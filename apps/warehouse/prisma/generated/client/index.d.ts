
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model CanvassItem
 * 
 */
export type CanvassItem = $Result.DefaultSelection<Prisma.$CanvassItemPayload>
/**
 * Model Canvass
 * 
 */
export type Canvass = $Result.DefaultSelection<Prisma.$CanvassPayload>
/**
 * Model JO
 * 
 */
export type JO = $Result.DefaultSelection<Prisma.$JOPayload>
/**
 * Model JOApprover
 * 
 */
export type JOApprover = $Result.DefaultSelection<Prisma.$JOApproverPayload>
/**
 * Model RV
 * 
 */
export type RV = $Result.DefaultSelection<Prisma.$RVPayload>
/**
 * Model RVApprover
 * 
 */
export type RVApprover = $Result.DefaultSelection<Prisma.$RVApproverPayload>
/**
 * Model SPR
 * 
 */
export type SPR = $Result.DefaultSelection<Prisma.$SPRPayload>
/**
 * Model SPRApprover
 * 
 */
export type SPRApprover = $Result.DefaultSelection<Prisma.$SPRApproverPayload>
/**
 * Model MEQS
 * 
 */
export type MEQS = $Result.DefaultSelection<Prisma.$MEQSPayload>
/**
 * Model MEQSSupplier
 * 
 */
export type MEQSSupplier = $Result.DefaultSelection<Prisma.$MEQSSupplierPayload>
/**
 * Model MEQSSupplierItem
 * 
 */
export type MEQSSupplierItem = $Result.DefaultSelection<Prisma.$MEQSSupplierItemPayload>
/**
 * Model MEQSSupplierAttachment
 * 
 */
export type MEQSSupplierAttachment = $Result.DefaultSelection<Prisma.$MEQSSupplierAttachmentPayload>
/**
 * Model MEQSApprover
 * 
 */
export type MEQSApprover = $Result.DefaultSelection<Prisma.$MEQSApproverPayload>
/**
 * Model PO
 * 
 */
export type PO = $Result.DefaultSelection<Prisma.$POPayload>
/**
 * Model POApprover
 * 
 */
export type POApprover = $Result.DefaultSelection<Prisma.$POApproverPayload>
/**
 * Model RR
 * 
 */
export type RR = $Result.DefaultSelection<Prisma.$RRPayload>
/**
 * Model RRApprover
 * 
 */
export type RRApprover = $Result.DefaultSelection<Prisma.$RRApproverPayload>
/**
 * Model RRItem
 * 
 */
export type RRItem = $Result.DefaultSelection<Prisma.$RRItemPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ItemType
 * 
 */
export type ItemType = $Result.DefaultSelection<Prisma.$ItemTypePayload>
/**
 * Model ItemTransaction
 * 
 */
export type ItemTransaction = $Result.DefaultSelection<Prisma.$ItemTransactionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Suppliers
 * const suppliers = await prisma.supplier.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Suppliers
   * const suppliers = await prisma.supplier.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs>;

  /**
   * `prisma.canvassItem`: Exposes CRUD operations for the **CanvassItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvassItems
    * const canvassItems = await prisma.canvassItem.findMany()
    * ```
    */
  get canvassItem(): Prisma.CanvassItemDelegate<ExtArgs>;

  /**
   * `prisma.canvass`: Exposes CRUD operations for the **Canvass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Canvasses
    * const canvasses = await prisma.canvass.findMany()
    * ```
    */
  get canvass(): Prisma.CanvassDelegate<ExtArgs>;

  /**
   * `prisma.jO`: Exposes CRUD operations for the **JO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JOS
    * const jOS = await prisma.jO.findMany()
    * ```
    */
  get jO(): Prisma.JODelegate<ExtArgs>;

  /**
   * `prisma.jOApprover`: Exposes CRUD operations for the **JOApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JOApprovers
    * const jOApprovers = await prisma.jOApprover.findMany()
    * ```
    */
  get jOApprover(): Prisma.JOApproverDelegate<ExtArgs>;

  /**
   * `prisma.rV`: Exposes CRUD operations for the **RV** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RVS
    * const rVS = await prisma.rV.findMany()
    * ```
    */
  get rV(): Prisma.RVDelegate<ExtArgs>;

  /**
   * `prisma.rVApprover`: Exposes CRUD operations for the **RVApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RVApprovers
    * const rVApprovers = await prisma.rVApprover.findMany()
    * ```
    */
  get rVApprover(): Prisma.RVApproverDelegate<ExtArgs>;

  /**
   * `prisma.sPR`: Exposes CRUD operations for the **SPR** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SPRS
    * const sPRS = await prisma.sPR.findMany()
    * ```
    */
  get sPR(): Prisma.SPRDelegate<ExtArgs>;

  /**
   * `prisma.sPRApprover`: Exposes CRUD operations for the **SPRApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SPRApprovers
    * const sPRApprovers = await prisma.sPRApprover.findMany()
    * ```
    */
  get sPRApprover(): Prisma.SPRApproverDelegate<ExtArgs>;

  /**
   * `prisma.mEQS`: Exposes CRUD operations for the **MEQS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQS
    * const mEQS = await prisma.mEQS.findMany()
    * ```
    */
  get mEQS(): Prisma.MEQSDelegate<ExtArgs>;

  /**
   * `prisma.mEQSSupplier`: Exposes CRUD operations for the **MEQSSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSSuppliers
    * const mEQSSuppliers = await prisma.mEQSSupplier.findMany()
    * ```
    */
  get mEQSSupplier(): Prisma.MEQSSupplierDelegate<ExtArgs>;

  /**
   * `prisma.mEQSSupplierItem`: Exposes CRUD operations for the **MEQSSupplierItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSSupplierItems
    * const mEQSSupplierItems = await prisma.mEQSSupplierItem.findMany()
    * ```
    */
  get mEQSSupplierItem(): Prisma.MEQSSupplierItemDelegate<ExtArgs>;

  /**
   * `prisma.mEQSSupplierAttachment`: Exposes CRUD operations for the **MEQSSupplierAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSSupplierAttachments
    * const mEQSSupplierAttachments = await prisma.mEQSSupplierAttachment.findMany()
    * ```
    */
  get mEQSSupplierAttachment(): Prisma.MEQSSupplierAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.mEQSApprover`: Exposes CRUD operations for the **MEQSApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEQSApprovers
    * const mEQSApprovers = await prisma.mEQSApprover.findMany()
    * ```
    */
  get mEQSApprover(): Prisma.MEQSApproverDelegate<ExtArgs>;

  /**
   * `prisma.pO`: Exposes CRUD operations for the **PO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POS
    * const pOS = await prisma.pO.findMany()
    * ```
    */
  get pO(): Prisma.PODelegate<ExtArgs>;

  /**
   * `prisma.pOApprover`: Exposes CRUD operations for the **POApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POApprovers
    * const pOApprovers = await prisma.pOApprover.findMany()
    * ```
    */
  get pOApprover(): Prisma.POApproverDelegate<ExtArgs>;

  /**
   * `prisma.rR`: Exposes CRUD operations for the **RR** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RRS
    * const rRS = await prisma.rR.findMany()
    * ```
    */
  get rR(): Prisma.RRDelegate<ExtArgs>;

  /**
   * `prisma.rRApprover`: Exposes CRUD operations for the **RRApprover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RRApprovers
    * const rRApprovers = await prisma.rRApprover.findMany()
    * ```
    */
  get rRApprover(): Prisma.RRApproverDelegate<ExtArgs>;

  /**
   * `prisma.rRItem`: Exposes CRUD operations for the **RRItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RRItems
    * const rRItems = await prisma.rRItem.findMany()
    * ```
    */
  get rRItem(): Prisma.RRItemDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.itemType`: Exposes CRUD operations for the **ItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTypes
    * const itemTypes = await prisma.itemType.findMany()
    * ```
    */
  get itemType(): Prisma.ItemTypeDelegate<ExtArgs>;

  /**
   * `prisma.itemTransaction`: Exposes CRUD operations for the **ItemTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTransactions
    * const itemTransactions = await prisma.itemTransaction.findMany()
    * ```
    */
  get itemTransaction(): Prisma.ItemTransactionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Supplier: 'Supplier',
    Unit: 'Unit',
    Brand: 'Brand',
    Vehicle: 'Vehicle',
    CanvassItem: 'CanvassItem',
    Canvass: 'Canvass',
    JO: 'JO',
    JOApprover: 'JOApprover',
    RV: 'RV',
    RVApprover: 'RVApprover',
    SPR: 'SPR',
    SPRApprover: 'SPRApprover',
    MEQS: 'MEQS',
    MEQSSupplier: 'MEQSSupplier',
    MEQSSupplierItem: 'MEQSSupplierItem',
    MEQSSupplierAttachment: 'MEQSSupplierAttachment',
    MEQSApprover: 'MEQSApprover',
    PO: 'PO',
    POApprover: 'POApprover',
    RR: 'RR',
    RRApprover: 'RRApprover',
    RRItem: 'RRItem',
    Item: 'Item',
    ItemType: 'ItemType',
    ItemTransaction: 'ItemTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'supplier' | 'unit' | 'brand' | 'vehicle' | 'canvassItem' | 'canvass' | 'jO' | 'jOApprover' | 'rV' | 'rVApprover' | 'sPR' | 'sPRApprover' | 'mEQS' | 'mEQSSupplier' | 'mEQSSupplierItem' | 'mEQSSupplierAttachment' | 'mEQSApprover' | 'pO' | 'pOApprover' | 'rR' | 'rRApprover' | 'rRItem' | 'item' | 'itemType' | 'itemTransaction'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>,
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>,
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>,
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      CanvassItem: {
        payload: Prisma.$CanvassItemPayload<ExtArgs>
        fields: Prisma.CanvassItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvassItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvassItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          findFirst: {
            args: Prisma.CanvassItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvassItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          findMany: {
            args: Prisma.CanvassItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>[]
          }
          create: {
            args: Prisma.CanvassItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          createMany: {
            args: Prisma.CanvassItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CanvassItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          update: {
            args: Prisma.CanvassItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          deleteMany: {
            args: Prisma.CanvassItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CanvassItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CanvassItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassItemPayload>
          }
          aggregate: {
            args: Prisma.CanvassItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCanvassItem>
          }
          groupBy: {
            args: Prisma.CanvassItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CanvassItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvassItemCountArgs<ExtArgs>,
            result: $Utils.Optional<CanvassItemCountAggregateOutputType> | number
          }
        }
      }
      Canvass: {
        payload: Prisma.$CanvassPayload<ExtArgs>
        fields: Prisma.CanvassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvassFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvassFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          findFirst: {
            args: Prisma.CanvassFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvassFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          findMany: {
            args: Prisma.CanvassFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>[]
          }
          create: {
            args: Prisma.CanvassCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          createMany: {
            args: Prisma.CanvassCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CanvassDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          update: {
            args: Prisma.CanvassUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          deleteMany: {
            args: Prisma.CanvassDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CanvassUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CanvassUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CanvassPayload>
          }
          aggregate: {
            args: Prisma.CanvassAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCanvass>
          }
          groupBy: {
            args: Prisma.CanvassGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CanvassGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvassCountArgs<ExtArgs>,
            result: $Utils.Optional<CanvassCountAggregateOutputType> | number
          }
        }
      }
      JO: {
        payload: Prisma.$JOPayload<ExtArgs>
        fields: Prisma.JOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JOFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JOFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          findFirst: {
            args: Prisma.JOFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JOFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          findMany: {
            args: Prisma.JOFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>[]
          }
          create: {
            args: Prisma.JOCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          createMany: {
            args: Prisma.JOCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JODeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          update: {
            args: Prisma.JOUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          deleteMany: {
            args: Prisma.JODeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JOUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JOUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOPayload>
          }
          aggregate: {
            args: Prisma.JOAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJO>
          }
          groupBy: {
            args: Prisma.JOGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JOGroupByOutputType>[]
          }
          count: {
            args: Prisma.JOCountArgs<ExtArgs>,
            result: $Utils.Optional<JOCountAggregateOutputType> | number
          }
        }
      }
      JOApprover: {
        payload: Prisma.$JOApproverPayload<ExtArgs>
        fields: Prisma.JOApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JOApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JOApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          findFirst: {
            args: Prisma.JOApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JOApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          findMany: {
            args: Prisma.JOApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>[]
          }
          create: {
            args: Prisma.JOApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          createMany: {
            args: Prisma.JOApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JOApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          update: {
            args: Prisma.JOApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          deleteMany: {
            args: Prisma.JOApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JOApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JOApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JOApproverPayload>
          }
          aggregate: {
            args: Prisma.JOApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJOApprover>
          }
          groupBy: {
            args: Prisma.JOApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JOApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.JOApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<JOApproverCountAggregateOutputType> | number
          }
        }
      }
      RV: {
        payload: Prisma.$RVPayload<ExtArgs>
        fields: Prisma.RVFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RVFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RVFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          findFirst: {
            args: Prisma.RVFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RVFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          findMany: {
            args: Prisma.RVFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>[]
          }
          create: {
            args: Prisma.RVCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          createMany: {
            args: Prisma.RVCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RVDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          update: {
            args: Prisma.RVUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          deleteMany: {
            args: Prisma.RVDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RVUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RVUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVPayload>
          }
          aggregate: {
            args: Prisma.RVAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRV>
          }
          groupBy: {
            args: Prisma.RVGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RVGroupByOutputType>[]
          }
          count: {
            args: Prisma.RVCountArgs<ExtArgs>,
            result: $Utils.Optional<RVCountAggregateOutputType> | number
          }
        }
      }
      RVApprover: {
        payload: Prisma.$RVApproverPayload<ExtArgs>
        fields: Prisma.RVApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RVApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RVApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          findFirst: {
            args: Prisma.RVApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RVApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          findMany: {
            args: Prisma.RVApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>[]
          }
          create: {
            args: Prisma.RVApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          createMany: {
            args: Prisma.RVApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RVApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          update: {
            args: Prisma.RVApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          deleteMany: {
            args: Prisma.RVApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RVApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RVApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RVApproverPayload>
          }
          aggregate: {
            args: Prisma.RVApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRVApprover>
          }
          groupBy: {
            args: Prisma.RVApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RVApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.RVApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<RVApproverCountAggregateOutputType> | number
          }
        }
      }
      SPR: {
        payload: Prisma.$SPRPayload<ExtArgs>
        fields: Prisma.SPRFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SPRFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SPRFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          findFirst: {
            args: Prisma.SPRFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SPRFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          findMany: {
            args: Prisma.SPRFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>[]
          }
          create: {
            args: Prisma.SPRCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          createMany: {
            args: Prisma.SPRCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SPRDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          update: {
            args: Prisma.SPRUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          deleteMany: {
            args: Prisma.SPRDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SPRUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SPRUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRPayload>
          }
          aggregate: {
            args: Prisma.SPRAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSPR>
          }
          groupBy: {
            args: Prisma.SPRGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SPRGroupByOutputType>[]
          }
          count: {
            args: Prisma.SPRCountArgs<ExtArgs>,
            result: $Utils.Optional<SPRCountAggregateOutputType> | number
          }
        }
      }
      SPRApprover: {
        payload: Prisma.$SPRApproverPayload<ExtArgs>
        fields: Prisma.SPRApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SPRApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SPRApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          findFirst: {
            args: Prisma.SPRApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SPRApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          findMany: {
            args: Prisma.SPRApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>[]
          }
          create: {
            args: Prisma.SPRApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          createMany: {
            args: Prisma.SPRApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SPRApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          update: {
            args: Prisma.SPRApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          deleteMany: {
            args: Prisma.SPRApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SPRApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SPRApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SPRApproverPayload>
          }
          aggregate: {
            args: Prisma.SPRApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSPRApprover>
          }
          groupBy: {
            args: Prisma.SPRApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SPRApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.SPRApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<SPRApproverCountAggregateOutputType> | number
          }
        }
      }
      MEQS: {
        payload: Prisma.$MEQSPayload<ExtArgs>
        fields: Prisma.MEQSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          findFirst: {
            args: Prisma.MEQSFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          findMany: {
            args: Prisma.MEQSFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>[]
          }
          create: {
            args: Prisma.MEQSCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          createMany: {
            args: Prisma.MEQSCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          update: {
            args: Prisma.MEQSUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          deleteMany: {
            args: Prisma.MEQSDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSPayload>
          }
          aggregate: {
            args: Prisma.MEQSAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQS>
          }
          groupBy: {
            args: Prisma.MEQSGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSCountAggregateOutputType> | number
          }
        }
      }
      MEQSSupplier: {
        payload: Prisma.$MEQSSupplierPayload<ExtArgs>
        fields: Prisma.MEQSSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSSupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSSupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          findFirst: {
            args: Prisma.MEQSSupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSSupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          findMany: {
            args: Prisma.MEQSSupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>[]
          }
          create: {
            args: Prisma.MEQSSupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          createMany: {
            args: Prisma.MEQSSupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSSupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          update: {
            args: Prisma.MEQSSupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          deleteMany: {
            args: Prisma.MEQSSupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSSupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSSupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierPayload>
          }
          aggregate: {
            args: Prisma.MEQSSupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSSupplier>
          }
          groupBy: {
            args: Prisma.MEQSSupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSSupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierCountAggregateOutputType> | number
          }
        }
      }
      MEQSSupplierItem: {
        payload: Prisma.$MEQSSupplierItemPayload<ExtArgs>
        fields: Prisma.MEQSSupplierItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSSupplierItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          findFirst: {
            args: Prisma.MEQSSupplierItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          findMany: {
            args: Prisma.MEQSSupplierItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>[]
          }
          create: {
            args: Prisma.MEQSSupplierItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          createMany: {
            args: Prisma.MEQSSupplierItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSSupplierItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          update: {
            args: Prisma.MEQSSupplierItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          deleteMany: {
            args: Prisma.MEQSSupplierItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSSupplierItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSSupplierItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierItemPayload>
          }
          aggregate: {
            args: Prisma.MEQSSupplierItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSSupplierItem>
          }
          groupBy: {
            args: Prisma.MEQSSupplierItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSSupplierItemCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierItemCountAggregateOutputType> | number
          }
        }
      }
      MEQSSupplierAttachment: {
        payload: Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>
        fields: Prisma.MEQSSupplierAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSSupplierAttachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MEQSSupplierAttachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          findMany: {
            args: Prisma.MEQSSupplierAttachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>[]
          }
          create: {
            args: Prisma.MEQSSupplierAttachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          createMany: {
            args: Prisma.MEQSSupplierAttachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSSupplierAttachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          update: {
            args: Prisma.MEQSSupplierAttachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MEQSSupplierAttachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSSupplierAttachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSSupplierAttachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSSupplierAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MEQSSupplierAttachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSSupplierAttachment>
          }
          groupBy: {
            args: Prisma.MEQSSupplierAttachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSSupplierAttachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSSupplierAttachmentCountAggregateOutputType> | number
          }
        }
      }
      MEQSApprover: {
        payload: Prisma.$MEQSApproverPayload<ExtArgs>
        fields: Prisma.MEQSApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEQSApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEQSApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          findFirst: {
            args: Prisma.MEQSApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEQSApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          findMany: {
            args: Prisma.MEQSApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>[]
          }
          create: {
            args: Prisma.MEQSApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          createMany: {
            args: Prisma.MEQSApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEQSApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          update: {
            args: Prisma.MEQSApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          deleteMany: {
            args: Prisma.MEQSApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEQSApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEQSApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEQSApproverPayload>
          }
          aggregate: {
            args: Prisma.MEQSApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEQSApprover>
          }
          groupBy: {
            args: Prisma.MEQSApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEQSApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEQSApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<MEQSApproverCountAggregateOutputType> | number
          }
        }
      }
      PO: {
        payload: Prisma.$POPayload<ExtArgs>
        fields: Prisma.POFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          findFirst: {
            args: Prisma.POFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          findMany: {
            args: Prisma.POFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>[]
          }
          create: {
            args: Prisma.POCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          createMany: {
            args: Prisma.POCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PODeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          update: {
            args: Prisma.POUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          deleteMany: {
            args: Prisma.PODeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.POUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.POUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POPayload>
          }
          aggregate: {
            args: Prisma.POAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePO>
          }
          groupBy: {
            args: Prisma.POGroupByArgs<ExtArgs>,
            result: $Utils.Optional<POGroupByOutputType>[]
          }
          count: {
            args: Prisma.POCountArgs<ExtArgs>,
            result: $Utils.Optional<POCountAggregateOutputType> | number
          }
        }
      }
      POApprover: {
        payload: Prisma.$POApproverPayload<ExtArgs>
        fields: Prisma.POApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          findFirst: {
            args: Prisma.POApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          findMany: {
            args: Prisma.POApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>[]
          }
          create: {
            args: Prisma.POApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          createMany: {
            args: Prisma.POApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.POApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          update: {
            args: Prisma.POApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          deleteMany: {
            args: Prisma.POApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.POApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.POApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$POApproverPayload>
          }
          aggregate: {
            args: Prisma.POApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePOApprover>
          }
          groupBy: {
            args: Prisma.POApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<POApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.POApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<POApproverCountAggregateOutputType> | number
          }
        }
      }
      RR: {
        payload: Prisma.$RRPayload<ExtArgs>
        fields: Prisma.RRFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RRFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RRFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          findFirst: {
            args: Prisma.RRFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RRFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          findMany: {
            args: Prisma.RRFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>[]
          }
          create: {
            args: Prisma.RRCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          createMany: {
            args: Prisma.RRCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RRDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          update: {
            args: Prisma.RRUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          deleteMany: {
            args: Prisma.RRDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RRUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RRUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRPayload>
          }
          aggregate: {
            args: Prisma.RRAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRR>
          }
          groupBy: {
            args: Prisma.RRGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RRGroupByOutputType>[]
          }
          count: {
            args: Prisma.RRCountArgs<ExtArgs>,
            result: $Utils.Optional<RRCountAggregateOutputType> | number
          }
        }
      }
      RRApprover: {
        payload: Prisma.$RRApproverPayload<ExtArgs>
        fields: Prisma.RRApproverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RRApproverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RRApproverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          findFirst: {
            args: Prisma.RRApproverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RRApproverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          findMany: {
            args: Prisma.RRApproverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>[]
          }
          create: {
            args: Prisma.RRApproverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          createMany: {
            args: Prisma.RRApproverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RRApproverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          update: {
            args: Prisma.RRApproverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          deleteMany: {
            args: Prisma.RRApproverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RRApproverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RRApproverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRApproverPayload>
          }
          aggregate: {
            args: Prisma.RRApproverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRRApprover>
          }
          groupBy: {
            args: Prisma.RRApproverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RRApproverGroupByOutputType>[]
          }
          count: {
            args: Prisma.RRApproverCountArgs<ExtArgs>,
            result: $Utils.Optional<RRApproverCountAggregateOutputType> | number
          }
        }
      }
      RRItem: {
        payload: Prisma.$RRItemPayload<ExtArgs>
        fields: Prisma.RRItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RRItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RRItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          findFirst: {
            args: Prisma.RRItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RRItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          findMany: {
            args: Prisma.RRItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>[]
          }
          create: {
            args: Prisma.RRItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          createMany: {
            args: Prisma.RRItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RRItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          update: {
            args: Prisma.RRItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          deleteMany: {
            args: Prisma.RRItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RRItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RRItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RRItemPayload>
          }
          aggregate: {
            args: Prisma.RRItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRRItem>
          }
          groupBy: {
            args: Prisma.RRItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RRItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RRItemCountArgs<ExtArgs>,
            result: $Utils.Optional<RRItemCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ItemType: {
        payload: Prisma.$ItemTypePayload<ExtArgs>
        fields: Prisma.ItemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findFirst: {
            args: Prisma.ItemTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findMany: {
            args: Prisma.ItemTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          create: {
            args: Prisma.ItemTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          createMany: {
            args: Prisma.ItemTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          update: {
            args: Prisma.ItemTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          deleteMany: {
            args: Prisma.ItemTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          aggregate: {
            args: Prisma.ItemTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemType>
          }
          groupBy: {
            args: Prisma.ItemTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemTypeCountAggregateOutputType> | number
          }
        }
      }
      ItemTransaction: {
        payload: Prisma.$ItemTransactionPayload<ExtArgs>
        fields: Prisma.ItemTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          findFirst: {
            args: Prisma.ItemTransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          findMany: {
            args: Prisma.ItemTransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>[]
          }
          create: {
            args: Prisma.ItemTransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          createMany: {
            args: Prisma.ItemTransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemTransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          update: {
            args: Prisma.ItemTransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          deleteMany: {
            args: Prisma.ItemTransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemTransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTransactionPayload>
          }
          aggregate: {
            args: Prisma.ItemTransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemTransaction>
          }
          groupBy: {
            args: Prisma.ItemTransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    MEQSSupplier: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MEQSSupplier?: boolean | SupplierCountOutputTypeCountMEQSSupplierArgs
  }

  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountMEQSSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierWhereInput
  }



  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    canvass_items: number
    rr_items: number
    items: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | UnitCountOutputTypeCountCanvass_itemsArgs
    rr_items?: boolean | UnitCountOutputTypeCountRr_itemsArgs
    items?: boolean | UnitCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountCanvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountRr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
  }


  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }



  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    canvass_items: number
    rr_items: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | BrandCountOutputTypeCountCanvass_itemsArgs
    rr_items?: boolean | BrandCountOutputTypeCountRr_itemsArgs
  }

  // Custom InputTypes

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountCanvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
  }


  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountRr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
  }



  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    sprs: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprs?: boolean | VehicleCountOutputTypeCountSprsArgs
  }

  // Custom InputTypes

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountSprsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRWhereInput
  }



  /**
   * Count Type CanvassItemCountOutputType
   */

  export type CanvassItemCountOutputType = {
    meqs_supplier_items: number
  }

  export type CanvassItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_supplier_items?: boolean | CanvassItemCountOutputTypeCountMeqs_supplier_itemsArgs
  }

  // Custom InputTypes

  /**
   * CanvassItemCountOutputType without action
   */
  export type CanvassItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItemCountOutputType
     */
    select?: CanvassItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CanvassItemCountOutputType without action
   */
  export type CanvassItemCountOutputTypeCountMeqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierItemWhereInput
  }



  /**
   * Count Type CanvassCountOutputType
   */

  export type CanvassCountOutputType = {
    canvass_items: number
  }

  export type CanvassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | CanvassCountOutputTypeCountCanvass_itemsArgs
  }

  // Custom InputTypes

  /**
   * CanvassCountOutputType without action
   */
  export type CanvassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassCountOutputType
     */
    select?: CanvassCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CanvassCountOutputType without action
   */
  export type CanvassCountOutputTypeCountCanvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
  }



  /**
   * Count Type JOCountOutputType
   */

  export type JOCountOutputType = {
    jo_approvers: number
  }

  export type JOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jo_approvers?: boolean | JOCountOutputTypeCountJo_approversArgs
  }

  // Custom InputTypes

  /**
   * JOCountOutputType without action
   */
  export type JOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOCountOutputType
     */
    select?: JOCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JOCountOutputType without action
   */
  export type JOCountOutputTypeCountJo_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOApproverWhereInput
  }



  /**
   * Count Type RVCountOutputType
   */

  export type RVCountOutputType = {
    rv_approvers: number
  }

  export type RVCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rv_approvers?: boolean | RVCountOutputTypeCountRv_approversArgs
  }

  // Custom InputTypes

  /**
   * RVCountOutputType without action
   */
  export type RVCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVCountOutputType
     */
    select?: RVCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RVCountOutputType without action
   */
  export type RVCountOutputTypeCountRv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RVApproverWhereInput
  }



  /**
   * Count Type SPRCountOutputType
   */

  export type SPRCountOutputType = {
    spr_approvers: number
  }

  export type SPRCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spr_approvers?: boolean | SPRCountOutputTypeCountSpr_approversArgs
  }

  // Custom InputTypes

  /**
   * SPRCountOutputType without action
   */
  export type SPRCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRCountOutputType
     */
    select?: SPRCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SPRCountOutputType without action
   */
  export type SPRCountOutputTypeCountSpr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRApproverWhereInput
  }



  /**
   * Count Type MEQSCountOutputType
   */

  export type MEQSCountOutputType = {
    meqs_approvers: number
    meqs_suppliers: number
  }

  export type MEQSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_approvers?: boolean | MEQSCountOutputTypeCountMeqs_approversArgs
    meqs_suppliers?: boolean | MEQSCountOutputTypeCountMeqs_suppliersArgs
  }

  // Custom InputTypes

  /**
   * MEQSCountOutputType without action
   */
  export type MEQSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSCountOutputType
     */
    select?: MEQSCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MEQSCountOutputType without action
   */
  export type MEQSCountOutputTypeCountMeqs_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSApproverWhereInput
  }


  /**
   * MEQSCountOutputType without action
   */
  export type MEQSCountOutputTypeCountMeqs_suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierWhereInput
  }



  /**
   * Count Type MEQSSupplierCountOutputType
   */

  export type MEQSSupplierCountOutputType = {
    attachments: number
    meqs_supplier_items: number
  }

  export type MEQSSupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MEQSSupplierCountOutputTypeCountAttachmentsArgs
    meqs_supplier_items?: boolean | MEQSSupplierCountOutputTypeCountMeqs_supplier_itemsArgs
  }

  // Custom InputTypes

  /**
   * MEQSSupplierCountOutputType without action
   */
  export type MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierCountOutputType
     */
    select?: MEQSSupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MEQSSupplierCountOutputType without action
   */
  export type MEQSSupplierCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierAttachmentWhereInput
  }


  /**
   * MEQSSupplierCountOutputType without action
   */
  export type MEQSSupplierCountOutputTypeCountMeqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierItemWhereInput
  }



  /**
   * Count Type POCountOutputType
   */

  export type POCountOutputType = {
    po_approvers: number
  }

  export type POCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po_approvers?: boolean | POCountOutputTypeCountPo_approversArgs
  }

  // Custom InputTypes

  /**
   * POCountOutputType without action
   */
  export type POCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POCountOutputType
     */
    select?: POCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * POCountOutputType without action
   */
  export type POCountOutputTypeCountPo_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POApproverWhereInput
  }



  /**
   * Count Type RRCountOutputType
   */

  export type RRCountOutputType = {
    rr_approvers: number
    rr_items: number
  }

  export type RRCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rr_approvers?: boolean | RRCountOutputTypeCountRr_approversArgs
    rr_items?: boolean | RRCountOutputTypeCountRr_itemsArgs
  }

  // Custom InputTypes

  /**
   * RRCountOutputType without action
   */
  export type RRCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRCountOutputType
     */
    select?: RRCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RRCountOutputType without action
   */
  export type RRCountOutputTypeCountRr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRApproverWhereInput
  }


  /**
   * RRCountOutputType without action
   */
  export type RRCountOutputTypeCountRr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
  }



  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    item_transactions: number
    rr_items: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_transactions?: boolean | ItemCountOutputTypeCountItem_transactionsArgs
    rr_items?: boolean | ItemCountOutputTypeCountRr_itemsArgs
  }

  // Custom InputTypes

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountItem_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTransactionWhereInput
  }


  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountRr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
  }



  /**
   * Count Type ItemTypeCountOutputType
   */

  export type ItemTypeCountOutputType = {
    items: number
  }

  export type ItemTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemTypeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTypeCountOutputType
     */
    select?: ItemTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    contact: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    MEQSSupplier?: boolean | Supplier$MEQSSupplierArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MEQSSupplier?: boolean | Supplier$MEQSSupplierArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      MEQSSupplier: Prisma.$MEQSSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contact: string
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }


  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    MEQSSupplier<T extends Supplier$MEQSSupplierArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$MEQSSupplierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contact: FieldRef<"Supplier", 'String'>
    readonly created_at: FieldRef<"Supplier", 'DateTime'>
    readonly updated_at: FieldRef<"Supplier", 'DateTime'>
    readonly is_deleted: FieldRef<"Supplier", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }


  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }


  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier.MEQSSupplier
   */
  export type Supplier$MEQSSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    where?: MEQSSupplierWhereInput
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    cursor?: MEQSSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
  }



  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    canvass_items?: boolean | Unit$canvass_itemsArgs<ExtArgs>
    rr_items?: boolean | Unit$rr_itemsArgs<ExtArgs>
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | Unit$canvass_itemsArgs<ExtArgs>
    rr_items?: boolean | Unit$rr_itemsArgs<ExtArgs>
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      canvass_items: Prisma.$CanvassItemPayload<ExtArgs>[]
      rr_items: Prisma.$RRItemPayload<ExtArgs>[]
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }


  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
    **/
    create<T extends UnitCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitCreateArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Units.
     *     @param {UnitCreateManyArgs} args - Arguments to create many Units.
     *     @example
     *     // Create many Units
     *     const unit = await prisma.unit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UnitCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
    **/
    delete<T extends UnitDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
    **/
    upsert<T extends UnitUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>
    ): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass_items<T extends Unit$canvass_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$canvass_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    rr_items<T extends Unit$rr_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$rr_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    items<T extends Unit$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly created_at: FieldRef<"Unit", 'DateTime'>
    readonly updated_at: FieldRef<"Unit", 'DateTime'>
    readonly is_deleted: FieldRef<"Unit", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }


  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }


  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }


  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }


  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }


  /**
   * Unit.canvass_items
   */
  export type Unit$canvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    cursor?: CanvassItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * Unit.rr_items
   */
  export type Unit$rr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    cursor?: RRItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * Unit.items
   */
  export type Unit$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
  }



  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    canvass_items?: boolean | Brand$canvass_itemsArgs<ExtArgs>
    rr_items?: boolean | Brand$rr_itemsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | Brand$canvass_itemsArgs<ExtArgs>
    rr_items?: boolean | Brand$rr_itemsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      canvass_items: Prisma.$CanvassItemPayload<ExtArgs>[]
      rr_items: Prisma.$RRItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }


  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BrandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Brand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BrandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BrandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
    **/
    create<T extends BrandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandCreateArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Brands.
     *     @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     *     @example
     *     // Create many Brands
     *     const brand = await prisma.brand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BrandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
    **/
    delete<T extends BrandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BrandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BrandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BrandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
    **/
    upsert<T extends BrandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass_items<T extends Brand$canvass_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$canvass_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    rr_items<T extends Brand$rr_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$rr_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Brand model
   */ 
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly created_at: FieldRef<"Brand", 'DateTime'>
    readonly updated_at: FieldRef<"Brand", 'DateTime'>
    readonly is_deleted: FieldRef<"Brand", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }


  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
  }


  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }


  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
  }


  /**
   * Brand.canvass_items
   */
  export type Brand$canvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    cursor?: CanvassItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * Brand.rr_items
   */
  export type Brand$rr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    cursor?: RRItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
  }



  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    name: string | null
    plate_number: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    plate_number: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    name: number
    plate_number: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type VehicleMinAggregateInputType = {
    id?: true
    name?: true
    plate_number?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    name?: true
    plate_number?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    name?: true
    plate_number?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    name: string
    plate_number: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: VehicleCountAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plate_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    sprs?: boolean | Vehicle$sprsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    name?: boolean
    plate_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprs?: boolean | Vehicle$sprsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      sprs: Prisma.$SPRPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      plate_number: string
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }


  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VehicleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Vehicle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VehicleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VehicleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
    **/
    create<T extends VehicleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Vehicles.
     *     @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     *     @example
     *     // Create many Vehicles
     *     const vehicle = await prisma.vehicle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VehicleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
    **/
    delete<T extends VehicleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VehicleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VehicleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VehicleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
    **/
    upsert<T extends VehicleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>
    ): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sprs<T extends Vehicle$sprsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$sprsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Vehicle model
   */ 
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly name: FieldRef<"Vehicle", 'String'>
    readonly plate_number: FieldRef<"Vehicle", 'String'>
    readonly created_at: FieldRef<"Vehicle", 'DateTime'>
    readonly updated_at: FieldRef<"Vehicle", 'DateTime'>
    readonly is_deleted: FieldRef<"Vehicle", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }


  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }


  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }


  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }


  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
  }


  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }


  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }


  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
  }


  /**
   * Vehicle.sprs
   */
  export type Vehicle$sprsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    where?: SPRWhereInput
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    cursor?: SPRWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VehicleInclude<ExtArgs> | null
  }



  /**
   * Model CanvassItem
   */

  export type AggregateCanvassItem = {
    _count: CanvassItemCountAggregateOutputType | null
    _avg: CanvassItemAvgAggregateOutputType | null
    _sum: CanvassItemSumAggregateOutputType | null
    _min: CanvassItemMinAggregateOutputType | null
    _max: CanvassItemMaxAggregateOutputType | null
  }

  export type CanvassItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CanvassItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type CanvassItemMinAggregateOutputType = {
    id: string | null
    canvass_id: string | null
    description: string | null
    brand_id: string | null
    unit_id: string | null
    quantity: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type CanvassItemMaxAggregateOutputType = {
    id: string | null
    canvass_id: string | null
    description: string | null
    brand_id: string | null
    unit_id: string | null
    quantity: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type CanvassItemCountAggregateOutputType = {
    id: number
    canvass_id: number
    description: number
    brand_id: number
    unit_id: number
    quantity: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type CanvassItemAvgAggregateInputType = {
    quantity?: true
  }

  export type CanvassItemSumAggregateInputType = {
    quantity?: true
  }

  export type CanvassItemMinAggregateInputType = {
    id?: true
    canvass_id?: true
    description?: true
    brand_id?: true
    unit_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type CanvassItemMaxAggregateInputType = {
    id?: true
    canvass_id?: true
    description?: true
    brand_id?: true
    unit_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type CanvassItemCountAggregateInputType = {
    id?: true
    canvass_id?: true
    description?: true
    brand_id?: true
    unit_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type CanvassItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvassItem to aggregate.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvassItems
    **/
    _count?: true | CanvassItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CanvassItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CanvassItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvassItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvassItemMaxAggregateInputType
  }

  export type GetCanvassItemAggregateType<T extends CanvassItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvassItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvassItem[P]>
      : GetScalarType<T[P], AggregateCanvassItem[P]>
  }




  export type CanvassItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithAggregationInput | CanvassItemOrderByWithAggregationInput[]
    by: CanvassItemScalarFieldEnum[] | CanvassItemScalarFieldEnum
    having?: CanvassItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvassItemCountAggregateInputType | true
    _avg?: CanvassItemAvgAggregateInputType
    _sum?: CanvassItemSumAggregateInputType
    _min?: CanvassItemMinAggregateInputType
    _max?: CanvassItemMaxAggregateInputType
  }

  export type CanvassItemGroupByOutputType = {
    id: string
    canvass_id: string
    description: string
    brand_id: string | null
    unit_id: string
    quantity: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: CanvassItemCountAggregateOutputType | null
    _avg: CanvassItemAvgAggregateOutputType | null
    _sum: CanvassItemSumAggregateOutputType | null
    _min: CanvassItemMinAggregateOutputType | null
    _max: CanvassItemMaxAggregateOutputType | null
  }

  type GetCanvassItemGroupByPayload<T extends CanvassItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvassItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvassItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvassItemGroupByOutputType[P]>
            : GetScalarType<T[P], CanvassItemGroupByOutputType[P]>
        }
      >
    >


  export type CanvassItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvass_id?: boolean
    description?: boolean
    brand_id?: boolean
    unit_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    brand?: boolean | CanvassItem$brandArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    meqs_supplier_items?: boolean | CanvassItem$meqs_supplier_itemsArgs<ExtArgs>
    _count?: boolean | CanvassItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvassItem"]>

  export type CanvassItemSelectScalar = {
    id?: boolean
    canvass_id?: boolean
    description?: boolean
    brand_id?: boolean
    unit_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type CanvassItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    brand?: boolean | CanvassItem$brandArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    meqs_supplier_items?: boolean | CanvassItem$meqs_supplier_itemsArgs<ExtArgs>
    _count?: boolean | CanvassItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CanvassItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvassItem"
    objects: {
      canvass: Prisma.$CanvassPayload<ExtArgs>
      brand: Prisma.$BrandPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs>
      meqs_supplier_items: Prisma.$MEQSSupplierItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvass_id: string
      description: string
      brand_id: string | null
      unit_id: string
      quantity: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["canvassItem"]>
    composites: {}
  }


  type CanvassItemGetPayload<S extends boolean | null | undefined | CanvassItemDefaultArgs> = $Result.GetResult<Prisma.$CanvassItemPayload, S>

  type CanvassItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CanvassItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CanvassItemCountAggregateInputType | true
    }

  export interface CanvassItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvassItem'], meta: { name: 'CanvassItem' } }
    /**
     * Find zero or one CanvassItem that matches the filter.
     * @param {CanvassItemFindUniqueArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CanvassItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemFindUniqueArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CanvassItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CanvassItemFindUniqueOrThrowArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CanvassItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CanvassItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemFindFirstArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CanvassItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindFirstArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CanvassItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemFindFirstOrThrowArgs} args - Arguments to find a CanvassItem
     * @example
     * // Get one CanvassItem
     * const canvassItem = await prisma.canvassItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CanvassItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CanvassItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvassItems
     * const canvassItems = await prisma.canvassItem.findMany()
     * 
     * // Get first 10 CanvassItems
     * const canvassItems = await prisma.canvassItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvassItemWithIdOnly = await prisma.canvassItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CanvassItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CanvassItem.
     * @param {CanvassItemCreateArgs} args - Arguments to create a CanvassItem.
     * @example
     * // Create one CanvassItem
     * const CanvassItem = await prisma.canvassItem.create({
     *   data: {
     *     // ... data to create a CanvassItem
     *   }
     * })
     * 
    **/
    create<T extends CanvassItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemCreateArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CanvassItems.
     *     @param {CanvassItemCreateManyArgs} args - Arguments to create many CanvassItems.
     *     @example
     *     // Create many CanvassItems
     *     const canvassItem = await prisma.canvassItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CanvassItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CanvassItem.
     * @param {CanvassItemDeleteArgs} args - Arguments to delete one CanvassItem.
     * @example
     * // Delete one CanvassItem
     * const CanvassItem = await prisma.canvassItem.delete({
     *   where: {
     *     // ... filter to delete one CanvassItem
     *   }
     * })
     * 
    **/
    delete<T extends CanvassItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemDeleteArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CanvassItem.
     * @param {CanvassItemUpdateArgs} args - Arguments to update one CanvassItem.
     * @example
     * // Update one CanvassItem
     * const canvassItem = await prisma.canvassItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CanvassItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemUpdateArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CanvassItems.
     * @param {CanvassItemDeleteManyArgs} args - Arguments to filter CanvassItems to delete.
     * @example
     * // Delete a few CanvassItems
     * const { count } = await prisma.canvassItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CanvassItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvassItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvassItems
     * const canvassItem = await prisma.canvassItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CanvassItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CanvassItem.
     * @param {CanvassItemUpsertArgs} args - Arguments to update or create a CanvassItem.
     * @example
     * // Update or create a CanvassItem
     * const canvassItem = await prisma.canvassItem.upsert({
     *   create: {
     *     // ... data to create a CanvassItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvassItem we want to update
     *   }
     * })
    **/
    upsert<T extends CanvassItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassItemUpsertArgs<ExtArgs>>
    ): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CanvassItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemCountArgs} args - Arguments to filter CanvassItems to count.
     * @example
     * // Count the number of CanvassItems
     * const count = await prisma.canvassItem.count({
     *   where: {
     *     // ... the filter for the CanvassItems we want to count
     *   }
     * })
    **/
    count<T extends CanvassItemCountArgs>(
      args?: Subset<T, CanvassItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvassItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvassItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvassItemAggregateArgs>(args: Subset<T, CanvassItemAggregateArgs>): Prisma.PrismaPromise<GetCanvassItemAggregateType<T>>

    /**
     * Group by CanvassItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvassItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvassItemGroupByArgs['orderBy'] }
        : { orderBy?: CanvassItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvassItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvassItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvassItem model
   */
  readonly fields: CanvassItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvassItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvassItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass<T extends CanvassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvassDefaultArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    brand<T extends CanvassItem$brandArgs<ExtArgs> = {}>(args?: Subset<T, CanvassItem$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    meqs_supplier_items<T extends CanvassItem$meqs_supplier_itemsArgs<ExtArgs> = {}>(args?: Subset<T, CanvassItem$meqs_supplier_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CanvassItem model
   */ 
  interface CanvassItemFieldRefs {
    readonly id: FieldRef<"CanvassItem", 'String'>
    readonly canvass_id: FieldRef<"CanvassItem", 'String'>
    readonly description: FieldRef<"CanvassItem", 'String'>
    readonly brand_id: FieldRef<"CanvassItem", 'String'>
    readonly unit_id: FieldRef<"CanvassItem", 'String'>
    readonly quantity: FieldRef<"CanvassItem", 'Int'>
    readonly created_at: FieldRef<"CanvassItem", 'DateTime'>
    readonly updated_at: FieldRef<"CanvassItem", 'DateTime'>
    readonly is_deleted: FieldRef<"CanvassItem", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CanvassItem findUnique
   */
  export type CanvassItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem findUniqueOrThrow
   */
  export type CanvassItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem findFirst
   */
  export type CanvassItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvassItems.
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvassItems.
     */
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * CanvassItem findFirstOrThrow
   */
  export type CanvassItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItem to fetch.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvassItems.
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvassItems.
     */
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * CanvassItem findMany
   */
  export type CanvassItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter, which CanvassItems to fetch.
     */
    where?: CanvassItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvassItems to fetch.
     */
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvassItems.
     */
    cursor?: CanvassItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvassItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvassItems.
     */
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * CanvassItem create
   */
  export type CanvassItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvassItem.
     */
    data: XOR<CanvassItemCreateInput, CanvassItemUncheckedCreateInput>
  }


  /**
   * CanvassItem createMany
   */
  export type CanvassItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvassItems.
     */
    data: CanvassItemCreateManyInput | CanvassItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CanvassItem update
   */
  export type CanvassItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvassItem.
     */
    data: XOR<CanvassItemUpdateInput, CanvassItemUncheckedUpdateInput>
    /**
     * Choose, which CanvassItem to update.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem updateMany
   */
  export type CanvassItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvassItems.
     */
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyInput>
    /**
     * Filter which CanvassItems to update
     */
    where?: CanvassItemWhereInput
  }


  /**
   * CanvassItem upsert
   */
  export type CanvassItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvassItem to update in case it exists.
     */
    where: CanvassItemWhereUniqueInput
    /**
     * In case the CanvassItem found by the `where` argument doesn't exist, create a new CanvassItem with this data.
     */
    create: XOR<CanvassItemCreateInput, CanvassItemUncheckedCreateInput>
    /**
     * In case the CanvassItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvassItemUpdateInput, CanvassItemUncheckedUpdateInput>
  }


  /**
   * CanvassItem delete
   */
  export type CanvassItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    /**
     * Filter which CanvassItem to delete.
     */
    where: CanvassItemWhereUniqueInput
  }


  /**
   * CanvassItem deleteMany
   */
  export type CanvassItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvassItems to delete
     */
    where?: CanvassItemWhereInput
  }


  /**
   * CanvassItem.brand
   */
  export type CanvassItem$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }


  /**
   * CanvassItem.meqs_supplier_items
   */
  export type CanvassItem$meqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    where?: MEQSSupplierItemWhereInput
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    cursor?: MEQSSupplierItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * CanvassItem without action
   */
  export type CanvassItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
  }



  /**
   * Model Canvass
   */

  export type AggregateCanvass = {
    _count: CanvassCountAggregateOutputType | null
    _min: CanvassMinAggregateOutputType | null
    _max: CanvassMaxAggregateOutputType | null
  }

  export type CanvassMinAggregateOutputType = {
    id: string | null
    rc_number: string | null
    date_requested: Date | null
    purpose: string | null
    notes: string | null
    requested_by_id: string | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type CanvassMaxAggregateOutputType = {
    id: string | null
    rc_number: string | null
    date_requested: Date | null
    purpose: string | null
    notes: string | null
    requested_by_id: string | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type CanvassCountAggregateOutputType = {
    id: number
    rc_number: number
    date_requested: number
    purpose: number
    notes: number
    requested_by_id: number
    is_referenced: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type CanvassMinAggregateInputType = {
    id?: true
    rc_number?: true
    date_requested?: true
    purpose?: true
    notes?: true
    requested_by_id?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type CanvassMaxAggregateInputType = {
    id?: true
    rc_number?: true
    date_requested?: true
    purpose?: true
    notes?: true
    requested_by_id?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type CanvassCountAggregateInputType = {
    id?: true
    rc_number?: true
    date_requested?: true
    purpose?: true
    notes?: true
    requested_by_id?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type CanvassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvass to aggregate.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Canvasses
    **/
    _count?: true | CanvassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvassMaxAggregateInputType
  }

  export type GetCanvassAggregateType<T extends CanvassAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvass[P]>
      : GetScalarType<T[P], AggregateCanvass[P]>
  }




  export type CanvassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvassWhereInput
    orderBy?: CanvassOrderByWithAggregationInput | CanvassOrderByWithAggregationInput[]
    by: CanvassScalarFieldEnum[] | CanvassScalarFieldEnum
    having?: CanvassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvassCountAggregateInputType | true
    _min?: CanvassMinAggregateInputType
    _max?: CanvassMaxAggregateInputType
  }

  export type CanvassGroupByOutputType = {
    id: string
    rc_number: string
    date_requested: Date
    purpose: string
    notes: string | null
    requested_by_id: string
    is_referenced: boolean
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: CanvassCountAggregateOutputType | null
    _min: CanvassMinAggregateOutputType | null
    _max: CanvassMaxAggregateOutputType | null
  }

  type GetCanvassGroupByPayload<T extends CanvassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvassGroupByOutputType[P]>
            : GetScalarType<T[P], CanvassGroupByOutputType[P]>
        }
      >
    >


  export type CanvassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rc_number?: boolean
    date_requested?: boolean
    purpose?: boolean
    notes?: boolean
    requested_by_id?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    canvass_items?: boolean | Canvass$canvass_itemsArgs<ExtArgs>
    jo?: boolean | Canvass$joArgs<ExtArgs>
    rv?: boolean | Canvass$rvArgs<ExtArgs>
    spr?: boolean | Canvass$sprArgs<ExtArgs>
    _count?: boolean | CanvassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvass"]>

  export type CanvassSelectScalar = {
    id?: boolean
    rc_number?: boolean
    date_requested?: boolean
    purpose?: boolean
    notes?: boolean
    requested_by_id?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type CanvassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_items?: boolean | Canvass$canvass_itemsArgs<ExtArgs>
    jo?: boolean | Canvass$joArgs<ExtArgs>
    rv?: boolean | Canvass$rvArgs<ExtArgs>
    spr?: boolean | Canvass$sprArgs<ExtArgs>
    _count?: boolean | CanvassCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CanvassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Canvass"
    objects: {
      canvass_items: Prisma.$CanvassItemPayload<ExtArgs>[]
      jo: Prisma.$JOPayload<ExtArgs> | null
      rv: Prisma.$RVPayload<ExtArgs> | null
      spr: Prisma.$SPRPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rc_number: string
      date_requested: Date
      purpose: string
      notes: string | null
      requested_by_id: string
      is_referenced: boolean
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["canvass"]>
    composites: {}
  }


  type CanvassGetPayload<S extends boolean | null | undefined | CanvassDefaultArgs> = $Result.GetResult<Prisma.$CanvassPayload, S>

  type CanvassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CanvassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CanvassCountAggregateInputType | true
    }

  export interface CanvassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Canvass'], meta: { name: 'Canvass' } }
    /**
     * Find zero or one Canvass that matches the filter.
     * @param {CanvassFindUniqueArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CanvassFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassFindUniqueArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Canvass that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CanvassFindUniqueOrThrowArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CanvassFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Canvass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassFindFirstArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CanvassFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindFirstArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Canvass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassFindFirstOrThrowArgs} args - Arguments to find a Canvass
     * @example
     * // Get one Canvass
     * const canvass = await prisma.canvass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CanvassFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Canvasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Canvasses
     * const canvasses = await prisma.canvass.findMany()
     * 
     * // Get first 10 Canvasses
     * const canvasses = await prisma.canvass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvassWithIdOnly = await prisma.canvass.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CanvassFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Canvass.
     * @param {CanvassCreateArgs} args - Arguments to create a Canvass.
     * @example
     * // Create one Canvass
     * const Canvass = await prisma.canvass.create({
     *   data: {
     *     // ... data to create a Canvass
     *   }
     * })
     * 
    **/
    create<T extends CanvassCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassCreateArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Canvasses.
     *     @param {CanvassCreateManyArgs} args - Arguments to create many Canvasses.
     *     @example
     *     // Create many Canvasses
     *     const canvass = await prisma.canvass.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CanvassCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Canvass.
     * @param {CanvassDeleteArgs} args - Arguments to delete one Canvass.
     * @example
     * // Delete one Canvass
     * const Canvass = await prisma.canvass.delete({
     *   where: {
     *     // ... filter to delete one Canvass
     *   }
     * })
     * 
    **/
    delete<T extends CanvassDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassDeleteArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Canvass.
     * @param {CanvassUpdateArgs} args - Arguments to update one Canvass.
     * @example
     * // Update one Canvass
     * const canvass = await prisma.canvass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CanvassUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassUpdateArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Canvasses.
     * @param {CanvassDeleteManyArgs} args - Arguments to filter Canvasses to delete.
     * @example
     * // Delete a few Canvasses
     * const { count } = await prisma.canvass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CanvassDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CanvassDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Canvasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Canvasses
     * const canvass = await prisma.canvass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CanvassUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Canvass.
     * @param {CanvassUpsertArgs} args - Arguments to update or create a Canvass.
     * @example
     * // Update or create a Canvass
     * const canvass = await prisma.canvass.upsert({
     *   create: {
     *     // ... data to create a Canvass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Canvass we want to update
     *   }
     * })
    **/
    upsert<T extends CanvassUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CanvassUpsertArgs<ExtArgs>>
    ): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Canvasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassCountArgs} args - Arguments to filter Canvasses to count.
     * @example
     * // Count the number of Canvasses
     * const count = await prisma.canvass.count({
     *   where: {
     *     // ... the filter for the Canvasses we want to count
     *   }
     * })
    **/
    count<T extends CanvassCountArgs>(
      args?: Subset<T, CanvassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Canvass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvassAggregateArgs>(args: Subset<T, CanvassAggregateArgs>): Prisma.PrismaPromise<GetCanvassAggregateType<T>>

    /**
     * Group by Canvass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvassGroupByArgs['orderBy'] }
        : { orderBy?: CanvassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Canvass model
   */
  readonly fields: CanvassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Canvass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass_items<T extends Canvass$canvass_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$canvass_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    jo<T extends Canvass$joArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$joArgs<ExtArgs>>): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rv<T extends Canvass$rvArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$rvArgs<ExtArgs>>): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    spr<T extends Canvass$sprArgs<ExtArgs> = {}>(args?: Subset<T, Canvass$sprArgs<ExtArgs>>): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Canvass model
   */ 
  interface CanvassFieldRefs {
    readonly id: FieldRef<"Canvass", 'String'>
    readonly rc_number: FieldRef<"Canvass", 'String'>
    readonly date_requested: FieldRef<"Canvass", 'DateTime'>
    readonly purpose: FieldRef<"Canvass", 'String'>
    readonly notes: FieldRef<"Canvass", 'String'>
    readonly requested_by_id: FieldRef<"Canvass", 'String'>
    readonly is_referenced: FieldRef<"Canvass", 'Boolean'>
    readonly created_at: FieldRef<"Canvass", 'DateTime'>
    readonly updated_at: FieldRef<"Canvass", 'DateTime'>
    readonly is_deleted: FieldRef<"Canvass", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Canvass findUnique
   */
  export type CanvassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass findUniqueOrThrow
   */
  export type CanvassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass findFirst
   */
  export type CanvassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvasses.
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvasses.
     */
    distinct?: CanvassScalarFieldEnum | CanvassScalarFieldEnum[]
  }


  /**
   * Canvass findFirstOrThrow
   */
  export type CanvassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvass to fetch.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvasses.
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvasses.
     */
    distinct?: CanvassScalarFieldEnum | CanvassScalarFieldEnum[]
  }


  /**
   * Canvass findMany
   */
  export type CanvassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter, which Canvasses to fetch.
     */
    where?: CanvassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvasses to fetch.
     */
    orderBy?: CanvassOrderByWithRelationInput | CanvassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Canvasses.
     */
    cursor?: CanvassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvasses.
     */
    skip?: number
    distinct?: CanvassScalarFieldEnum | CanvassScalarFieldEnum[]
  }


  /**
   * Canvass create
   */
  export type CanvassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * The data needed to create a Canvass.
     */
    data: XOR<CanvassCreateInput, CanvassUncheckedCreateInput>
  }


  /**
   * Canvass createMany
   */
  export type CanvassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Canvasses.
     */
    data: CanvassCreateManyInput | CanvassCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Canvass update
   */
  export type CanvassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * The data needed to update a Canvass.
     */
    data: XOR<CanvassUpdateInput, CanvassUncheckedUpdateInput>
    /**
     * Choose, which Canvass to update.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass updateMany
   */
  export type CanvassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Canvasses.
     */
    data: XOR<CanvassUpdateManyMutationInput, CanvassUncheckedUpdateManyInput>
    /**
     * Filter which Canvasses to update
     */
    where?: CanvassWhereInput
  }


  /**
   * Canvass upsert
   */
  export type CanvassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * The filter to search for the Canvass to update in case it exists.
     */
    where: CanvassWhereUniqueInput
    /**
     * In case the Canvass found by the `where` argument doesn't exist, create a new Canvass with this data.
     */
    create: XOR<CanvassCreateInput, CanvassUncheckedCreateInput>
    /**
     * In case the Canvass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvassUpdateInput, CanvassUncheckedUpdateInput>
  }


  /**
   * Canvass delete
   */
  export type CanvassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
    /**
     * Filter which Canvass to delete.
     */
    where: CanvassWhereUniqueInput
  }


  /**
   * Canvass deleteMany
   */
  export type CanvassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvasses to delete
     */
    where?: CanvassWhereInput
  }


  /**
   * Canvass.canvass_items
   */
  export type Canvass$canvass_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvassItem
     */
    select?: CanvassItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassItemInclude<ExtArgs> | null
    where?: CanvassItemWhereInput
    orderBy?: CanvassItemOrderByWithRelationInput | CanvassItemOrderByWithRelationInput[]
    cursor?: CanvassItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvassItemScalarFieldEnum | CanvassItemScalarFieldEnum[]
  }


  /**
   * Canvass.jo
   */
  export type Canvass$joArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    where?: JOWhereInput
  }


  /**
   * Canvass.rv
   */
  export type Canvass$rvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    where?: RVWhereInput
  }


  /**
   * Canvass.spr
   */
  export type Canvass$sprArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    where?: SPRWhereInput
  }


  /**
   * Canvass without action
   */
  export type CanvassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvass
     */
    select?: CanvassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CanvassInclude<ExtArgs> | null
  }



  /**
   * Model JO
   */

  export type AggregateJO = {
    _count: JOCountAggregateOutputType | null
    _avg: JOAvgAggregateOutputType | null
    _sum: JOSumAggregateOutputType | null
    _min: JOMinAggregateOutputType | null
    _max: JOMaxAggregateOutputType | null
  }

  export type JOAvgAggregateOutputType = {
    status: number | null
  }

  export type JOSumAggregateOutputType = {
    status: number | null
  }

  export type JOMinAggregateOutputType = {
    id: string | null
    jo_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    equipment: string | null
    classification_id: string | null
    department_id: string | null
    supervisor_id: string | null
    status: number | null
    canceller_id: string | null
    date_cancelled: Date | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type JOMaxAggregateOutputType = {
    id: string | null
    jo_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    equipment: string | null
    classification_id: string | null
    department_id: string | null
    supervisor_id: string | null
    status: number | null
    canceller_id: string | null
    date_cancelled: Date | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type JOCountAggregateOutputType = {
    id: number
    jo_number: number
    date_requested: number
    canvass_id: number
    equipment: number
    classification_id: number
    department_id: number
    supervisor_id: number
    status: number
    canceller_id: number
    date_cancelled: number
    is_referenced: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type JOAvgAggregateInputType = {
    status?: true
  }

  export type JOSumAggregateInputType = {
    status?: true
  }

  export type JOMinAggregateInputType = {
    id?: true
    jo_number?: true
    date_requested?: true
    canvass_id?: true
    equipment?: true
    classification_id?: true
    department_id?: true
    supervisor_id?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type JOMaxAggregateInputType = {
    id?: true
    jo_number?: true
    date_requested?: true
    canvass_id?: true
    equipment?: true
    classification_id?: true
    department_id?: true
    supervisor_id?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type JOCountAggregateInputType = {
    id?: true
    jo_number?: true
    date_requested?: true
    canvass_id?: true
    equipment?: true
    classification_id?: true
    department_id?: true
    supervisor_id?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type JOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JO to aggregate.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JOS
    **/
    _count?: true | JOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JOMaxAggregateInputType
  }

  export type GetJOAggregateType<T extends JOAggregateArgs> = {
        [P in keyof T & keyof AggregateJO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJO[P]>
      : GetScalarType<T[P], AggregateJO[P]>
  }




  export type JOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOWhereInput
    orderBy?: JOOrderByWithAggregationInput | JOOrderByWithAggregationInput[]
    by: JOScalarFieldEnum[] | JOScalarFieldEnum
    having?: JOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JOCountAggregateInputType | true
    _avg?: JOAvgAggregateInputType
    _sum?: JOSumAggregateInputType
    _min?: JOMinAggregateInputType
    _max?: JOMaxAggregateInputType
  }

  export type JOGroupByOutputType = {
    id: string
    jo_number: string
    date_requested: Date
    canvass_id: string
    equipment: string
    classification_id: string | null
    department_id: string
    supervisor_id: string
    status: number
    canceller_id: string | null
    date_cancelled: Date | null
    is_referenced: boolean
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: JOCountAggregateOutputType | null
    _avg: JOAvgAggregateOutputType | null
    _sum: JOSumAggregateOutputType | null
    _min: JOMinAggregateOutputType | null
    _max: JOMaxAggregateOutputType | null
  }

  type GetJOGroupByPayload<T extends JOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JOGroupByOutputType[P]>
            : GetScalarType<T[P], JOGroupByOutputType[P]>
        }
      >
    >


  export type JOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jo_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    equipment?: boolean
    classification_id?: boolean
    department_id?: boolean
    supervisor_id?: boolean
    status?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    jo_approvers?: boolean | JO$jo_approversArgs<ExtArgs>
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    meqs?: boolean | JO$meqsArgs<ExtArgs>
    _count?: boolean | JOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jO"]>

  export type JOSelectScalar = {
    id?: boolean
    jo_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    equipment?: boolean
    classification_id?: boolean
    department_id?: boolean
    supervisor_id?: boolean
    status?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type JOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jo_approvers?: boolean | JO$jo_approversArgs<ExtArgs>
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    meqs?: boolean | JO$meqsArgs<ExtArgs>
    _count?: boolean | JOCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $JOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JO"
    objects: {
      jo_approvers: Prisma.$JOApproverPayload<ExtArgs>[]
      canvass: Prisma.$CanvassPayload<ExtArgs>
      meqs: Prisma.$MEQSPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jo_number: string
      date_requested: Date
      canvass_id: string
      equipment: string
      classification_id: string | null
      department_id: string
      supervisor_id: string
      status: number
      canceller_id: string | null
      date_cancelled: Date | null
      is_referenced: boolean
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["jO"]>
    composites: {}
  }


  type JOGetPayload<S extends boolean | null | undefined | JODefaultArgs> = $Result.GetResult<Prisma.$JOPayload, S>

  type JOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JOFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JOCountAggregateInputType | true
    }

  export interface JODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JO'], meta: { name: 'JO' } }
    /**
     * Find zero or one JO that matches the filter.
     * @param {JOFindUniqueArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JOFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JOFindUniqueArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JO that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JOFindUniqueOrThrowArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JOFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOFindFirstArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JOFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindFirstArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOFindFirstOrThrowArgs} args - Arguments to find a JO
     * @example
     * // Get one JO
     * const jO = await prisma.jO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JOFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JOS
     * const jOS = await prisma.jO.findMany()
     * 
     * // Get first 10 JOS
     * const jOS = await prisma.jO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jOWithIdOnly = await prisma.jO.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JOFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JO.
     * @param {JOCreateArgs} args - Arguments to create a JO.
     * @example
     * // Create one JO
     * const JO = await prisma.jO.create({
     *   data: {
     *     // ... data to create a JO
     *   }
     * })
     * 
    **/
    create<T extends JOCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JOCreateArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JOS.
     *     @param {JOCreateManyArgs} args - Arguments to create many JOS.
     *     @example
     *     // Create many JOS
     *     const jO = await prisma.jO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JOCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JO.
     * @param {JODeleteArgs} args - Arguments to delete one JO.
     * @example
     * // Delete one JO
     * const JO = await prisma.jO.delete({
     *   where: {
     *     // ... filter to delete one JO
     *   }
     * })
     * 
    **/
    delete<T extends JODeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JODeleteArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JO.
     * @param {JOUpdateArgs} args - Arguments to update one JO.
     * @example
     * // Update one JO
     * const jO = await prisma.jO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JOUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JOUpdateArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JOS.
     * @param {JODeleteManyArgs} args - Arguments to filter JOS to delete.
     * @example
     * // Delete a few JOS
     * const { count } = await prisma.jO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JODeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JODeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JOS
     * const jO = await prisma.jO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JOUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JOUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JO.
     * @param {JOUpsertArgs} args - Arguments to update or create a JO.
     * @example
     * // Update or create a JO
     * const jO = await prisma.jO.upsert({
     *   create: {
     *     // ... data to create a JO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JO we want to update
     *   }
     * })
    **/
    upsert<T extends JOUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JOUpsertArgs<ExtArgs>>
    ): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOCountArgs} args - Arguments to filter JOS to count.
     * @example
     * // Count the number of JOS
     * const count = await prisma.jO.count({
     *   where: {
     *     // ... the filter for the JOS we want to count
     *   }
     * })
    **/
    count<T extends JOCountArgs>(
      args?: Subset<T, JOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JOAggregateArgs>(args: Subset<T, JOAggregateArgs>): Prisma.PrismaPromise<GetJOAggregateType<T>>

    /**
     * Group by JO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JOGroupByArgs['orderBy'] }
        : { orderBy?: JOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JO model
   */
  readonly fields: JOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jo_approvers<T extends JO$jo_approversArgs<ExtArgs> = {}>(args?: Subset<T, JO$jo_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    canvass<T extends CanvassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvassDefaultArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    meqs<T extends JO$meqsArgs<ExtArgs> = {}>(args?: Subset<T, JO$meqsArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JO model
   */ 
  interface JOFieldRefs {
    readonly id: FieldRef<"JO", 'String'>
    readonly jo_number: FieldRef<"JO", 'String'>
    readonly date_requested: FieldRef<"JO", 'DateTime'>
    readonly canvass_id: FieldRef<"JO", 'String'>
    readonly equipment: FieldRef<"JO", 'String'>
    readonly classification_id: FieldRef<"JO", 'String'>
    readonly department_id: FieldRef<"JO", 'String'>
    readonly supervisor_id: FieldRef<"JO", 'String'>
    readonly status: FieldRef<"JO", 'Int'>
    readonly canceller_id: FieldRef<"JO", 'String'>
    readonly date_cancelled: FieldRef<"JO", 'DateTime'>
    readonly is_referenced: FieldRef<"JO", 'Boolean'>
    readonly created_at: FieldRef<"JO", 'DateTime'>
    readonly updated_at: FieldRef<"JO", 'DateTime'>
    readonly is_deleted: FieldRef<"JO", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * JO findUnique
   */
  export type JOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO findUniqueOrThrow
   */
  export type JOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO findFirst
   */
  export type JOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOS.
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOS.
     */
    distinct?: JOScalarFieldEnum | JOScalarFieldEnum[]
  }


  /**
   * JO findFirstOrThrow
   */
  export type JOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JO to fetch.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOS.
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOS.
     */
    distinct?: JOScalarFieldEnum | JOScalarFieldEnum[]
  }


  /**
   * JO findMany
   */
  export type JOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter, which JOS to fetch.
     */
    where?: JOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOS to fetch.
     */
    orderBy?: JOOrderByWithRelationInput | JOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JOS.
     */
    cursor?: JOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOS.
     */
    skip?: number
    distinct?: JOScalarFieldEnum | JOScalarFieldEnum[]
  }


  /**
   * JO create
   */
  export type JOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * The data needed to create a JO.
     */
    data: XOR<JOCreateInput, JOUncheckedCreateInput>
  }


  /**
   * JO createMany
   */
  export type JOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JOS.
     */
    data: JOCreateManyInput | JOCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JO update
   */
  export type JOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * The data needed to update a JO.
     */
    data: XOR<JOUpdateInput, JOUncheckedUpdateInput>
    /**
     * Choose, which JO to update.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO updateMany
   */
  export type JOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JOS.
     */
    data: XOR<JOUpdateManyMutationInput, JOUncheckedUpdateManyInput>
    /**
     * Filter which JOS to update
     */
    where?: JOWhereInput
  }


  /**
   * JO upsert
   */
  export type JOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * The filter to search for the JO to update in case it exists.
     */
    where: JOWhereUniqueInput
    /**
     * In case the JO found by the `where` argument doesn't exist, create a new JO with this data.
     */
    create: XOR<JOCreateInput, JOUncheckedCreateInput>
    /**
     * In case the JO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JOUpdateInput, JOUncheckedUpdateInput>
  }


  /**
   * JO delete
   */
  export type JODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    /**
     * Filter which JO to delete.
     */
    where: JOWhereUniqueInput
  }


  /**
   * JO deleteMany
   */
  export type JODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOS to delete
     */
    where?: JOWhereInput
  }


  /**
   * JO.jo_approvers
   */
  export type JO$jo_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    where?: JOApproverWhereInput
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    cursor?: JOApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JO.meqs
   */
  export type JO$meqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    where?: MEQSWhereInput
  }


  /**
   * JO without action
   */
  export type JODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
  }



  /**
   * Model JOApprover
   */

  export type AggregateJOApprover = {
    _count: JOApproverCountAggregateOutputType | null
    _avg: JOApproverAvgAggregateOutputType | null
    _sum: JOApproverSumAggregateOutputType | null
    _min: JOApproverMinAggregateOutputType | null
    _max: JOApproverMaxAggregateOutputType | null
  }

  export type JOApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type JOApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type JOApproverMinAggregateOutputType = {
    id: string | null
    jo_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type JOApproverMaxAggregateOutputType = {
    id: string | null
    jo_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type JOApproverCountAggregateOutputType = {
    id: number
    jo_id: number
    approver_proxy_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type JOApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type JOApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type JOApproverMinAggregateInputType = {
    id?: true
    jo_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type JOApproverMaxAggregateInputType = {
    id?: true
    jo_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type JOApproverCountAggregateInputType = {
    id?: true
    jo_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type JOApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOApprover to aggregate.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JOApprovers
    **/
    _count?: true | JOApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JOApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JOApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JOApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JOApproverMaxAggregateInputType
  }

  export type GetJOApproverAggregateType<T extends JOApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateJOApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJOApprover[P]>
      : GetScalarType<T[P], AggregateJOApprover[P]>
  }




  export type JOApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JOApproverWhereInput
    orderBy?: JOApproverOrderByWithAggregationInput | JOApproverOrderByWithAggregationInput[]
    by: JOApproverScalarFieldEnum[] | JOApproverScalarFieldEnum
    having?: JOApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JOApproverCountAggregateInputType | true
    _avg?: JOApproverAvgAggregateInputType
    _sum?: JOApproverSumAggregateInputType
    _min?: JOApproverMinAggregateInputType
    _max?: JOApproverMaxAggregateInputType
  }

  export type JOApproverGroupByOutputType = {
    id: string
    jo_id: string
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number
    label: string
    order: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: JOApproverCountAggregateOutputType | null
    _avg: JOApproverAvgAggregateOutputType | null
    _sum: JOApproverSumAggregateOutputType | null
    _min: JOApproverMinAggregateOutputType | null
    _max: JOApproverMaxAggregateOutputType | null
  }

  type GetJOApproverGroupByPayload<T extends JOApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JOApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JOApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JOApproverGroupByOutputType[P]>
            : GetScalarType<T[P], JOApproverGroupByOutputType[P]>
        }
      >
    >


  export type JOApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jo_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    jo?: boolean | JODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jOApprover"]>

  export type JOApproverSelectScalar = {
    id?: boolean
    jo_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type JOApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jo?: boolean | JODefaultArgs<ExtArgs>
  }


  export type $JOApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JOApprover"
    objects: {
      jo: Prisma.$JOPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jo_id: string
      approver_proxy_id: string | null
      date_approval: Date | null
      notes: string | null
      status: number
      label: string
      order: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["jOApprover"]>
    composites: {}
  }


  type JOApproverGetPayload<S extends boolean | null | undefined | JOApproverDefaultArgs> = $Result.GetResult<Prisma.$JOApproverPayload, S>

  type JOApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JOApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JOApproverCountAggregateInputType | true
    }

  export interface JOApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JOApprover'], meta: { name: 'JOApprover' } }
    /**
     * Find zero or one JOApprover that matches the filter.
     * @param {JOApproverFindUniqueArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JOApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JOApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JOApproverFindUniqueOrThrowArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JOApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JOApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverFindFirstArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JOApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindFirstArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JOApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverFindFirstOrThrowArgs} args - Arguments to find a JOApprover
     * @example
     * // Get one JOApprover
     * const jOApprover = await prisma.jOApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JOApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JOApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JOApprovers
     * const jOApprovers = await prisma.jOApprover.findMany()
     * 
     * // Get first 10 JOApprovers
     * const jOApprovers = await prisma.jOApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jOApproverWithIdOnly = await prisma.jOApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JOApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JOApprover.
     * @param {JOApproverCreateArgs} args - Arguments to create a JOApprover.
     * @example
     * // Create one JOApprover
     * const JOApprover = await prisma.jOApprover.create({
     *   data: {
     *     // ... data to create a JOApprover
     *   }
     * })
     * 
    **/
    create<T extends JOApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverCreateArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JOApprovers.
     *     @param {JOApproverCreateManyArgs} args - Arguments to create many JOApprovers.
     *     @example
     *     // Create many JOApprovers
     *     const jOApprover = await prisma.jOApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JOApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JOApprover.
     * @param {JOApproverDeleteArgs} args - Arguments to delete one JOApprover.
     * @example
     * // Delete one JOApprover
     * const JOApprover = await prisma.jOApprover.delete({
     *   where: {
     *     // ... filter to delete one JOApprover
     *   }
     * })
     * 
    **/
    delete<T extends JOApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverDeleteArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JOApprover.
     * @param {JOApproverUpdateArgs} args - Arguments to update one JOApprover.
     * @example
     * // Update one JOApprover
     * const jOApprover = await prisma.jOApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JOApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverUpdateArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JOApprovers.
     * @param {JOApproverDeleteManyArgs} args - Arguments to filter JOApprovers to delete.
     * @example
     * // Delete a few JOApprovers
     * const { count } = await prisma.jOApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JOApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JOApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JOApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JOApprovers
     * const jOApprover = await prisma.jOApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JOApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JOApprover.
     * @param {JOApproverUpsertArgs} args - Arguments to update or create a JOApprover.
     * @example
     * // Update or create a JOApprover
     * const jOApprover = await prisma.jOApprover.upsert({
     *   create: {
     *     // ... data to create a JOApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JOApprover we want to update
     *   }
     * })
    **/
    upsert<T extends JOApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JOApproverUpsertArgs<ExtArgs>>
    ): Prisma__JOApproverClient<$Result.GetResult<Prisma.$JOApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JOApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverCountArgs} args - Arguments to filter JOApprovers to count.
     * @example
     * // Count the number of JOApprovers
     * const count = await prisma.jOApprover.count({
     *   where: {
     *     // ... the filter for the JOApprovers we want to count
     *   }
     * })
    **/
    count<T extends JOApproverCountArgs>(
      args?: Subset<T, JOApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JOApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JOApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JOApproverAggregateArgs>(args: Subset<T, JOApproverAggregateArgs>): Prisma.PrismaPromise<GetJOApproverAggregateType<T>>

    /**
     * Group by JOApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JOApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JOApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JOApproverGroupByArgs['orderBy'] }
        : { orderBy?: JOApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JOApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJOApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JOApprover model
   */
  readonly fields: JOApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JOApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JOApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jo<T extends JODefaultArgs<ExtArgs> = {}>(args?: Subset<T, JODefaultArgs<ExtArgs>>): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JOApprover model
   */ 
  interface JOApproverFieldRefs {
    readonly id: FieldRef<"JOApprover", 'String'>
    readonly jo_id: FieldRef<"JOApprover", 'String'>
    readonly approver_proxy_id: FieldRef<"JOApprover", 'String'>
    readonly date_approval: FieldRef<"JOApprover", 'DateTime'>
    readonly notes: FieldRef<"JOApprover", 'String'>
    readonly status: FieldRef<"JOApprover", 'Int'>
    readonly label: FieldRef<"JOApprover", 'String'>
    readonly order: FieldRef<"JOApprover", 'Int'>
    readonly created_at: FieldRef<"JOApprover", 'DateTime'>
    readonly updated_at: FieldRef<"JOApprover", 'DateTime'>
    readonly is_deleted: FieldRef<"JOApprover", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * JOApprover findUnique
   */
  export type JOApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover findUniqueOrThrow
   */
  export type JOApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover findFirst
   */
  export type JOApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOApprovers.
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOApprovers.
     */
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JOApprover findFirstOrThrow
   */
  export type JOApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprover to fetch.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JOApprovers.
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JOApprovers.
     */
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JOApprover findMany
   */
  export type JOApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter, which JOApprovers to fetch.
     */
    where?: JOApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JOApprovers to fetch.
     */
    orderBy?: JOApproverOrderByWithRelationInput | JOApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JOApprovers.
     */
    cursor?: JOApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JOApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JOApprovers.
     */
    skip?: number
    distinct?: JOApproverScalarFieldEnum | JOApproverScalarFieldEnum[]
  }


  /**
   * JOApprover create
   */
  export type JOApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a JOApprover.
     */
    data: XOR<JOApproverCreateInput, JOApproverUncheckedCreateInput>
  }


  /**
   * JOApprover createMany
   */
  export type JOApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JOApprovers.
     */
    data: JOApproverCreateManyInput | JOApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JOApprover update
   */
  export type JOApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a JOApprover.
     */
    data: XOR<JOApproverUpdateInput, JOApproverUncheckedUpdateInput>
    /**
     * Choose, which JOApprover to update.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover updateMany
   */
  export type JOApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JOApprovers.
     */
    data: XOR<JOApproverUpdateManyMutationInput, JOApproverUncheckedUpdateManyInput>
    /**
     * Filter which JOApprovers to update
     */
    where?: JOApproverWhereInput
  }


  /**
   * JOApprover upsert
   */
  export type JOApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the JOApprover to update in case it exists.
     */
    where: JOApproverWhereUniqueInput
    /**
     * In case the JOApprover found by the `where` argument doesn't exist, create a new JOApprover with this data.
     */
    create: XOR<JOApproverCreateInput, JOApproverUncheckedCreateInput>
    /**
     * In case the JOApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JOApproverUpdateInput, JOApproverUncheckedUpdateInput>
  }


  /**
   * JOApprover delete
   */
  export type JOApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
    /**
     * Filter which JOApprover to delete.
     */
    where: JOApproverWhereUniqueInput
  }


  /**
   * JOApprover deleteMany
   */
  export type JOApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JOApprovers to delete
     */
    where?: JOApproverWhereInput
  }


  /**
   * JOApprover without action
   */
  export type JOApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JOApprover
     */
    select?: JOApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOApproverInclude<ExtArgs> | null
  }



  /**
   * Model RV
   */

  export type AggregateRV = {
    _count: RVCountAggregateOutputType | null
    _avg: RVAvgAggregateOutputType | null
    _sum: RVSumAggregateOutputType | null
    _min: RVMinAggregateOutputType | null
    _max: RVMaxAggregateOutputType | null
  }

  export type RVAvgAggregateOutputType = {
    status: number | null
  }

  export type RVSumAggregateOutputType = {
    status: number | null
  }

  export type RVMinAggregateOutputType = {
    id: string | null
    canvass_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    canceller_id: string | null
    date_cancelled: Date | null
    rv_number: string | null
    date_requested: Date | null
    work_order_no: string | null
    work_order_date: Date | null
    status: number | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RVMaxAggregateOutputType = {
    id: string | null
    canvass_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    canceller_id: string | null
    date_cancelled: Date | null
    rv_number: string | null
    date_requested: Date | null
    work_order_no: string | null
    work_order_date: Date | null
    status: number | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RVCountAggregateOutputType = {
    id: number
    canvass_id: number
    classification_id: number
    supervisor_id: number
    canceller_id: number
    date_cancelled: number
    rv_number: number
    date_requested: number
    work_order_no: number
    work_order_date: number
    status: number
    is_referenced: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type RVAvgAggregateInputType = {
    status?: true
  }

  export type RVSumAggregateInputType = {
    status?: true
  }

  export type RVMinAggregateInputType = {
    id?: true
    canvass_id?: true
    classification_id?: true
    supervisor_id?: true
    canceller_id?: true
    date_cancelled?: true
    rv_number?: true
    date_requested?: true
    work_order_no?: true
    work_order_date?: true
    status?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RVMaxAggregateInputType = {
    id?: true
    canvass_id?: true
    classification_id?: true
    supervisor_id?: true
    canceller_id?: true
    date_cancelled?: true
    rv_number?: true
    date_requested?: true
    work_order_no?: true
    work_order_date?: true
    status?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RVCountAggregateInputType = {
    id?: true
    canvass_id?: true
    classification_id?: true
    supervisor_id?: true
    canceller_id?: true
    date_cancelled?: true
    rv_number?: true
    date_requested?: true
    work_order_no?: true
    work_order_date?: true
    status?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type RVAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RV to aggregate.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RVS
    **/
    _count?: true | RVCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RVAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RVSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RVMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RVMaxAggregateInputType
  }

  export type GetRVAggregateType<T extends RVAggregateArgs> = {
        [P in keyof T & keyof AggregateRV]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRV[P]>
      : GetScalarType<T[P], AggregateRV[P]>
  }




  export type RVGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RVWhereInput
    orderBy?: RVOrderByWithAggregationInput | RVOrderByWithAggregationInput[]
    by: RVScalarFieldEnum[] | RVScalarFieldEnum
    having?: RVScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RVCountAggregateInputType | true
    _avg?: RVAvgAggregateInputType
    _sum?: RVSumAggregateInputType
    _min?: RVMinAggregateInputType
    _max?: RVMaxAggregateInputType
  }

  export type RVGroupByOutputType = {
    id: string
    canvass_id: string
    classification_id: string | null
    supervisor_id: string
    canceller_id: string | null
    date_cancelled: Date | null
    rv_number: string
    date_requested: Date
    work_order_no: string | null
    work_order_date: Date | null
    status: number
    is_referenced: boolean
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: RVCountAggregateOutputType | null
    _avg: RVAvgAggregateOutputType | null
    _sum: RVSumAggregateOutputType | null
    _min: RVMinAggregateOutputType | null
    _max: RVMaxAggregateOutputType | null
  }

  type GetRVGroupByPayload<T extends RVGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RVGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RVGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RVGroupByOutputType[P]>
            : GetScalarType<T[P], RVGroupByOutputType[P]>
        }
      >
    >


  export type RVSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvass_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    rv_number?: boolean
    date_requested?: boolean
    work_order_no?: boolean
    work_order_date?: boolean
    status?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    meqs?: boolean | RV$meqsArgs<ExtArgs>
    rv_approvers?: boolean | RV$rv_approversArgs<ExtArgs>
    _count?: boolean | RVCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rV"]>

  export type RVSelectScalar = {
    id?: boolean
    canvass_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    rv_number?: boolean
    date_requested?: boolean
    work_order_no?: boolean
    work_order_date?: boolean
    status?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type RVInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    meqs?: boolean | RV$meqsArgs<ExtArgs>
    rv_approvers?: boolean | RV$rv_approversArgs<ExtArgs>
    _count?: boolean | RVCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RVPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RV"
    objects: {
      canvass: Prisma.$CanvassPayload<ExtArgs>
      meqs: Prisma.$MEQSPayload<ExtArgs> | null
      rv_approvers: Prisma.$RVApproverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvass_id: string
      classification_id: string | null
      supervisor_id: string
      canceller_id: string | null
      date_cancelled: Date | null
      rv_number: string
      date_requested: Date
      work_order_no: string | null
      work_order_date: Date | null
      status: number
      is_referenced: boolean
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["rV"]>
    composites: {}
  }


  type RVGetPayload<S extends boolean | null | undefined | RVDefaultArgs> = $Result.GetResult<Prisma.$RVPayload, S>

  type RVCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RVFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RVCountAggregateInputType | true
    }

  export interface RVDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RV'], meta: { name: 'RV' } }
    /**
     * Find zero or one RV that matches the filter.
     * @param {RVFindUniqueArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RVFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RVFindUniqueArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RV that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RVFindUniqueOrThrowArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RVFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RV that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVFindFirstArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RVFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindFirstArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RV that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVFindFirstOrThrowArgs} args - Arguments to find a RV
     * @example
     * // Get one RV
     * const rV = await prisma.rV.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RVFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RVS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RVS
     * const rVS = await prisma.rV.findMany()
     * 
     * // Get first 10 RVS
     * const rVS = await prisma.rV.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rVWithIdOnly = await prisma.rV.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RVFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RV.
     * @param {RVCreateArgs} args - Arguments to create a RV.
     * @example
     * // Create one RV
     * const RV = await prisma.rV.create({
     *   data: {
     *     // ... data to create a RV
     *   }
     * })
     * 
    **/
    create<T extends RVCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RVCreateArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RVS.
     *     @param {RVCreateManyArgs} args - Arguments to create many RVS.
     *     @example
     *     // Create many RVS
     *     const rV = await prisma.rV.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RVCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RV.
     * @param {RVDeleteArgs} args - Arguments to delete one RV.
     * @example
     * // Delete one RV
     * const RV = await prisma.rV.delete({
     *   where: {
     *     // ... filter to delete one RV
     *   }
     * })
     * 
    **/
    delete<T extends RVDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RVDeleteArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RV.
     * @param {RVUpdateArgs} args - Arguments to update one RV.
     * @example
     * // Update one RV
     * const rV = await prisma.rV.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RVUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RVUpdateArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RVS.
     * @param {RVDeleteManyArgs} args - Arguments to filter RVS to delete.
     * @example
     * // Delete a few RVS
     * const { count } = await prisma.rV.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RVDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RVS
     * const rV = await prisma.rV.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RVUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RVUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RV.
     * @param {RVUpsertArgs} args - Arguments to update or create a RV.
     * @example
     * // Update or create a RV
     * const rV = await prisma.rV.upsert({
     *   create: {
     *     // ... data to create a RV
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RV we want to update
     *   }
     * })
    **/
    upsert<T extends RVUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RVUpsertArgs<ExtArgs>>
    ): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RVS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVCountArgs} args - Arguments to filter RVS to count.
     * @example
     * // Count the number of RVS
     * const count = await prisma.rV.count({
     *   where: {
     *     // ... the filter for the RVS we want to count
     *   }
     * })
    **/
    count<T extends RVCountArgs>(
      args?: Subset<T, RVCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RVCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RVAggregateArgs>(args: Subset<T, RVAggregateArgs>): Prisma.PrismaPromise<GetRVAggregateType<T>>

    /**
     * Group by RV.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RVGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RVGroupByArgs['orderBy'] }
        : { orderBy?: RVGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RVGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRVGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RV model
   */
  readonly fields: RVFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RV.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RVClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass<T extends CanvassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvassDefaultArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    meqs<T extends RV$meqsArgs<ExtArgs> = {}>(args?: Subset<T, RV$meqsArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rv_approvers<T extends RV$rv_approversArgs<ExtArgs> = {}>(args?: Subset<T, RV$rv_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RV model
   */ 
  interface RVFieldRefs {
    readonly id: FieldRef<"RV", 'String'>
    readonly canvass_id: FieldRef<"RV", 'String'>
    readonly classification_id: FieldRef<"RV", 'String'>
    readonly supervisor_id: FieldRef<"RV", 'String'>
    readonly canceller_id: FieldRef<"RV", 'String'>
    readonly date_cancelled: FieldRef<"RV", 'DateTime'>
    readonly rv_number: FieldRef<"RV", 'String'>
    readonly date_requested: FieldRef<"RV", 'DateTime'>
    readonly work_order_no: FieldRef<"RV", 'String'>
    readonly work_order_date: FieldRef<"RV", 'DateTime'>
    readonly status: FieldRef<"RV", 'Int'>
    readonly is_referenced: FieldRef<"RV", 'Boolean'>
    readonly created_at: FieldRef<"RV", 'DateTime'>
    readonly updated_at: FieldRef<"RV", 'DateTime'>
    readonly is_deleted: FieldRef<"RV", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * RV findUnique
   */
  export type RVFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV findUniqueOrThrow
   */
  export type RVFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV findFirst
   */
  export type RVFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVS.
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVS.
     */
    distinct?: RVScalarFieldEnum | RVScalarFieldEnum[]
  }


  /**
   * RV findFirstOrThrow
   */
  export type RVFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RV to fetch.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVS.
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVS.
     */
    distinct?: RVScalarFieldEnum | RVScalarFieldEnum[]
  }


  /**
   * RV findMany
   */
  export type RVFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter, which RVS to fetch.
     */
    where?: RVWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVS to fetch.
     */
    orderBy?: RVOrderByWithRelationInput | RVOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RVS.
     */
    cursor?: RVWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVS.
     */
    skip?: number
    distinct?: RVScalarFieldEnum | RVScalarFieldEnum[]
  }


  /**
   * RV create
   */
  export type RVCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * The data needed to create a RV.
     */
    data: XOR<RVCreateInput, RVUncheckedCreateInput>
  }


  /**
   * RV createMany
   */
  export type RVCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RVS.
     */
    data: RVCreateManyInput | RVCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RV update
   */
  export type RVUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * The data needed to update a RV.
     */
    data: XOR<RVUpdateInput, RVUncheckedUpdateInput>
    /**
     * Choose, which RV to update.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV updateMany
   */
  export type RVUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RVS.
     */
    data: XOR<RVUpdateManyMutationInput, RVUncheckedUpdateManyInput>
    /**
     * Filter which RVS to update
     */
    where?: RVWhereInput
  }


  /**
   * RV upsert
   */
  export type RVUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * The filter to search for the RV to update in case it exists.
     */
    where: RVWhereUniqueInput
    /**
     * In case the RV found by the `where` argument doesn't exist, create a new RV with this data.
     */
    create: XOR<RVCreateInput, RVUncheckedCreateInput>
    /**
     * In case the RV was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RVUpdateInput, RVUncheckedUpdateInput>
  }


  /**
   * RV delete
   */
  export type RVDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    /**
     * Filter which RV to delete.
     */
    where: RVWhereUniqueInput
  }


  /**
   * RV deleteMany
   */
  export type RVDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RVS to delete
     */
    where?: RVWhereInput
  }


  /**
   * RV.meqs
   */
  export type RV$meqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    where?: MEQSWhereInput
  }


  /**
   * RV.rv_approvers
   */
  export type RV$rv_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    where?: RVApproverWhereInput
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    cursor?: RVApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RV without action
   */
  export type RVDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
  }



  /**
   * Model RVApprover
   */

  export type AggregateRVApprover = {
    _count: RVApproverCountAggregateOutputType | null
    _avg: RVApproverAvgAggregateOutputType | null
    _sum: RVApproverSumAggregateOutputType | null
    _min: RVApproverMinAggregateOutputType | null
    _max: RVApproverMaxAggregateOutputType | null
  }

  export type RVApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RVApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RVApproverMinAggregateOutputType = {
    id: string | null
    rv_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RVApproverMaxAggregateOutputType = {
    id: string | null
    rv_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RVApproverCountAggregateOutputType = {
    id: number
    rv_id: number
    approver_id: number
    approver_proxy_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type RVApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type RVApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type RVApproverMinAggregateInputType = {
    id?: true
    rv_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RVApproverMaxAggregateInputType = {
    id?: true
    rv_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RVApproverCountAggregateInputType = {
    id?: true
    rv_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type RVApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RVApprover to aggregate.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RVApprovers
    **/
    _count?: true | RVApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RVApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RVApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RVApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RVApproverMaxAggregateInputType
  }

  export type GetRVApproverAggregateType<T extends RVApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateRVApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRVApprover[P]>
      : GetScalarType<T[P], AggregateRVApprover[P]>
  }




  export type RVApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RVApproverWhereInput
    orderBy?: RVApproverOrderByWithAggregationInput | RVApproverOrderByWithAggregationInput[]
    by: RVApproverScalarFieldEnum[] | RVApproverScalarFieldEnum
    having?: RVApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RVApproverCountAggregateInputType | true
    _avg?: RVApproverAvgAggregateInputType
    _sum?: RVApproverSumAggregateInputType
    _min?: RVApproverMinAggregateInputType
    _max?: RVApproverMaxAggregateInputType
  }

  export type RVApproverGroupByOutputType = {
    id: string
    rv_id: string
    approver_id: string
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number
    label: string
    order: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: RVApproverCountAggregateOutputType | null
    _avg: RVApproverAvgAggregateOutputType | null
    _sum: RVApproverSumAggregateOutputType | null
    _min: RVApproverMinAggregateOutputType | null
    _max: RVApproverMaxAggregateOutputType | null
  }

  type GetRVApproverGroupByPayload<T extends RVApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RVApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RVApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RVApproverGroupByOutputType[P]>
            : GetScalarType<T[P], RVApproverGroupByOutputType[P]>
        }
      >
    >


  export type RVApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rv_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    rv?: boolean | RVDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rVApprover"]>

  export type RVApproverSelectScalar = {
    id?: boolean
    rv_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type RVApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rv?: boolean | RVDefaultArgs<ExtArgs>
  }


  export type $RVApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RVApprover"
    objects: {
      rv: Prisma.$RVPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rv_id: string
      approver_id: string
      approver_proxy_id: string | null
      date_approval: Date | null
      notes: string | null
      status: number
      label: string
      order: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["rVApprover"]>
    composites: {}
  }


  type RVApproverGetPayload<S extends boolean | null | undefined | RVApproverDefaultArgs> = $Result.GetResult<Prisma.$RVApproverPayload, S>

  type RVApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RVApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RVApproverCountAggregateInputType | true
    }

  export interface RVApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RVApprover'], meta: { name: 'RVApprover' } }
    /**
     * Find zero or one RVApprover that matches the filter.
     * @param {RVApproverFindUniqueArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RVApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RVApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RVApproverFindUniqueOrThrowArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RVApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RVApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverFindFirstArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RVApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindFirstArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RVApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverFindFirstOrThrowArgs} args - Arguments to find a RVApprover
     * @example
     * // Get one RVApprover
     * const rVApprover = await prisma.rVApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RVApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RVApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RVApprovers
     * const rVApprovers = await prisma.rVApprover.findMany()
     * 
     * // Get first 10 RVApprovers
     * const rVApprovers = await prisma.rVApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rVApproverWithIdOnly = await prisma.rVApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RVApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RVApprover.
     * @param {RVApproverCreateArgs} args - Arguments to create a RVApprover.
     * @example
     * // Create one RVApprover
     * const RVApprover = await prisma.rVApprover.create({
     *   data: {
     *     // ... data to create a RVApprover
     *   }
     * })
     * 
    **/
    create<T extends RVApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverCreateArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RVApprovers.
     *     @param {RVApproverCreateManyArgs} args - Arguments to create many RVApprovers.
     *     @example
     *     // Create many RVApprovers
     *     const rVApprover = await prisma.rVApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RVApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RVApprover.
     * @param {RVApproverDeleteArgs} args - Arguments to delete one RVApprover.
     * @example
     * // Delete one RVApprover
     * const RVApprover = await prisma.rVApprover.delete({
     *   where: {
     *     // ... filter to delete one RVApprover
     *   }
     * })
     * 
    **/
    delete<T extends RVApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverDeleteArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RVApprover.
     * @param {RVApproverUpdateArgs} args - Arguments to update one RVApprover.
     * @example
     * // Update one RVApprover
     * const rVApprover = await prisma.rVApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RVApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverUpdateArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RVApprovers.
     * @param {RVApproverDeleteManyArgs} args - Arguments to filter RVApprovers to delete.
     * @example
     * // Delete a few RVApprovers
     * const { count } = await prisma.rVApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RVApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RVApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RVApprovers
     * const rVApprover = await prisma.rVApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RVApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RVApprover.
     * @param {RVApproverUpsertArgs} args - Arguments to update or create a RVApprover.
     * @example
     * // Update or create a RVApprover
     * const rVApprover = await prisma.rVApprover.upsert({
     *   create: {
     *     // ... data to create a RVApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RVApprover we want to update
     *   }
     * })
    **/
    upsert<T extends RVApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RVApproverUpsertArgs<ExtArgs>>
    ): Prisma__RVApproverClient<$Result.GetResult<Prisma.$RVApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RVApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverCountArgs} args - Arguments to filter RVApprovers to count.
     * @example
     * // Count the number of RVApprovers
     * const count = await prisma.rVApprover.count({
     *   where: {
     *     // ... the filter for the RVApprovers we want to count
     *   }
     * })
    **/
    count<T extends RVApproverCountArgs>(
      args?: Subset<T, RVApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RVApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RVApproverAggregateArgs>(args: Subset<T, RVApproverAggregateArgs>): Prisma.PrismaPromise<GetRVApproverAggregateType<T>>

    /**
     * Group by RVApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RVApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RVApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RVApproverGroupByArgs['orderBy'] }
        : { orderBy?: RVApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RVApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRVApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RVApprover model
   */
  readonly fields: RVApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RVApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RVApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rv<T extends RVDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RVDefaultArgs<ExtArgs>>): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RVApprover model
   */ 
  interface RVApproverFieldRefs {
    readonly id: FieldRef<"RVApprover", 'String'>
    readonly rv_id: FieldRef<"RVApprover", 'String'>
    readonly approver_id: FieldRef<"RVApprover", 'String'>
    readonly approver_proxy_id: FieldRef<"RVApprover", 'String'>
    readonly date_approval: FieldRef<"RVApprover", 'DateTime'>
    readonly notes: FieldRef<"RVApprover", 'String'>
    readonly status: FieldRef<"RVApprover", 'Int'>
    readonly label: FieldRef<"RVApprover", 'String'>
    readonly order: FieldRef<"RVApprover", 'Int'>
    readonly created_at: FieldRef<"RVApprover", 'DateTime'>
    readonly updated_at: FieldRef<"RVApprover", 'DateTime'>
    readonly is_deleted: FieldRef<"RVApprover", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * RVApprover findUnique
   */
  export type RVApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover findUniqueOrThrow
   */
  export type RVApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover findFirst
   */
  export type RVApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVApprovers.
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVApprovers.
     */
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RVApprover findFirstOrThrow
   */
  export type RVApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprover to fetch.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RVApprovers.
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RVApprovers.
     */
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RVApprover findMany
   */
  export type RVApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter, which RVApprovers to fetch.
     */
    where?: RVApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RVApprovers to fetch.
     */
    orderBy?: RVApproverOrderByWithRelationInput | RVApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RVApprovers.
     */
    cursor?: RVApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RVApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RVApprovers.
     */
    skip?: number
    distinct?: RVApproverScalarFieldEnum | RVApproverScalarFieldEnum[]
  }


  /**
   * RVApprover create
   */
  export type RVApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a RVApprover.
     */
    data: XOR<RVApproverCreateInput, RVApproverUncheckedCreateInput>
  }


  /**
   * RVApprover createMany
   */
  export type RVApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RVApprovers.
     */
    data: RVApproverCreateManyInput | RVApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RVApprover update
   */
  export type RVApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a RVApprover.
     */
    data: XOR<RVApproverUpdateInput, RVApproverUncheckedUpdateInput>
    /**
     * Choose, which RVApprover to update.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover updateMany
   */
  export type RVApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RVApprovers.
     */
    data: XOR<RVApproverUpdateManyMutationInput, RVApproverUncheckedUpdateManyInput>
    /**
     * Filter which RVApprovers to update
     */
    where?: RVApproverWhereInput
  }


  /**
   * RVApprover upsert
   */
  export type RVApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the RVApprover to update in case it exists.
     */
    where: RVApproverWhereUniqueInput
    /**
     * In case the RVApprover found by the `where` argument doesn't exist, create a new RVApprover with this data.
     */
    create: XOR<RVApproverCreateInput, RVApproverUncheckedCreateInput>
    /**
     * In case the RVApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RVApproverUpdateInput, RVApproverUncheckedUpdateInput>
  }


  /**
   * RVApprover delete
   */
  export type RVApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
    /**
     * Filter which RVApprover to delete.
     */
    where: RVApproverWhereUniqueInput
  }


  /**
   * RVApprover deleteMany
   */
  export type RVApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RVApprovers to delete
     */
    where?: RVApproverWhereInput
  }


  /**
   * RVApprover without action
   */
  export type RVApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RVApprover
     */
    select?: RVApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVApproverInclude<ExtArgs> | null
  }



  /**
   * Model SPR
   */

  export type AggregateSPR = {
    _count: SPRCountAggregateOutputType | null
    _avg: SPRAvgAggregateOutputType | null
    _sum: SPRSumAggregateOutputType | null
    _min: SPRMinAggregateOutputType | null
    _max: SPRMaxAggregateOutputType | null
  }

  export type SPRAvgAggregateOutputType = {
    status: number | null
  }

  export type SPRSumAggregateOutputType = {
    status: number | null
  }

  export type SPRMinAggregateOutputType = {
    id: string | null
    spr_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    vehicle_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    status: number | null
    canceller_id: string | null
    date_cancelled: Date | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type SPRMaxAggregateOutputType = {
    id: string | null
    spr_number: string | null
    date_requested: Date | null
    canvass_id: string | null
    vehicle_id: string | null
    classification_id: string | null
    supervisor_id: string | null
    status: number | null
    canceller_id: string | null
    date_cancelled: Date | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type SPRCountAggregateOutputType = {
    id: number
    spr_number: number
    date_requested: number
    canvass_id: number
    vehicle_id: number
    classification_id: number
    supervisor_id: number
    status: number
    canceller_id: number
    date_cancelled: number
    is_referenced: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type SPRAvgAggregateInputType = {
    status?: true
  }

  export type SPRSumAggregateInputType = {
    status?: true
  }

  export type SPRMinAggregateInputType = {
    id?: true
    spr_number?: true
    date_requested?: true
    canvass_id?: true
    vehicle_id?: true
    classification_id?: true
    supervisor_id?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type SPRMaxAggregateInputType = {
    id?: true
    spr_number?: true
    date_requested?: true
    canvass_id?: true
    vehicle_id?: true
    classification_id?: true
    supervisor_id?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type SPRCountAggregateInputType = {
    id?: true
    spr_number?: true
    date_requested?: true
    canvass_id?: true
    vehicle_id?: true
    classification_id?: true
    supervisor_id?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type SPRAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPR to aggregate.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SPRS
    **/
    _count?: true | SPRCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SPRAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SPRSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SPRMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SPRMaxAggregateInputType
  }

  export type GetSPRAggregateType<T extends SPRAggregateArgs> = {
        [P in keyof T & keyof AggregateSPR]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSPR[P]>
      : GetScalarType<T[P], AggregateSPR[P]>
  }




  export type SPRGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRWhereInput
    orderBy?: SPROrderByWithAggregationInput | SPROrderByWithAggregationInput[]
    by: SPRScalarFieldEnum[] | SPRScalarFieldEnum
    having?: SPRScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SPRCountAggregateInputType | true
    _avg?: SPRAvgAggregateInputType
    _sum?: SPRSumAggregateInputType
    _min?: SPRMinAggregateInputType
    _max?: SPRMaxAggregateInputType
  }

  export type SPRGroupByOutputType = {
    id: string
    spr_number: string
    date_requested: Date
    canvass_id: string
    vehicle_id: string
    classification_id: string | null
    supervisor_id: string
    status: number
    canceller_id: string | null
    date_cancelled: Date | null
    is_referenced: boolean
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: SPRCountAggregateOutputType | null
    _avg: SPRAvgAggregateOutputType | null
    _sum: SPRSumAggregateOutputType | null
    _min: SPRMinAggregateOutputType | null
    _max: SPRMaxAggregateOutputType | null
  }

  type GetSPRGroupByPayload<T extends SPRGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SPRGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SPRGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SPRGroupByOutputType[P]>
            : GetScalarType<T[P], SPRGroupByOutputType[P]>
        }
      >
    >


  export type SPRSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spr_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    vehicle_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    status?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    meqs?: boolean | SPR$meqsArgs<ExtArgs>
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    spr_approvers?: boolean | SPR$spr_approversArgs<ExtArgs>
    _count?: boolean | SPRCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sPR"]>

  export type SPRSelectScalar = {
    id?: boolean
    spr_number?: boolean
    date_requested?: boolean
    canvass_id?: boolean
    vehicle_id?: boolean
    classification_id?: boolean
    supervisor_id?: boolean
    status?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type SPRInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs?: boolean | SPR$meqsArgs<ExtArgs>
    canvass?: boolean | CanvassDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    spr_approvers?: boolean | SPR$spr_approversArgs<ExtArgs>
    _count?: boolean | SPRCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SPRPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SPR"
    objects: {
      meqs: Prisma.$MEQSPayload<ExtArgs> | null
      canvass: Prisma.$CanvassPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      spr_approvers: Prisma.$SPRApproverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spr_number: string
      date_requested: Date
      canvass_id: string
      vehicle_id: string
      classification_id: string | null
      supervisor_id: string
      status: number
      canceller_id: string | null
      date_cancelled: Date | null
      is_referenced: boolean
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["sPR"]>
    composites: {}
  }


  type SPRGetPayload<S extends boolean | null | undefined | SPRDefaultArgs> = $Result.GetResult<Prisma.$SPRPayload, S>

  type SPRCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SPRFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SPRCountAggregateInputType | true
    }

  export interface SPRDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SPR'], meta: { name: 'SPR' } }
    /**
     * Find zero or one SPR that matches the filter.
     * @param {SPRFindUniqueArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SPRFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SPRFindUniqueArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SPR that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SPRFindUniqueOrThrowArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SPRFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SPR that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRFindFirstArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SPRFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindFirstArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SPR that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRFindFirstOrThrowArgs} args - Arguments to find a SPR
     * @example
     * // Get one SPR
     * const sPR = await prisma.sPR.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SPRFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SPRS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SPRS
     * const sPRS = await prisma.sPR.findMany()
     * 
     * // Get first 10 SPRS
     * const sPRS = await prisma.sPR.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sPRWithIdOnly = await prisma.sPR.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SPRFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SPR.
     * @param {SPRCreateArgs} args - Arguments to create a SPR.
     * @example
     * // Create one SPR
     * const SPR = await prisma.sPR.create({
     *   data: {
     *     // ... data to create a SPR
     *   }
     * })
     * 
    **/
    create<T extends SPRCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRCreateArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SPRS.
     *     @param {SPRCreateManyArgs} args - Arguments to create many SPRS.
     *     @example
     *     // Create many SPRS
     *     const sPR = await prisma.sPR.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SPRCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SPR.
     * @param {SPRDeleteArgs} args - Arguments to delete one SPR.
     * @example
     * // Delete one SPR
     * const SPR = await prisma.sPR.delete({
     *   where: {
     *     // ... filter to delete one SPR
     *   }
     * })
     * 
    **/
    delete<T extends SPRDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SPRDeleteArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SPR.
     * @param {SPRUpdateArgs} args - Arguments to update one SPR.
     * @example
     * // Update one SPR
     * const sPR = await prisma.sPR.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SPRUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRUpdateArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SPRS.
     * @param {SPRDeleteManyArgs} args - Arguments to filter SPRS to delete.
     * @example
     * // Delete a few SPRS
     * const { count } = await prisma.sPR.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SPRDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SPRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SPRS
     * const sPR = await prisma.sPR.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SPRUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SPRUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SPR.
     * @param {SPRUpsertArgs} args - Arguments to update or create a SPR.
     * @example
     * // Update or create a SPR
     * const sPR = await prisma.sPR.upsert({
     *   create: {
     *     // ... data to create a SPR
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SPR we want to update
     *   }
     * })
    **/
    upsert<T extends SPRUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SPRUpsertArgs<ExtArgs>>
    ): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SPRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRCountArgs} args - Arguments to filter SPRS to count.
     * @example
     * // Count the number of SPRS
     * const count = await prisma.sPR.count({
     *   where: {
     *     // ... the filter for the SPRS we want to count
     *   }
     * })
    **/
    count<T extends SPRCountArgs>(
      args?: Subset<T, SPRCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SPRCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SPR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SPRAggregateArgs>(args: Subset<T, SPRAggregateArgs>): Prisma.PrismaPromise<GetSPRAggregateType<T>>

    /**
     * Group by SPR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SPRGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SPRGroupByArgs['orderBy'] }
        : { orderBy?: SPRGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SPRGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSPRGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SPR model
   */
  readonly fields: SPRFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SPR.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SPRClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs<T extends SPR$meqsArgs<ExtArgs> = {}>(args?: Subset<T, SPR$meqsArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    canvass<T extends CanvassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvassDefaultArgs<ExtArgs>>): Prisma__CanvassClient<$Result.GetResult<Prisma.$CanvassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    spr_approvers<T extends SPR$spr_approversArgs<ExtArgs> = {}>(args?: Subset<T, SPR$spr_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SPR model
   */ 
  interface SPRFieldRefs {
    readonly id: FieldRef<"SPR", 'String'>
    readonly spr_number: FieldRef<"SPR", 'String'>
    readonly date_requested: FieldRef<"SPR", 'DateTime'>
    readonly canvass_id: FieldRef<"SPR", 'String'>
    readonly vehicle_id: FieldRef<"SPR", 'String'>
    readonly classification_id: FieldRef<"SPR", 'String'>
    readonly supervisor_id: FieldRef<"SPR", 'String'>
    readonly status: FieldRef<"SPR", 'Int'>
    readonly canceller_id: FieldRef<"SPR", 'String'>
    readonly date_cancelled: FieldRef<"SPR", 'DateTime'>
    readonly is_referenced: FieldRef<"SPR", 'Boolean'>
    readonly created_at: FieldRef<"SPR", 'DateTime'>
    readonly updated_at: FieldRef<"SPR", 'DateTime'>
    readonly is_deleted: FieldRef<"SPR", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * SPR findUnique
   */
  export type SPRFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR findUniqueOrThrow
   */
  export type SPRFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR findFirst
   */
  export type SPRFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRS.
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRS.
     */
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * SPR findFirstOrThrow
   */
  export type SPRFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPR to fetch.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRS.
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRS.
     */
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * SPR findMany
   */
  export type SPRFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter, which SPRS to fetch.
     */
    where?: SPRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRS to fetch.
     */
    orderBy?: SPROrderByWithRelationInput | SPROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SPRS.
     */
    cursor?: SPRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRS.
     */
    skip?: number
    distinct?: SPRScalarFieldEnum | SPRScalarFieldEnum[]
  }


  /**
   * SPR create
   */
  export type SPRCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * The data needed to create a SPR.
     */
    data: XOR<SPRCreateInput, SPRUncheckedCreateInput>
  }


  /**
   * SPR createMany
   */
  export type SPRCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SPRS.
     */
    data: SPRCreateManyInput | SPRCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SPR update
   */
  export type SPRUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * The data needed to update a SPR.
     */
    data: XOR<SPRUpdateInput, SPRUncheckedUpdateInput>
    /**
     * Choose, which SPR to update.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR updateMany
   */
  export type SPRUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SPRS.
     */
    data: XOR<SPRUpdateManyMutationInput, SPRUncheckedUpdateManyInput>
    /**
     * Filter which SPRS to update
     */
    where?: SPRWhereInput
  }


  /**
   * SPR upsert
   */
  export type SPRUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * The filter to search for the SPR to update in case it exists.
     */
    where: SPRWhereUniqueInput
    /**
     * In case the SPR found by the `where` argument doesn't exist, create a new SPR with this data.
     */
    create: XOR<SPRCreateInput, SPRUncheckedCreateInput>
    /**
     * In case the SPR was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SPRUpdateInput, SPRUncheckedUpdateInput>
  }


  /**
   * SPR delete
   */
  export type SPRDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    /**
     * Filter which SPR to delete.
     */
    where: SPRWhereUniqueInput
  }


  /**
   * SPR deleteMany
   */
  export type SPRDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPRS to delete
     */
    where?: SPRWhereInput
  }


  /**
   * SPR.meqs
   */
  export type SPR$meqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    where?: MEQSWhereInput
  }


  /**
   * SPR.spr_approvers
   */
  export type SPR$spr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    where?: SPRApproverWhereInput
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    cursor?: SPRApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPR without action
   */
  export type SPRDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
  }



  /**
   * Model SPRApprover
   */

  export type AggregateSPRApprover = {
    _count: SPRApproverCountAggregateOutputType | null
    _avg: SPRApproverAvgAggregateOutputType | null
    _sum: SPRApproverSumAggregateOutputType | null
    _min: SPRApproverMinAggregateOutputType | null
    _max: SPRApproverMaxAggregateOutputType | null
  }

  export type SPRApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type SPRApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type SPRApproverMinAggregateOutputType = {
    id: string | null
    spr_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type SPRApproverMaxAggregateOutputType = {
    id: string | null
    spr_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type SPRApproverCountAggregateOutputType = {
    id: number
    spr_id: number
    approver_id: number
    approver_proxy_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type SPRApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type SPRApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type SPRApproverMinAggregateInputType = {
    id?: true
    spr_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type SPRApproverMaxAggregateInputType = {
    id?: true
    spr_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type SPRApproverCountAggregateInputType = {
    id?: true
    spr_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type SPRApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPRApprover to aggregate.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SPRApprovers
    **/
    _count?: true | SPRApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SPRApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SPRApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SPRApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SPRApproverMaxAggregateInputType
  }

  export type GetSPRApproverAggregateType<T extends SPRApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateSPRApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSPRApprover[P]>
      : GetScalarType<T[P], AggregateSPRApprover[P]>
  }




  export type SPRApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SPRApproverWhereInput
    orderBy?: SPRApproverOrderByWithAggregationInput | SPRApproverOrderByWithAggregationInput[]
    by: SPRApproverScalarFieldEnum[] | SPRApproverScalarFieldEnum
    having?: SPRApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SPRApproverCountAggregateInputType | true
    _avg?: SPRApproverAvgAggregateInputType
    _sum?: SPRApproverSumAggregateInputType
    _min?: SPRApproverMinAggregateInputType
    _max?: SPRApproverMaxAggregateInputType
  }

  export type SPRApproverGroupByOutputType = {
    id: string
    spr_id: string
    approver_id: string
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number
    label: string
    order: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: SPRApproverCountAggregateOutputType | null
    _avg: SPRApproverAvgAggregateOutputType | null
    _sum: SPRApproverSumAggregateOutputType | null
    _min: SPRApproverMinAggregateOutputType | null
    _max: SPRApproverMaxAggregateOutputType | null
  }

  type GetSPRApproverGroupByPayload<T extends SPRApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SPRApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SPRApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SPRApproverGroupByOutputType[P]>
            : GetScalarType<T[P], SPRApproverGroupByOutputType[P]>
        }
      >
    >


  export type SPRApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spr_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    spr?: boolean | SPRDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sPRApprover"]>

  export type SPRApproverSelectScalar = {
    id?: boolean
    spr_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type SPRApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spr?: boolean | SPRDefaultArgs<ExtArgs>
  }


  export type $SPRApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SPRApprover"
    objects: {
      spr: Prisma.$SPRPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spr_id: string
      approver_id: string
      approver_proxy_id: string | null
      date_approval: Date | null
      notes: string | null
      status: number
      label: string
      order: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["sPRApprover"]>
    composites: {}
  }


  type SPRApproverGetPayload<S extends boolean | null | undefined | SPRApproverDefaultArgs> = $Result.GetResult<Prisma.$SPRApproverPayload, S>

  type SPRApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SPRApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SPRApproverCountAggregateInputType | true
    }

  export interface SPRApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SPRApprover'], meta: { name: 'SPRApprover' } }
    /**
     * Find zero or one SPRApprover that matches the filter.
     * @param {SPRApproverFindUniqueArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SPRApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SPRApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SPRApproverFindUniqueOrThrowArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SPRApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SPRApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverFindFirstArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SPRApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindFirstArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SPRApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverFindFirstOrThrowArgs} args - Arguments to find a SPRApprover
     * @example
     * // Get one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SPRApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SPRApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SPRApprovers
     * const sPRApprovers = await prisma.sPRApprover.findMany()
     * 
     * // Get first 10 SPRApprovers
     * const sPRApprovers = await prisma.sPRApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sPRApproverWithIdOnly = await prisma.sPRApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SPRApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SPRApprover.
     * @param {SPRApproverCreateArgs} args - Arguments to create a SPRApprover.
     * @example
     * // Create one SPRApprover
     * const SPRApprover = await prisma.sPRApprover.create({
     *   data: {
     *     // ... data to create a SPRApprover
     *   }
     * })
     * 
    **/
    create<T extends SPRApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverCreateArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SPRApprovers.
     *     @param {SPRApproverCreateManyArgs} args - Arguments to create many SPRApprovers.
     *     @example
     *     // Create many SPRApprovers
     *     const sPRApprover = await prisma.sPRApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SPRApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SPRApprover.
     * @param {SPRApproverDeleteArgs} args - Arguments to delete one SPRApprover.
     * @example
     * // Delete one SPRApprover
     * const SPRApprover = await prisma.sPRApprover.delete({
     *   where: {
     *     // ... filter to delete one SPRApprover
     *   }
     * })
     * 
    **/
    delete<T extends SPRApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverDeleteArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SPRApprover.
     * @param {SPRApproverUpdateArgs} args - Arguments to update one SPRApprover.
     * @example
     * // Update one SPRApprover
     * const sPRApprover = await prisma.sPRApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SPRApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverUpdateArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SPRApprovers.
     * @param {SPRApproverDeleteManyArgs} args - Arguments to filter SPRApprovers to delete.
     * @example
     * // Delete a few SPRApprovers
     * const { count } = await prisma.sPRApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SPRApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SPRApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SPRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SPRApprovers
     * const sPRApprover = await prisma.sPRApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SPRApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SPRApprover.
     * @param {SPRApproverUpsertArgs} args - Arguments to update or create a SPRApprover.
     * @example
     * // Update or create a SPRApprover
     * const sPRApprover = await prisma.sPRApprover.upsert({
     *   create: {
     *     // ... data to create a SPRApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SPRApprover we want to update
     *   }
     * })
    **/
    upsert<T extends SPRApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SPRApproverUpsertArgs<ExtArgs>>
    ): Prisma__SPRApproverClient<$Result.GetResult<Prisma.$SPRApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SPRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverCountArgs} args - Arguments to filter SPRApprovers to count.
     * @example
     * // Count the number of SPRApprovers
     * const count = await prisma.sPRApprover.count({
     *   where: {
     *     // ... the filter for the SPRApprovers we want to count
     *   }
     * })
    **/
    count<T extends SPRApproverCountArgs>(
      args?: Subset<T, SPRApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SPRApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SPRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SPRApproverAggregateArgs>(args: Subset<T, SPRApproverAggregateArgs>): Prisma.PrismaPromise<GetSPRApproverAggregateType<T>>

    /**
     * Group by SPRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SPRApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SPRApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SPRApproverGroupByArgs['orderBy'] }
        : { orderBy?: SPRApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SPRApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSPRApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SPRApprover model
   */
  readonly fields: SPRApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SPRApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SPRApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spr<T extends SPRDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SPRDefaultArgs<ExtArgs>>): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SPRApprover model
   */ 
  interface SPRApproverFieldRefs {
    readonly id: FieldRef<"SPRApprover", 'String'>
    readonly spr_id: FieldRef<"SPRApprover", 'String'>
    readonly approver_id: FieldRef<"SPRApprover", 'String'>
    readonly approver_proxy_id: FieldRef<"SPRApprover", 'String'>
    readonly date_approval: FieldRef<"SPRApprover", 'DateTime'>
    readonly notes: FieldRef<"SPRApprover", 'String'>
    readonly status: FieldRef<"SPRApprover", 'Int'>
    readonly label: FieldRef<"SPRApprover", 'String'>
    readonly order: FieldRef<"SPRApprover", 'Int'>
    readonly created_at: FieldRef<"SPRApprover", 'DateTime'>
    readonly updated_at: FieldRef<"SPRApprover", 'DateTime'>
    readonly is_deleted: FieldRef<"SPRApprover", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * SPRApprover findUnique
   */
  export type SPRApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover findUniqueOrThrow
   */
  export type SPRApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover findFirst
   */
  export type SPRApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRApprovers.
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRApprovers.
     */
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPRApprover findFirstOrThrow
   */
  export type SPRApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprover to fetch.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SPRApprovers.
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SPRApprovers.
     */
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPRApprover findMany
   */
  export type SPRApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter, which SPRApprovers to fetch.
     */
    where?: SPRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SPRApprovers to fetch.
     */
    orderBy?: SPRApproverOrderByWithRelationInput | SPRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SPRApprovers.
     */
    cursor?: SPRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SPRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SPRApprovers.
     */
    skip?: number
    distinct?: SPRApproverScalarFieldEnum | SPRApproverScalarFieldEnum[]
  }


  /**
   * SPRApprover create
   */
  export type SPRApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a SPRApprover.
     */
    data: XOR<SPRApproverCreateInput, SPRApproverUncheckedCreateInput>
  }


  /**
   * SPRApprover createMany
   */
  export type SPRApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SPRApprovers.
     */
    data: SPRApproverCreateManyInput | SPRApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SPRApprover update
   */
  export type SPRApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a SPRApprover.
     */
    data: XOR<SPRApproverUpdateInput, SPRApproverUncheckedUpdateInput>
    /**
     * Choose, which SPRApprover to update.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover updateMany
   */
  export type SPRApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SPRApprovers.
     */
    data: XOR<SPRApproverUpdateManyMutationInput, SPRApproverUncheckedUpdateManyInput>
    /**
     * Filter which SPRApprovers to update
     */
    where?: SPRApproverWhereInput
  }


  /**
   * SPRApprover upsert
   */
  export type SPRApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the SPRApprover to update in case it exists.
     */
    where: SPRApproverWhereUniqueInput
    /**
     * In case the SPRApprover found by the `where` argument doesn't exist, create a new SPRApprover with this data.
     */
    create: XOR<SPRApproverCreateInput, SPRApproverUncheckedCreateInput>
    /**
     * In case the SPRApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SPRApproverUpdateInput, SPRApproverUncheckedUpdateInput>
  }


  /**
   * SPRApprover delete
   */
  export type SPRApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
    /**
     * Filter which SPRApprover to delete.
     */
    where: SPRApproverWhereUniqueInput
  }


  /**
   * SPRApprover deleteMany
   */
  export type SPRApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SPRApprovers to delete
     */
    where?: SPRApproverWhereInput
  }


  /**
   * SPRApprover without action
   */
  export type SPRApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPRApprover
     */
    select?: SPRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRApproverInclude<ExtArgs> | null
  }



  /**
   * Model MEQS
   */

  export type AggregateMEQS = {
    _count: MEQSCountAggregateOutputType | null
    _avg: MEQSAvgAggregateOutputType | null
    _sum: MEQSSumAggregateOutputType | null
    _min: MEQSMinAggregateOutputType | null
    _max: MEQSMaxAggregateOutputType | null
  }

  export type MEQSAvgAggregateOutputType = {
    request_type: number | null
    status: number | null
  }

  export type MEQSSumAggregateOutputType = {
    request_type: number | null
    status: number | null
  }

  export type MEQSMinAggregateOutputType = {
    id: string | null
    jo_id: string | null
    rv_id: string | null
    spr_id: string | null
    meqs_number: string | null
    request_type: number | null
    meqs_date: Date | null
    status: number | null
    notes: string | null
    canceller_id: string | null
    date_cancelled: Date | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSMaxAggregateOutputType = {
    id: string | null
    jo_id: string | null
    rv_id: string | null
    spr_id: string | null
    meqs_number: string | null
    request_type: number | null
    meqs_date: Date | null
    status: number | null
    notes: string | null
    canceller_id: string | null
    date_cancelled: Date | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSCountAggregateOutputType = {
    id: number
    jo_id: number
    rv_id: number
    spr_id: number
    meqs_number: number
    request_type: number
    meqs_date: number
    status: number
    notes: number
    canceller_id: number
    date_cancelled: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type MEQSAvgAggregateInputType = {
    request_type?: true
    status?: true
  }

  export type MEQSSumAggregateInputType = {
    request_type?: true
    status?: true
  }

  export type MEQSMinAggregateInputType = {
    id?: true
    jo_id?: true
    rv_id?: true
    spr_id?: true
    meqs_number?: true
    request_type?: true
    meqs_date?: true
    status?: true
    notes?: true
    canceller_id?: true
    date_cancelled?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSMaxAggregateInputType = {
    id?: true
    jo_id?: true
    rv_id?: true
    spr_id?: true
    meqs_number?: true
    request_type?: true
    meqs_date?: true
    status?: true
    notes?: true
    canceller_id?: true
    date_cancelled?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSCountAggregateInputType = {
    id?: true
    jo_id?: true
    rv_id?: true
    spr_id?: true
    meqs_number?: true
    request_type?: true
    meqs_date?: true
    status?: true
    notes?: true
    canceller_id?: true
    date_cancelled?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type MEQSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQS to aggregate.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQS
    **/
    _count?: true | MEQSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MEQSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MEQSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSMaxAggregateInputType
  }

  export type GetMEQSAggregateType<T extends MEQSAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQS[P]>
      : GetScalarType<T[P], AggregateMEQS[P]>
  }




  export type MEQSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSWhereInput
    orderBy?: MEQSOrderByWithAggregationInput | MEQSOrderByWithAggregationInput[]
    by: MEQSScalarFieldEnum[] | MEQSScalarFieldEnum
    having?: MEQSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSCountAggregateInputType | true
    _avg?: MEQSAvgAggregateInputType
    _sum?: MEQSSumAggregateInputType
    _min?: MEQSMinAggregateInputType
    _max?: MEQSMaxAggregateInputType
  }

  export type MEQSGroupByOutputType = {
    id: string
    jo_id: string | null
    rv_id: string | null
    spr_id: string | null
    meqs_number: string
    request_type: number
    meqs_date: Date
    status: number
    notes: string | null
    canceller_id: string | null
    date_cancelled: Date | null
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: MEQSCountAggregateOutputType | null
    _avg: MEQSAvgAggregateOutputType | null
    _sum: MEQSSumAggregateOutputType | null
    _min: MEQSMinAggregateOutputType | null
    _max: MEQSMaxAggregateOutputType | null
  }

  type GetMEQSGroupByPayload<T extends MEQSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jo_id?: boolean
    rv_id?: boolean
    spr_id?: boolean
    meqs_number?: boolean
    request_type?: boolean
    meqs_date?: boolean
    status?: boolean
    notes?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    jo?: boolean | MEQS$joArgs<ExtArgs>
    rv?: boolean | MEQS$rvArgs<ExtArgs>
    spr?: boolean | MEQS$sprArgs<ExtArgs>
    meqs_approvers?: boolean | MEQS$meqs_approversArgs<ExtArgs>
    meqs_suppliers?: boolean | MEQS$meqs_suppliersArgs<ExtArgs>
    _count?: boolean | MEQSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQS"]>

  export type MEQSSelectScalar = {
    id?: boolean
    jo_id?: boolean
    rv_id?: boolean
    spr_id?: boolean
    meqs_number?: boolean
    request_type?: boolean
    meqs_date?: boolean
    status?: boolean
    notes?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type MEQSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jo?: boolean | MEQS$joArgs<ExtArgs>
    rv?: boolean | MEQS$rvArgs<ExtArgs>
    spr?: boolean | MEQS$sprArgs<ExtArgs>
    meqs_approvers?: boolean | MEQS$meqs_approversArgs<ExtArgs>
    meqs_suppliers?: boolean | MEQS$meqs_suppliersArgs<ExtArgs>
    _count?: boolean | MEQSCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MEQSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQS"
    objects: {
      jo: Prisma.$JOPayload<ExtArgs> | null
      rv: Prisma.$RVPayload<ExtArgs> | null
      spr: Prisma.$SPRPayload<ExtArgs> | null
      meqs_approvers: Prisma.$MEQSApproverPayload<ExtArgs>[]
      meqs_suppliers: Prisma.$MEQSSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jo_id: string | null
      rv_id: string | null
      spr_id: string | null
      meqs_number: string
      request_type: number
      meqs_date: Date
      status: number
      notes: string | null
      canceller_id: string | null
      date_cancelled: Date | null
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["mEQS"]>
    composites: {}
  }


  type MEQSGetPayload<S extends boolean | null | undefined | MEQSDefaultArgs> = $Result.GetResult<Prisma.$MEQSPayload, S>

  type MEQSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSCountAggregateInputType | true
    }

  export interface MEQSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQS'], meta: { name: 'MEQS' } }
    /**
     * Find zero or one MEQS that matches the filter.
     * @param {MEQSFindUniqueArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQS that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSFindUniqueOrThrowArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSFindFirstArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSFindFirstOrThrowArgs} args - Arguments to find a MEQS
     * @example
     * // Get one MEQS
     * const mEQS = await prisma.mEQS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQS
     * const mEQS = await prisma.mEQS.findMany()
     * 
     * // Get first 10 MEQS
     * const mEQS = await prisma.mEQS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSWithIdOnly = await prisma.mEQS.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQS.
     * @param {MEQSCreateArgs} args - Arguments to create a MEQS.
     * @example
     * // Create one MEQS
     * const MEQS = await prisma.mEQS.create({
     *   data: {
     *     // ... data to create a MEQS
     *   }
     * })
     * 
    **/
    create<T extends MEQSCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSCreateArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQS.
     *     @param {MEQSCreateManyArgs} args - Arguments to create many MEQS.
     *     @example
     *     // Create many MEQS
     *     const mEQS = await prisma.mEQS.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQS.
     * @param {MEQSDeleteArgs} args - Arguments to delete one MEQS.
     * @example
     * // Delete one MEQS
     * const MEQS = await prisma.mEQS.delete({
     *   where: {
     *     // ... filter to delete one MEQS
     *   }
     * })
     * 
    **/
    delete<T extends MEQSDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSDeleteArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQS.
     * @param {MEQSUpdateArgs} args - Arguments to update one MEQS.
     * @example
     * // Update one MEQS
     * const mEQS = await prisma.mEQS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSUpdateArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQS.
     * @param {MEQSDeleteManyArgs} args - Arguments to filter MEQS to delete.
     * @example
     * // Delete a few MEQS
     * const { count } = await prisma.mEQS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQS
     * const mEQS = await prisma.mEQS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQS.
     * @param {MEQSUpsertArgs} args - Arguments to update or create a MEQS.
     * @example
     * // Update or create a MEQS
     * const mEQS = await prisma.mEQS.upsert({
     *   create: {
     *     // ... data to create a MEQS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQS we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSUpsertArgs<ExtArgs>>
    ): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSCountArgs} args - Arguments to filter MEQS to count.
     * @example
     * // Count the number of MEQS
     * const count = await prisma.mEQS.count({
     *   where: {
     *     // ... the filter for the MEQS we want to count
     *   }
     * })
    **/
    count<T extends MEQSCountArgs>(
      args?: Subset<T, MEQSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSAggregateArgs>(args: Subset<T, MEQSAggregateArgs>): Prisma.PrismaPromise<GetMEQSAggregateType<T>>

    /**
     * Group by MEQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSGroupByArgs['orderBy'] }
        : { orderBy?: MEQSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQS model
   */
  readonly fields: MEQSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jo<T extends MEQS$joArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$joArgs<ExtArgs>>): Prisma__JOClient<$Result.GetResult<Prisma.$JOPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rv<T extends MEQS$rvArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$rvArgs<ExtArgs>>): Prisma__RVClient<$Result.GetResult<Prisma.$RVPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    spr<T extends MEQS$sprArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$sprArgs<ExtArgs>>): Prisma__SPRClient<$Result.GetResult<Prisma.$SPRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    meqs_approvers<T extends MEQS$meqs_approversArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$meqs_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    meqs_suppliers<T extends MEQS$meqs_suppliersArgs<ExtArgs> = {}>(args?: Subset<T, MEQS$meqs_suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQS model
   */ 
  interface MEQSFieldRefs {
    readonly id: FieldRef<"MEQS", 'String'>
    readonly jo_id: FieldRef<"MEQS", 'String'>
    readonly rv_id: FieldRef<"MEQS", 'String'>
    readonly spr_id: FieldRef<"MEQS", 'String'>
    readonly meqs_number: FieldRef<"MEQS", 'String'>
    readonly request_type: FieldRef<"MEQS", 'Int'>
    readonly meqs_date: FieldRef<"MEQS", 'DateTime'>
    readonly status: FieldRef<"MEQS", 'Int'>
    readonly notes: FieldRef<"MEQS", 'String'>
    readonly canceller_id: FieldRef<"MEQS", 'String'>
    readonly date_cancelled: FieldRef<"MEQS", 'DateTime'>
    readonly created_at: FieldRef<"MEQS", 'DateTime'>
    readonly updated_at: FieldRef<"MEQS", 'DateTime'>
    readonly is_deleted: FieldRef<"MEQS", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * MEQS findUnique
   */
  export type MEQSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS findUniqueOrThrow
   */
  export type MEQSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS findFirst
   */
  export type MEQSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQS.
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQS.
     */
    distinct?: MEQSScalarFieldEnum | MEQSScalarFieldEnum[]
  }


  /**
   * MEQS findFirstOrThrow
   */
  export type MEQSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQS.
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQS.
     */
    distinct?: MEQSScalarFieldEnum | MEQSScalarFieldEnum[]
  }


  /**
   * MEQS findMany
   */
  export type MEQSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter, which MEQS to fetch.
     */
    where?: MEQSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQS to fetch.
     */
    orderBy?: MEQSOrderByWithRelationInput | MEQSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQS.
     */
    cursor?: MEQSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQS.
     */
    skip?: number
    distinct?: MEQSScalarFieldEnum | MEQSScalarFieldEnum[]
  }


  /**
   * MEQS create
   */
  export type MEQSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQS.
     */
    data: XOR<MEQSCreateInput, MEQSUncheckedCreateInput>
  }


  /**
   * MEQS createMany
   */
  export type MEQSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQS.
     */
    data: MEQSCreateManyInput | MEQSCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQS update
   */
  export type MEQSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQS.
     */
    data: XOR<MEQSUpdateInput, MEQSUncheckedUpdateInput>
    /**
     * Choose, which MEQS to update.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS updateMany
   */
  export type MEQSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQS.
     */
    data: XOR<MEQSUpdateManyMutationInput, MEQSUncheckedUpdateManyInput>
    /**
     * Filter which MEQS to update
     */
    where?: MEQSWhereInput
  }


  /**
   * MEQS upsert
   */
  export type MEQSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQS to update in case it exists.
     */
    where: MEQSWhereUniqueInput
    /**
     * In case the MEQS found by the `where` argument doesn't exist, create a new MEQS with this data.
     */
    create: XOR<MEQSCreateInput, MEQSUncheckedCreateInput>
    /**
     * In case the MEQS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSUpdateInput, MEQSUncheckedUpdateInput>
  }


  /**
   * MEQS delete
   */
  export type MEQSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
    /**
     * Filter which MEQS to delete.
     */
    where: MEQSWhereUniqueInput
  }


  /**
   * MEQS deleteMany
   */
  export type MEQSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQS to delete
     */
    where?: MEQSWhereInput
  }


  /**
   * MEQS.jo
   */
  export type MEQS$joArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JO
     */
    select?: JOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JOInclude<ExtArgs> | null
    where?: JOWhereInput
  }


  /**
   * MEQS.rv
   */
  export type MEQS$rvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RV
     */
    select?: RVSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RVInclude<ExtArgs> | null
    where?: RVWhereInput
  }


  /**
   * MEQS.spr
   */
  export type MEQS$sprArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SPR
     */
    select?: SPRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SPRInclude<ExtArgs> | null
    where?: SPRWhereInput
  }


  /**
   * MEQS.meqs_approvers
   */
  export type MEQS$meqs_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    where?: MEQSApproverWhereInput
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    cursor?: MEQSApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQS.meqs_suppliers
   */
  export type MEQS$meqs_suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    where?: MEQSSupplierWhereInput
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    cursor?: MEQSSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQS without action
   */
  export type MEQSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQS
     */
    select?: MEQSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSInclude<ExtArgs> | null
  }



  /**
   * Model MEQSSupplier
   */

  export type AggregateMEQSSupplier = {
    _count: MEQSSupplierCountAggregateOutputType | null
    _min: MEQSSupplierMinAggregateOutputType | null
    _max: MEQSSupplierMaxAggregateOutputType | null
  }

  export type MEQSSupplierMinAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    supplier_id: string | null
    payment_terms: string | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSSupplierMaxAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    supplier_id: string | null
    payment_terms: string | null
    is_referenced: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSSupplierCountAggregateOutputType = {
    id: number
    meqs_id: number
    supplier_id: number
    payment_terms: number
    is_referenced: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type MEQSSupplierMinAggregateInputType = {
    id?: true
    meqs_id?: true
    supplier_id?: true
    payment_terms?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSSupplierMaxAggregateInputType = {
    id?: true
    meqs_id?: true
    supplier_id?: true
    payment_terms?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSSupplierCountAggregateInputType = {
    id?: true
    meqs_id?: true
    supplier_id?: true
    payment_terms?: true
    is_referenced?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type MEQSSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplier to aggregate.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSSuppliers
    **/
    _count?: true | MEQSSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSSupplierMaxAggregateInputType
  }

  export type GetMEQSSupplierAggregateType<T extends MEQSSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSSupplier[P]>
      : GetScalarType<T[P], AggregateMEQSSupplier[P]>
  }




  export type MEQSSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierWhereInput
    orderBy?: MEQSSupplierOrderByWithAggregationInput | MEQSSupplierOrderByWithAggregationInput[]
    by: MEQSSupplierScalarFieldEnum[] | MEQSSupplierScalarFieldEnum
    having?: MEQSSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSSupplierCountAggregateInputType | true
    _min?: MEQSSupplierMinAggregateInputType
    _max?: MEQSSupplierMaxAggregateInputType
  }

  export type MEQSSupplierGroupByOutputType = {
    id: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    is_referenced: boolean
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: MEQSSupplierCountAggregateOutputType | null
    _min: MEQSSupplierMinAggregateOutputType | null
    _max: MEQSSupplierMaxAggregateOutputType | null
  }

  type GetMEQSSupplierGroupByPayload<T extends MEQSSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSSupplierGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_id?: boolean
    supplier_id?: boolean
    payment_terms?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    attachments?: boolean | MEQSSupplier$attachmentsArgs<ExtArgs>
    meqs_supplier_items?: boolean | MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs>
    po?: boolean | MEQSSupplier$poArgs<ExtArgs>
    _count?: boolean | MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSSupplier"]>

  export type MEQSSupplierSelectScalar = {
    id?: boolean
    meqs_id?: boolean
    supplier_id?: boolean
    payment_terms?: boolean
    is_referenced?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type MEQSSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    attachments?: boolean | MEQSSupplier$attachmentsArgs<ExtArgs>
    meqs_supplier_items?: boolean | MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs>
    po?: boolean | MEQSSupplier$poArgs<ExtArgs>
    _count?: boolean | MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MEQSSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSSupplier"
    objects: {
      meqs: Prisma.$MEQSPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      attachments: Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>[]
      meqs_supplier_items: Prisma.$MEQSSupplierItemPayload<ExtArgs>[]
      po: Prisma.$POPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_id: string
      supplier_id: string
      payment_terms: string
      is_referenced: boolean
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["mEQSSupplier"]>
    composites: {}
  }


  type MEQSSupplierGetPayload<S extends boolean | null | undefined | MEQSSupplierDefaultArgs> = $Result.GetResult<Prisma.$MEQSSupplierPayload, S>

  type MEQSSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSSupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSSupplierCountAggregateInputType | true
    }

  export interface MEQSSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSSupplier'], meta: { name: 'MEQSSupplier' } }
    /**
     * Find zero or one MEQSSupplier that matches the filter.
     * @param {MEQSSupplierFindUniqueArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSSupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSSupplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSSupplierFindUniqueOrThrowArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSSupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierFindFirstArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSSupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierFindFirstOrThrowArgs} args - Arguments to find a MEQSSupplier
     * @example
     * // Get one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSSupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSSuppliers
     * const mEQSSuppliers = await prisma.mEQSSupplier.findMany()
     * 
     * // Get first 10 MEQSSuppliers
     * const mEQSSuppliers = await prisma.mEQSSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSSupplierWithIdOnly = await prisma.mEQSSupplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSSupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSSupplier.
     * @param {MEQSSupplierCreateArgs} args - Arguments to create a MEQSSupplier.
     * @example
     * // Create one MEQSSupplier
     * const MEQSSupplier = await prisma.mEQSSupplier.create({
     *   data: {
     *     // ... data to create a MEQSSupplier
     *   }
     * })
     * 
    **/
    create<T extends MEQSSupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierCreateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSSuppliers.
     *     @param {MEQSSupplierCreateManyArgs} args - Arguments to create many MEQSSuppliers.
     *     @example
     *     // Create many MEQSSuppliers
     *     const mEQSSupplier = await prisma.mEQSSupplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSSupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSSupplier.
     * @param {MEQSSupplierDeleteArgs} args - Arguments to delete one MEQSSupplier.
     * @example
     * // Delete one MEQSSupplier
     * const MEQSSupplier = await prisma.mEQSSupplier.delete({
     *   where: {
     *     // ... filter to delete one MEQSSupplier
     *   }
     * })
     * 
    **/
    delete<T extends MEQSSupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierDeleteArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSSupplier.
     * @param {MEQSSupplierUpdateArgs} args - Arguments to update one MEQSSupplier.
     * @example
     * // Update one MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSSupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierUpdateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSSuppliers.
     * @param {MEQSSupplierDeleteManyArgs} args - Arguments to filter MEQSSuppliers to delete.
     * @example
     * // Delete a few MEQSSuppliers
     * const { count } = await prisma.mEQSSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSSupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSSuppliers
     * const mEQSSupplier = await prisma.mEQSSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSSupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSSupplier.
     * @param {MEQSSupplierUpsertArgs} args - Arguments to update or create a MEQSSupplier.
     * @example
     * // Update or create a MEQSSupplier
     * const mEQSSupplier = await prisma.mEQSSupplier.upsert({
     *   create: {
     *     // ... data to create a MEQSSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSSupplier we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSSupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierUpsertArgs<ExtArgs>>
    ): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierCountArgs} args - Arguments to filter MEQSSuppliers to count.
     * @example
     * // Count the number of MEQSSuppliers
     * const count = await prisma.mEQSSupplier.count({
     *   where: {
     *     // ... the filter for the MEQSSuppliers we want to count
     *   }
     * })
    **/
    count<T extends MEQSSupplierCountArgs>(
      args?: Subset<T, MEQSSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSSupplierAggregateArgs>(args: Subset<T, MEQSSupplierAggregateArgs>): Prisma.PrismaPromise<GetMEQSSupplierAggregateType<T>>

    /**
     * Group by MEQSSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSSupplierGroupByArgs['orderBy'] }
        : { orderBy?: MEQSSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSSupplier model
   */
  readonly fields: MEQSSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs<T extends MEQSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSDefaultArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    attachments<T extends MEQSSupplier$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplier$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    meqs_supplier_items<T extends MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    po<T extends MEQSSupplier$poArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplier$poArgs<ExtArgs>>): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSSupplier model
   */ 
  interface MEQSSupplierFieldRefs {
    readonly id: FieldRef<"MEQSSupplier", 'String'>
    readonly meqs_id: FieldRef<"MEQSSupplier", 'String'>
    readonly supplier_id: FieldRef<"MEQSSupplier", 'String'>
    readonly payment_terms: FieldRef<"MEQSSupplier", 'String'>
    readonly is_referenced: FieldRef<"MEQSSupplier", 'Boolean'>
    readonly created_at: FieldRef<"MEQSSupplier", 'DateTime'>
    readonly updated_at: FieldRef<"MEQSSupplier", 'DateTime'>
    readonly is_deleted: FieldRef<"MEQSSupplier", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * MEQSSupplier findUnique
   */
  export type MEQSSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier findUniqueOrThrow
   */
  export type MEQSSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier findFirst
   */
  export type MEQSSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSuppliers.
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSuppliers.
     */
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQSSupplier findFirstOrThrow
   */
  export type MEQSSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplier to fetch.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSuppliers.
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSuppliers.
     */
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQSSupplier findMany
   */
  export type MEQSSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSuppliers to fetch.
     */
    where?: MEQSSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSuppliers to fetch.
     */
    orderBy?: MEQSSupplierOrderByWithRelationInput | MEQSSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSSuppliers.
     */
    cursor?: MEQSSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSuppliers.
     */
    skip?: number
    distinct?: MEQSSupplierScalarFieldEnum | MEQSSupplierScalarFieldEnum[]
  }


  /**
   * MEQSSupplier create
   */
  export type MEQSSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSSupplier.
     */
    data: XOR<MEQSSupplierCreateInput, MEQSSupplierUncheckedCreateInput>
  }


  /**
   * MEQSSupplier createMany
   */
  export type MEQSSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSSuppliers.
     */
    data: MEQSSupplierCreateManyInput | MEQSSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSSupplier update
   */
  export type MEQSSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSSupplier.
     */
    data: XOR<MEQSSupplierUpdateInput, MEQSSupplierUncheckedUpdateInput>
    /**
     * Choose, which MEQSSupplier to update.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier updateMany
   */
  export type MEQSSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSSuppliers.
     */
    data: XOR<MEQSSupplierUpdateManyMutationInput, MEQSSupplierUncheckedUpdateManyInput>
    /**
     * Filter which MEQSSuppliers to update
     */
    where?: MEQSSupplierWhereInput
  }


  /**
   * MEQSSupplier upsert
   */
  export type MEQSSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSSupplier to update in case it exists.
     */
    where: MEQSSupplierWhereUniqueInput
    /**
     * In case the MEQSSupplier found by the `where` argument doesn't exist, create a new MEQSSupplier with this data.
     */
    create: XOR<MEQSSupplierCreateInput, MEQSSupplierUncheckedCreateInput>
    /**
     * In case the MEQSSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSSupplierUpdateInput, MEQSSupplierUncheckedUpdateInput>
  }


  /**
   * MEQSSupplier delete
   */
  export type MEQSSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
    /**
     * Filter which MEQSSupplier to delete.
     */
    where: MEQSSupplierWhereUniqueInput
  }


  /**
   * MEQSSupplier deleteMany
   */
  export type MEQSSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSuppliers to delete
     */
    where?: MEQSSupplierWhereInput
  }


  /**
   * MEQSSupplier.attachments
   */
  export type MEQSSupplier$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    where?: MEQSSupplierAttachmentWhereInput
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplier.meqs_supplier_items
   */
  export type MEQSSupplier$meqs_supplier_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    where?: MEQSSupplierItemWhereInput
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    cursor?: MEQSSupplierItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplier.po
   */
  export type MEQSSupplier$poArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    where?: POWhereInput
  }


  /**
   * MEQSSupplier without action
   */
  export type MEQSSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplier
     */
    select?: MEQSSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierInclude<ExtArgs> | null
  }



  /**
   * Model MEQSSupplierItem
   */

  export type AggregateMEQSSupplierItem = {
    _count: MEQSSupplierItemCountAggregateOutputType | null
    _avg: MEQSSupplierItemAvgAggregateOutputType | null
    _sum: MEQSSupplierItemSumAggregateOutputType | null
    _min: MEQSSupplierItemMinAggregateOutputType | null
    _max: MEQSSupplierItemMaxAggregateOutputType | null
  }

  export type MEQSSupplierItemAvgAggregateOutputType = {
    price: number | null
    vat_type: number | null
  }

  export type MEQSSupplierItemSumAggregateOutputType = {
    price: number | null
    vat_type: number | null
  }

  export type MEQSSupplierItemMinAggregateOutputType = {
    id: string | null
    canvass_item_id: string | null
    meqs_supplier_id: string | null
    price: number | null
    is_awarded: boolean | null
    notes: string | null
    vat_type: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSSupplierItemMaxAggregateOutputType = {
    id: string | null
    canvass_item_id: string | null
    meqs_supplier_id: string | null
    price: number | null
    is_awarded: boolean | null
    notes: string | null
    vat_type: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSSupplierItemCountAggregateOutputType = {
    id: number
    canvass_item_id: number
    meqs_supplier_id: number
    price: number
    is_awarded: number
    notes: number
    vat_type: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type MEQSSupplierItemAvgAggregateInputType = {
    price?: true
    vat_type?: true
  }

  export type MEQSSupplierItemSumAggregateInputType = {
    price?: true
    vat_type?: true
  }

  export type MEQSSupplierItemMinAggregateInputType = {
    id?: true
    canvass_item_id?: true
    meqs_supplier_id?: true
    price?: true
    is_awarded?: true
    notes?: true
    vat_type?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSSupplierItemMaxAggregateInputType = {
    id?: true
    canvass_item_id?: true
    meqs_supplier_id?: true
    price?: true
    is_awarded?: true
    notes?: true
    vat_type?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSSupplierItemCountAggregateInputType = {
    id?: true
    canvass_item_id?: true
    meqs_supplier_id?: true
    price?: true
    is_awarded?: true
    notes?: true
    vat_type?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type MEQSSupplierItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierItem to aggregate.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSSupplierItems
    **/
    _count?: true | MEQSSupplierItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MEQSSupplierItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MEQSSupplierItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSSupplierItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSSupplierItemMaxAggregateInputType
  }

  export type GetMEQSSupplierItemAggregateType<T extends MEQSSupplierItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSSupplierItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSSupplierItem[P]>
      : GetScalarType<T[P], AggregateMEQSSupplierItem[P]>
  }




  export type MEQSSupplierItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierItemWhereInput
    orderBy?: MEQSSupplierItemOrderByWithAggregationInput | MEQSSupplierItemOrderByWithAggregationInput[]
    by: MEQSSupplierItemScalarFieldEnum[] | MEQSSupplierItemScalarFieldEnum
    having?: MEQSSupplierItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSSupplierItemCountAggregateInputType | true
    _avg?: MEQSSupplierItemAvgAggregateInputType
    _sum?: MEQSSupplierItemSumAggregateInputType
    _min?: MEQSSupplierItemMinAggregateInputType
    _max?: MEQSSupplierItemMaxAggregateInputType
  }

  export type MEQSSupplierItemGroupByOutputType = {
    id: string
    canvass_item_id: string
    meqs_supplier_id: string
    price: number
    is_awarded: boolean
    notes: string | null
    vat_type: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: MEQSSupplierItemCountAggregateOutputType | null
    _avg: MEQSSupplierItemAvgAggregateOutputType | null
    _sum: MEQSSupplierItemSumAggregateOutputType | null
    _min: MEQSSupplierItemMinAggregateOutputType | null
    _max: MEQSSupplierItemMaxAggregateOutputType | null
  }

  type GetMEQSSupplierItemGroupByPayload<T extends MEQSSupplierItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSSupplierItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSSupplierItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSSupplierItemGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSSupplierItemGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSupplierItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvass_item_id?: boolean
    meqs_supplier_id?: boolean
    price?: boolean
    is_awarded?: boolean
    notes?: boolean
    vat_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    canvass_item?: boolean | CanvassItemDefaultArgs<ExtArgs>
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSSupplierItem"]>

  export type MEQSSupplierItemSelectScalar = {
    id?: boolean
    canvass_item_id?: boolean
    meqs_supplier_id?: boolean
    price?: boolean
    is_awarded?: boolean
    notes?: boolean
    vat_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type MEQSSupplierItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvass_item?: boolean | CanvassItemDefaultArgs<ExtArgs>
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
  }


  export type $MEQSSupplierItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSSupplierItem"
    objects: {
      canvass_item: Prisma.$CanvassItemPayload<ExtArgs>
      meqs_supplier: Prisma.$MEQSSupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      canvass_item_id: string
      meqs_supplier_id: string
      price: number
      is_awarded: boolean
      notes: string | null
      vat_type: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["mEQSSupplierItem"]>
    composites: {}
  }


  type MEQSSupplierItemGetPayload<S extends boolean | null | undefined | MEQSSupplierItemDefaultArgs> = $Result.GetResult<Prisma.$MEQSSupplierItemPayload, S>

  type MEQSSupplierItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSSupplierItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSSupplierItemCountAggregateInputType | true
    }

  export interface MEQSSupplierItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSSupplierItem'], meta: { name: 'MEQSSupplierItem' } }
    /**
     * Find zero or one MEQSSupplierItem that matches the filter.
     * @param {MEQSSupplierItemFindUniqueArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSSupplierItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSSupplierItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSSupplierItemFindUniqueOrThrowArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSSupplierItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemFindFirstArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSSupplierItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSSupplierItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemFindFirstOrThrowArgs} args - Arguments to find a MEQSSupplierItem
     * @example
     * // Get one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSSupplierItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSSupplierItems
     * const mEQSSupplierItems = await prisma.mEQSSupplierItem.findMany()
     * 
     * // Get first 10 MEQSSupplierItems
     * const mEQSSupplierItems = await prisma.mEQSSupplierItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSSupplierItemWithIdOnly = await prisma.mEQSSupplierItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSSupplierItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSSupplierItem.
     * @param {MEQSSupplierItemCreateArgs} args - Arguments to create a MEQSSupplierItem.
     * @example
     * // Create one MEQSSupplierItem
     * const MEQSSupplierItem = await prisma.mEQSSupplierItem.create({
     *   data: {
     *     // ... data to create a MEQSSupplierItem
     *   }
     * })
     * 
    **/
    create<T extends MEQSSupplierItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemCreateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSSupplierItems.
     *     @param {MEQSSupplierItemCreateManyArgs} args - Arguments to create many MEQSSupplierItems.
     *     @example
     *     // Create many MEQSSupplierItems
     *     const mEQSSupplierItem = await prisma.mEQSSupplierItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSSupplierItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSSupplierItem.
     * @param {MEQSSupplierItemDeleteArgs} args - Arguments to delete one MEQSSupplierItem.
     * @example
     * // Delete one MEQSSupplierItem
     * const MEQSSupplierItem = await prisma.mEQSSupplierItem.delete({
     *   where: {
     *     // ... filter to delete one MEQSSupplierItem
     *   }
     * })
     * 
    **/
    delete<T extends MEQSSupplierItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemDeleteArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSSupplierItem.
     * @param {MEQSSupplierItemUpdateArgs} args - Arguments to update one MEQSSupplierItem.
     * @example
     * // Update one MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSSupplierItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemUpdateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSSupplierItems.
     * @param {MEQSSupplierItemDeleteManyArgs} args - Arguments to filter MEQSSupplierItems to delete.
     * @example
     * // Delete a few MEQSSupplierItems
     * const { count } = await prisma.mEQSSupplierItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSSupplierItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSSupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSSupplierItems
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSSupplierItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSSupplierItem.
     * @param {MEQSSupplierItemUpsertArgs} args - Arguments to update or create a MEQSSupplierItem.
     * @example
     * // Update or create a MEQSSupplierItem
     * const mEQSSupplierItem = await prisma.mEQSSupplierItem.upsert({
     *   create: {
     *     // ... data to create a MEQSSupplierItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSSupplierItem we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSSupplierItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierItemUpsertArgs<ExtArgs>>
    ): Prisma__MEQSSupplierItemClient<$Result.GetResult<Prisma.$MEQSSupplierItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSSupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemCountArgs} args - Arguments to filter MEQSSupplierItems to count.
     * @example
     * // Count the number of MEQSSupplierItems
     * const count = await prisma.mEQSSupplierItem.count({
     *   where: {
     *     // ... the filter for the MEQSSupplierItems we want to count
     *   }
     * })
    **/
    count<T extends MEQSSupplierItemCountArgs>(
      args?: Subset<T, MEQSSupplierItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSSupplierItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSSupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSSupplierItemAggregateArgs>(args: Subset<T, MEQSSupplierItemAggregateArgs>): Prisma.PrismaPromise<GetMEQSSupplierItemAggregateType<T>>

    /**
     * Group by MEQSSupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSSupplierItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSSupplierItemGroupByArgs['orderBy'] }
        : { orderBy?: MEQSSupplierItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSSupplierItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSSupplierItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSSupplierItem model
   */
  readonly fields: MEQSSupplierItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSSupplierItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSSupplierItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    canvass_item<T extends CanvassItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvassItemDefaultArgs<ExtArgs>>): Prisma__CanvassItemClient<$Result.GetResult<Prisma.$CanvassItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    meqs_supplier<T extends MEQSSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplierDefaultArgs<ExtArgs>>): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSSupplierItem model
   */ 
  interface MEQSSupplierItemFieldRefs {
    readonly id: FieldRef<"MEQSSupplierItem", 'String'>
    readonly canvass_item_id: FieldRef<"MEQSSupplierItem", 'String'>
    readonly meqs_supplier_id: FieldRef<"MEQSSupplierItem", 'String'>
    readonly price: FieldRef<"MEQSSupplierItem", 'Float'>
    readonly is_awarded: FieldRef<"MEQSSupplierItem", 'Boolean'>
    readonly notes: FieldRef<"MEQSSupplierItem", 'String'>
    readonly vat_type: FieldRef<"MEQSSupplierItem", 'Int'>
    readonly created_at: FieldRef<"MEQSSupplierItem", 'DateTime'>
    readonly updated_at: FieldRef<"MEQSSupplierItem", 'DateTime'>
    readonly is_deleted: FieldRef<"MEQSSupplierItem", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * MEQSSupplierItem findUnique
   */
  export type MEQSSupplierItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem findUniqueOrThrow
   */
  export type MEQSSupplierItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem findFirst
   */
  export type MEQSSupplierItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierItems.
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierItems.
     */
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplierItem findFirstOrThrow
   */
  export type MEQSSupplierItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItem to fetch.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierItems.
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierItems.
     */
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplierItem findMany
   */
  export type MEQSSupplierItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierItems to fetch.
     */
    where?: MEQSSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierItems to fetch.
     */
    orderBy?: MEQSSupplierItemOrderByWithRelationInput | MEQSSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSSupplierItems.
     */
    cursor?: MEQSSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierItems.
     */
    skip?: number
    distinct?: MEQSSupplierItemScalarFieldEnum | MEQSSupplierItemScalarFieldEnum[]
  }


  /**
   * MEQSSupplierItem create
   */
  export type MEQSSupplierItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSSupplierItem.
     */
    data: XOR<MEQSSupplierItemCreateInput, MEQSSupplierItemUncheckedCreateInput>
  }


  /**
   * MEQSSupplierItem createMany
   */
  export type MEQSSupplierItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSSupplierItems.
     */
    data: MEQSSupplierItemCreateManyInput | MEQSSupplierItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSSupplierItem update
   */
  export type MEQSSupplierItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSSupplierItem.
     */
    data: XOR<MEQSSupplierItemUpdateInput, MEQSSupplierItemUncheckedUpdateInput>
    /**
     * Choose, which MEQSSupplierItem to update.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem updateMany
   */
  export type MEQSSupplierItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSSupplierItems.
     */
    data: XOR<MEQSSupplierItemUpdateManyMutationInput, MEQSSupplierItemUncheckedUpdateManyInput>
    /**
     * Filter which MEQSSupplierItems to update
     */
    where?: MEQSSupplierItemWhereInput
  }


  /**
   * MEQSSupplierItem upsert
   */
  export type MEQSSupplierItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSSupplierItem to update in case it exists.
     */
    where: MEQSSupplierItemWhereUniqueInput
    /**
     * In case the MEQSSupplierItem found by the `where` argument doesn't exist, create a new MEQSSupplierItem with this data.
     */
    create: XOR<MEQSSupplierItemCreateInput, MEQSSupplierItemUncheckedCreateInput>
    /**
     * In case the MEQSSupplierItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSSupplierItemUpdateInput, MEQSSupplierItemUncheckedUpdateInput>
  }


  /**
   * MEQSSupplierItem delete
   */
  export type MEQSSupplierItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
    /**
     * Filter which MEQSSupplierItem to delete.
     */
    where: MEQSSupplierItemWhereUniqueInput
  }


  /**
   * MEQSSupplierItem deleteMany
   */
  export type MEQSSupplierItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierItems to delete
     */
    where?: MEQSSupplierItemWhereInput
  }


  /**
   * MEQSSupplierItem without action
   */
  export type MEQSSupplierItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierItem
     */
    select?: MEQSSupplierItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierItemInclude<ExtArgs> | null
  }



  /**
   * Model MEQSSupplierAttachment
   */

  export type AggregateMEQSSupplierAttachment = {
    _count: MEQSSupplierAttachmentCountAggregateOutputType | null
    _min: MEQSSupplierAttachmentMinAggregateOutputType | null
    _max: MEQSSupplierAttachmentMaxAggregateOutputType | null
  }

  export type MEQSSupplierAttachmentMinAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    src: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSSupplierAttachmentMaxAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    src: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSSupplierAttachmentCountAggregateOutputType = {
    id: number
    meqs_supplier_id: number
    src: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type MEQSSupplierAttachmentMinAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    src?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSSupplierAttachmentMaxAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    src?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSSupplierAttachmentCountAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    src?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type MEQSSupplierAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierAttachment to aggregate.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSSupplierAttachments
    **/
    _count?: true | MEQSSupplierAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSSupplierAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSSupplierAttachmentMaxAggregateInputType
  }

  export type GetMEQSSupplierAttachmentAggregateType<T extends MEQSSupplierAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSSupplierAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSSupplierAttachment[P]>
      : GetScalarType<T[P], AggregateMEQSSupplierAttachment[P]>
  }




  export type MEQSSupplierAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSSupplierAttachmentWhereInput
    orderBy?: MEQSSupplierAttachmentOrderByWithAggregationInput | MEQSSupplierAttachmentOrderByWithAggregationInput[]
    by: MEQSSupplierAttachmentScalarFieldEnum[] | MEQSSupplierAttachmentScalarFieldEnum
    having?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSSupplierAttachmentCountAggregateInputType | true
    _min?: MEQSSupplierAttachmentMinAggregateInputType
    _max?: MEQSSupplierAttachmentMaxAggregateInputType
  }

  export type MEQSSupplierAttachmentGroupByOutputType = {
    id: string
    meqs_supplier_id: string
    src: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: MEQSSupplierAttachmentCountAggregateOutputType | null
    _min: MEQSSupplierAttachmentMinAggregateOutputType | null
    _max: MEQSSupplierAttachmentMaxAggregateOutputType | null
  }

  type GetMEQSSupplierAttachmentGroupByPayload<T extends MEQSSupplierAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSSupplierAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSSupplierAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSSupplierAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSSupplierAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MEQSSupplierAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_supplier_id?: boolean
    src?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSSupplierAttachment"]>

  export type MEQSSupplierAttachmentSelectScalar = {
    id?: boolean
    meqs_supplier_id?: boolean
    src?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type MEQSSupplierAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
  }


  export type $MEQSSupplierAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSSupplierAttachment"
    objects: {
      meqs_supplier: Prisma.$MEQSSupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_supplier_id: string
      src: string
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["mEQSSupplierAttachment"]>
    composites: {}
  }


  type MEQSSupplierAttachmentGetPayload<S extends boolean | null | undefined | MEQSSupplierAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload, S>

  type MEQSSupplierAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSSupplierAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSSupplierAttachmentCountAggregateInputType | true
    }

  export interface MEQSSupplierAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSSupplierAttachment'], meta: { name: 'MEQSSupplierAttachment' } }
    /**
     * Find zero or one MEQSSupplierAttachment that matches the filter.
     * @param {MEQSSupplierAttachmentFindUniqueArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSSupplierAttachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSSupplierAttachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSSupplierAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSSupplierAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentFindFirstArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSSupplierAttachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSSupplierAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentFindFirstOrThrowArgs} args - Arguments to find a MEQSSupplierAttachment
     * @example
     * // Get one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSSupplierAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSSupplierAttachments
     * const mEQSSupplierAttachments = await prisma.mEQSSupplierAttachment.findMany()
     * 
     * // Get first 10 MEQSSupplierAttachments
     * const mEQSSupplierAttachments = await prisma.mEQSSupplierAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSSupplierAttachmentWithIdOnly = await prisma.mEQSSupplierAttachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSSupplierAttachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentCreateArgs} args - Arguments to create a MEQSSupplierAttachment.
     * @example
     * // Create one MEQSSupplierAttachment
     * const MEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.create({
     *   data: {
     *     // ... data to create a MEQSSupplierAttachment
     *   }
     * })
     * 
    **/
    create<T extends MEQSSupplierAttachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentCreateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSSupplierAttachments.
     *     @param {MEQSSupplierAttachmentCreateManyArgs} args - Arguments to create many MEQSSupplierAttachments.
     *     @example
     *     // Create many MEQSSupplierAttachments
     *     const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSSupplierAttachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentDeleteArgs} args - Arguments to delete one MEQSSupplierAttachment.
     * @example
     * // Delete one MEQSSupplierAttachment
     * const MEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.delete({
     *   where: {
     *     // ... filter to delete one MEQSSupplierAttachment
     *   }
     * })
     * 
    **/
    delete<T extends MEQSSupplierAttachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentDeleteArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentUpdateArgs} args - Arguments to update one MEQSSupplierAttachment.
     * @example
     * // Update one MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSSupplierAttachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentUpdateArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSSupplierAttachments.
     * @param {MEQSSupplierAttachmentDeleteManyArgs} args - Arguments to filter MEQSSupplierAttachments to delete.
     * @example
     * // Delete a few MEQSSupplierAttachments
     * const { count } = await prisma.mEQSSupplierAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSSupplierAttachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSSupplierAttachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSSupplierAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSSupplierAttachments
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSSupplierAttachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSSupplierAttachment.
     * @param {MEQSSupplierAttachmentUpsertArgs} args - Arguments to update or create a MEQSSupplierAttachment.
     * @example
     * // Update or create a MEQSSupplierAttachment
     * const mEQSSupplierAttachment = await prisma.mEQSSupplierAttachment.upsert({
     *   create: {
     *     // ... data to create a MEQSSupplierAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSSupplierAttachment we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSSupplierAttachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSSupplierAttachmentUpsertArgs<ExtArgs>>
    ): Prisma__MEQSSupplierAttachmentClient<$Result.GetResult<Prisma.$MEQSSupplierAttachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSSupplierAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentCountArgs} args - Arguments to filter MEQSSupplierAttachments to count.
     * @example
     * // Count the number of MEQSSupplierAttachments
     * const count = await prisma.mEQSSupplierAttachment.count({
     *   where: {
     *     // ... the filter for the MEQSSupplierAttachments we want to count
     *   }
     * })
    **/
    count<T extends MEQSSupplierAttachmentCountArgs>(
      args?: Subset<T, MEQSSupplierAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSSupplierAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSSupplierAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSSupplierAttachmentAggregateArgs>(args: Subset<T, MEQSSupplierAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMEQSSupplierAttachmentAggregateType<T>>

    /**
     * Group by MEQSSupplierAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSSupplierAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSSupplierAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSSupplierAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MEQSSupplierAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSSupplierAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSSupplierAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSSupplierAttachment model
   */
  readonly fields: MEQSSupplierAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSSupplierAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSSupplierAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs_supplier<T extends MEQSSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplierDefaultArgs<ExtArgs>>): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSSupplierAttachment model
   */ 
  interface MEQSSupplierAttachmentFieldRefs {
    readonly id: FieldRef<"MEQSSupplierAttachment", 'String'>
    readonly meqs_supplier_id: FieldRef<"MEQSSupplierAttachment", 'String'>
    readonly src: FieldRef<"MEQSSupplierAttachment", 'String'>
    readonly created_at: FieldRef<"MEQSSupplierAttachment", 'DateTime'>
    readonly updated_at: FieldRef<"MEQSSupplierAttachment", 'DateTime'>
    readonly is_deleted: FieldRef<"MEQSSupplierAttachment", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * MEQSSupplierAttachment findUnique
   */
  export type MEQSSupplierAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment findUniqueOrThrow
   */
  export type MEQSSupplierAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment findFirst
   */
  export type MEQSSupplierAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierAttachments.
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierAttachments.
     */
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplierAttachment findFirstOrThrow
   */
  export type MEQSSupplierAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachment to fetch.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSSupplierAttachments.
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSSupplierAttachments.
     */
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplierAttachment findMany
   */
  export type MEQSSupplierAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MEQSSupplierAttachments to fetch.
     */
    where?: MEQSSupplierAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSSupplierAttachments to fetch.
     */
    orderBy?: MEQSSupplierAttachmentOrderByWithRelationInput | MEQSSupplierAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSSupplierAttachments.
     */
    cursor?: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSSupplierAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSSupplierAttachments.
     */
    skip?: number
    distinct?: MEQSSupplierAttachmentScalarFieldEnum | MEQSSupplierAttachmentScalarFieldEnum[]
  }


  /**
   * MEQSSupplierAttachment create
   */
  export type MEQSSupplierAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSSupplierAttachment.
     */
    data: XOR<MEQSSupplierAttachmentCreateInput, MEQSSupplierAttachmentUncheckedCreateInput>
  }


  /**
   * MEQSSupplierAttachment createMany
   */
  export type MEQSSupplierAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSSupplierAttachments.
     */
    data: MEQSSupplierAttachmentCreateManyInput | MEQSSupplierAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSSupplierAttachment update
   */
  export type MEQSSupplierAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSSupplierAttachment.
     */
    data: XOR<MEQSSupplierAttachmentUpdateInput, MEQSSupplierAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MEQSSupplierAttachment to update.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment updateMany
   */
  export type MEQSSupplierAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSSupplierAttachments.
     */
    data: XOR<MEQSSupplierAttachmentUpdateManyMutationInput, MEQSSupplierAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MEQSSupplierAttachments to update
     */
    where?: MEQSSupplierAttachmentWhereInput
  }


  /**
   * MEQSSupplierAttachment upsert
   */
  export type MEQSSupplierAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSSupplierAttachment to update in case it exists.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
    /**
     * In case the MEQSSupplierAttachment found by the `where` argument doesn't exist, create a new MEQSSupplierAttachment with this data.
     */
    create: XOR<MEQSSupplierAttachmentCreateInput, MEQSSupplierAttachmentUncheckedCreateInput>
    /**
     * In case the MEQSSupplierAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSSupplierAttachmentUpdateInput, MEQSSupplierAttachmentUncheckedUpdateInput>
  }


  /**
   * MEQSSupplierAttachment delete
   */
  export type MEQSSupplierAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MEQSSupplierAttachment to delete.
     */
    where: MEQSSupplierAttachmentWhereUniqueInput
  }


  /**
   * MEQSSupplierAttachment deleteMany
   */
  export type MEQSSupplierAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSSupplierAttachments to delete
     */
    where?: MEQSSupplierAttachmentWhereInput
  }


  /**
   * MEQSSupplierAttachment without action
   */
  export type MEQSSupplierAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSSupplierAttachment
     */
    select?: MEQSSupplierAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSSupplierAttachmentInclude<ExtArgs> | null
  }



  /**
   * Model MEQSApprover
   */

  export type AggregateMEQSApprover = {
    _count: MEQSApproverCountAggregateOutputType | null
    _avg: MEQSApproverAvgAggregateOutputType | null
    _sum: MEQSApproverSumAggregateOutputType | null
    _min: MEQSApproverMinAggregateOutputType | null
    _max: MEQSApproverMaxAggregateOutputType | null
  }

  export type MEQSApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MEQSApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type MEQSApproverMinAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSApproverMaxAggregateOutputType = {
    id: string | null
    meqs_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type MEQSApproverCountAggregateOutputType = {
    id: number
    meqs_id: number
    approver_id: number
    approver_proxy_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type MEQSApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type MEQSApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type MEQSApproverMinAggregateInputType = {
    id?: true
    meqs_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSApproverMaxAggregateInputType = {
    id?: true
    meqs_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type MEQSApproverCountAggregateInputType = {
    id?: true
    meqs_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type MEQSApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSApprover to aggregate.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEQSApprovers
    **/
    _count?: true | MEQSApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MEQSApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MEQSApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEQSApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEQSApproverMaxAggregateInputType
  }

  export type GetMEQSApproverAggregateType<T extends MEQSApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateMEQSApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEQSApprover[P]>
      : GetScalarType<T[P], AggregateMEQSApprover[P]>
  }




  export type MEQSApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEQSApproverWhereInput
    orderBy?: MEQSApproverOrderByWithAggregationInput | MEQSApproverOrderByWithAggregationInput[]
    by: MEQSApproverScalarFieldEnum[] | MEQSApproverScalarFieldEnum
    having?: MEQSApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEQSApproverCountAggregateInputType | true
    _avg?: MEQSApproverAvgAggregateInputType
    _sum?: MEQSApproverSumAggregateInputType
    _min?: MEQSApproverMinAggregateInputType
    _max?: MEQSApproverMaxAggregateInputType
  }

  export type MEQSApproverGroupByOutputType = {
    id: string
    meqs_id: string
    approver_id: string
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number
    label: string
    order: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: MEQSApproverCountAggregateOutputType | null
    _avg: MEQSApproverAvgAggregateOutputType | null
    _sum: MEQSApproverSumAggregateOutputType | null
    _min: MEQSApproverMinAggregateOutputType | null
    _max: MEQSApproverMaxAggregateOutputType | null
  }

  type GetMEQSApproverGroupByPayload<T extends MEQSApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEQSApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEQSApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEQSApproverGroupByOutputType[P]>
            : GetScalarType<T[P], MEQSApproverGroupByOutputType[P]>
        }
      >
    >


  export type MEQSApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mEQSApprover"]>

  export type MEQSApproverSelectScalar = {
    id?: boolean
    meqs_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type MEQSApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meqs?: boolean | MEQSDefaultArgs<ExtArgs>
  }


  export type $MEQSApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEQSApprover"
    objects: {
      meqs: Prisma.$MEQSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_id: string
      approver_id: string
      approver_proxy_id: string | null
      date_approval: Date | null
      notes: string | null
      status: number
      label: string
      order: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["mEQSApprover"]>
    composites: {}
  }


  type MEQSApproverGetPayload<S extends boolean | null | undefined | MEQSApproverDefaultArgs> = $Result.GetResult<Prisma.$MEQSApproverPayload, S>

  type MEQSApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEQSApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MEQSApproverCountAggregateInputType | true
    }

  export interface MEQSApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEQSApprover'], meta: { name: 'MEQSApprover' } }
    /**
     * Find zero or one MEQSApprover that matches the filter.
     * @param {MEQSApproverFindUniqueArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEQSApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEQSApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEQSApproverFindUniqueOrThrowArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEQSApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEQSApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverFindFirstArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEQSApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindFirstArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEQSApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverFindFirstOrThrowArgs} args - Arguments to find a MEQSApprover
     * @example
     * // Get one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEQSApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEQSApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEQSApprovers
     * const mEQSApprovers = await prisma.mEQSApprover.findMany()
     * 
     * // Get first 10 MEQSApprovers
     * const mEQSApprovers = await prisma.mEQSApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mEQSApproverWithIdOnly = await prisma.mEQSApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MEQSApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEQSApprover.
     * @param {MEQSApproverCreateArgs} args - Arguments to create a MEQSApprover.
     * @example
     * // Create one MEQSApprover
     * const MEQSApprover = await prisma.mEQSApprover.create({
     *   data: {
     *     // ... data to create a MEQSApprover
     *   }
     * })
     * 
    **/
    create<T extends MEQSApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverCreateArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEQSApprovers.
     *     @param {MEQSApproverCreateManyArgs} args - Arguments to create many MEQSApprovers.
     *     @example
     *     // Create many MEQSApprovers
     *     const mEQSApprover = await prisma.mEQSApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEQSApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEQSApprover.
     * @param {MEQSApproverDeleteArgs} args - Arguments to delete one MEQSApprover.
     * @example
     * // Delete one MEQSApprover
     * const MEQSApprover = await prisma.mEQSApprover.delete({
     *   where: {
     *     // ... filter to delete one MEQSApprover
     *   }
     * })
     * 
    **/
    delete<T extends MEQSApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverDeleteArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEQSApprover.
     * @param {MEQSApproverUpdateArgs} args - Arguments to update one MEQSApprover.
     * @example
     * // Update one MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEQSApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverUpdateArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEQSApprovers.
     * @param {MEQSApproverDeleteManyArgs} args - Arguments to filter MEQSApprovers to delete.
     * @example
     * // Delete a few MEQSApprovers
     * const { count } = await prisma.mEQSApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEQSApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEQSApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEQSApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEQSApprovers
     * const mEQSApprover = await prisma.mEQSApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEQSApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEQSApprover.
     * @param {MEQSApproverUpsertArgs} args - Arguments to update or create a MEQSApprover.
     * @example
     * // Update or create a MEQSApprover
     * const mEQSApprover = await prisma.mEQSApprover.upsert({
     *   create: {
     *     // ... data to create a MEQSApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEQSApprover we want to update
     *   }
     * })
    **/
    upsert<T extends MEQSApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEQSApproverUpsertArgs<ExtArgs>>
    ): Prisma__MEQSApproverClient<$Result.GetResult<Prisma.$MEQSApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEQSApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverCountArgs} args - Arguments to filter MEQSApprovers to count.
     * @example
     * // Count the number of MEQSApprovers
     * const count = await prisma.mEQSApprover.count({
     *   where: {
     *     // ... the filter for the MEQSApprovers we want to count
     *   }
     * })
    **/
    count<T extends MEQSApproverCountArgs>(
      args?: Subset<T, MEQSApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEQSApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEQSApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEQSApproverAggregateArgs>(args: Subset<T, MEQSApproverAggregateArgs>): Prisma.PrismaPromise<GetMEQSApproverAggregateType<T>>

    /**
     * Group by MEQSApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEQSApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEQSApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEQSApproverGroupByArgs['orderBy'] }
        : { orderBy?: MEQSApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEQSApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEQSApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEQSApprover model
   */
  readonly fields: MEQSApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEQSApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEQSApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meqs<T extends MEQSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSDefaultArgs<ExtArgs>>): Prisma__MEQSClient<$Result.GetResult<Prisma.$MEQSPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEQSApprover model
   */ 
  interface MEQSApproverFieldRefs {
    readonly id: FieldRef<"MEQSApprover", 'String'>
    readonly meqs_id: FieldRef<"MEQSApprover", 'String'>
    readonly approver_id: FieldRef<"MEQSApprover", 'String'>
    readonly approver_proxy_id: FieldRef<"MEQSApprover", 'String'>
    readonly date_approval: FieldRef<"MEQSApprover", 'DateTime'>
    readonly notes: FieldRef<"MEQSApprover", 'String'>
    readonly status: FieldRef<"MEQSApprover", 'Int'>
    readonly label: FieldRef<"MEQSApprover", 'String'>
    readonly order: FieldRef<"MEQSApprover", 'Int'>
    readonly created_at: FieldRef<"MEQSApprover", 'DateTime'>
    readonly updated_at: FieldRef<"MEQSApprover", 'DateTime'>
    readonly is_deleted: FieldRef<"MEQSApprover", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * MEQSApprover findUnique
   */
  export type MEQSApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover findUniqueOrThrow
   */
  export type MEQSApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover findFirst
   */
  export type MEQSApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSApprovers.
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSApprovers.
     */
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQSApprover findFirstOrThrow
   */
  export type MEQSApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprover to fetch.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEQSApprovers.
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEQSApprovers.
     */
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQSApprover findMany
   */
  export type MEQSApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter, which MEQSApprovers to fetch.
     */
    where?: MEQSApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEQSApprovers to fetch.
     */
    orderBy?: MEQSApproverOrderByWithRelationInput | MEQSApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEQSApprovers.
     */
    cursor?: MEQSApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEQSApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEQSApprovers.
     */
    skip?: number
    distinct?: MEQSApproverScalarFieldEnum | MEQSApproverScalarFieldEnum[]
  }


  /**
   * MEQSApprover create
   */
  export type MEQSApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a MEQSApprover.
     */
    data: XOR<MEQSApproverCreateInput, MEQSApproverUncheckedCreateInput>
  }


  /**
   * MEQSApprover createMany
   */
  export type MEQSApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEQSApprovers.
     */
    data: MEQSApproverCreateManyInput | MEQSApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MEQSApprover update
   */
  export type MEQSApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a MEQSApprover.
     */
    data: XOR<MEQSApproverUpdateInput, MEQSApproverUncheckedUpdateInput>
    /**
     * Choose, which MEQSApprover to update.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover updateMany
   */
  export type MEQSApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEQSApprovers.
     */
    data: XOR<MEQSApproverUpdateManyMutationInput, MEQSApproverUncheckedUpdateManyInput>
    /**
     * Filter which MEQSApprovers to update
     */
    where?: MEQSApproverWhereInput
  }


  /**
   * MEQSApprover upsert
   */
  export type MEQSApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the MEQSApprover to update in case it exists.
     */
    where: MEQSApproverWhereUniqueInput
    /**
     * In case the MEQSApprover found by the `where` argument doesn't exist, create a new MEQSApprover with this data.
     */
    create: XOR<MEQSApproverCreateInput, MEQSApproverUncheckedCreateInput>
    /**
     * In case the MEQSApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEQSApproverUpdateInput, MEQSApproverUncheckedUpdateInput>
  }


  /**
   * MEQSApprover delete
   */
  export type MEQSApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
    /**
     * Filter which MEQSApprover to delete.
     */
    where: MEQSApproverWhereUniqueInput
  }


  /**
   * MEQSApprover deleteMany
   */
  export type MEQSApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEQSApprovers to delete
     */
    where?: MEQSApproverWhereInput
  }


  /**
   * MEQSApprover without action
   */
  export type MEQSApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEQSApprover
     */
    select?: MEQSApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MEQSApproverInclude<ExtArgs> | null
  }



  /**
   * Model PO
   */

  export type AggregatePO = {
    _count: POCountAggregateOutputType | null
    _avg: POAvgAggregateOutputType | null
    _sum: POSumAggregateOutputType | null
    _min: POMinAggregateOutputType | null
    _max: POMaxAggregateOutputType | null
  }

  export type POAvgAggregateOutputType = {
    status: number | null
  }

  export type POSumAggregateOutputType = {
    status: number | null
  }

  export type POMinAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    po_number: string | null
    po_date: Date | null
    status: number | null
    canceller_id: string | null
    date_cancelled: Date | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    is_referenced: boolean | null
  }

  export type POMaxAggregateOutputType = {
    id: string | null
    meqs_supplier_id: string | null
    po_number: string | null
    po_date: Date | null
    status: number | null
    canceller_id: string | null
    date_cancelled: Date | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    is_referenced: boolean | null
  }

  export type POCountAggregateOutputType = {
    id: number
    meqs_supplier_id: number
    po_number: number
    po_date: number
    status: number
    canceller_id: number
    date_cancelled: number
    created_at: number
    updated_at: number
    is_deleted: number
    is_referenced: number
    _all: number
  }


  export type POAvgAggregateInputType = {
    status?: true
  }

  export type POSumAggregateInputType = {
    status?: true
  }

  export type POMinAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    po_number?: true
    po_date?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    is_referenced?: true
  }

  export type POMaxAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    po_number?: true
    po_date?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    is_referenced?: true
  }

  export type POCountAggregateInputType = {
    id?: true
    meqs_supplier_id?: true
    po_number?: true
    po_date?: true
    status?: true
    canceller_id?: true
    date_cancelled?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    is_referenced?: true
    _all?: true
  }

  export type POAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PO to aggregate.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POS
    **/
    _count?: true | POCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POMaxAggregateInputType
  }

  export type GetPOAggregateType<T extends POAggregateArgs> = {
        [P in keyof T & keyof AggregatePO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePO[P]>
      : GetScalarType<T[P], AggregatePO[P]>
  }




  export type POGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POWhereInput
    orderBy?: POOrderByWithAggregationInput | POOrderByWithAggregationInput[]
    by: POScalarFieldEnum[] | POScalarFieldEnum
    having?: POScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POCountAggregateInputType | true
    _avg?: POAvgAggregateInputType
    _sum?: POSumAggregateInputType
    _min?: POMinAggregateInputType
    _max?: POMaxAggregateInputType
  }

  export type POGroupByOutputType = {
    id: string
    meqs_supplier_id: string
    po_number: string
    po_date: Date
    status: number
    canceller_id: string | null
    date_cancelled: Date | null
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    is_referenced: boolean
    _count: POCountAggregateOutputType | null
    _avg: POAvgAggregateOutputType | null
    _sum: POSumAggregateOutputType | null
    _min: POMinAggregateOutputType | null
    _max: POMaxAggregateOutputType | null
  }

  type GetPOGroupByPayload<T extends POGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POGroupByOutputType[P]>
            : GetScalarType<T[P], POGroupByOutputType[P]>
        }
      >
    >


  export type POSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meqs_supplier_id?: boolean
    po_number?: boolean
    po_date?: boolean
    status?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    is_referenced?: boolean
    po_approvers?: boolean | PO$po_approversArgs<ExtArgs>
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
    rr?: boolean | PO$rrArgs<ExtArgs>
    _count?: boolean | POCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pO"]>

  export type POSelectScalar = {
    id?: boolean
    meqs_supplier_id?: boolean
    po_number?: boolean
    po_date?: boolean
    status?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    is_referenced?: boolean
  }

  export type POInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po_approvers?: boolean | PO$po_approversArgs<ExtArgs>
    meqs_supplier?: boolean | MEQSSupplierDefaultArgs<ExtArgs>
    rr?: boolean | PO$rrArgs<ExtArgs>
    _count?: boolean | POCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $POPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PO"
    objects: {
      po_approvers: Prisma.$POApproverPayload<ExtArgs>[]
      meqs_supplier: Prisma.$MEQSSupplierPayload<ExtArgs>
      rr: Prisma.$RRPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meqs_supplier_id: string
      po_number: string
      po_date: Date
      status: number
      canceller_id: string | null
      date_cancelled: Date | null
      created_at: Date
      updated_at: Date
      is_deleted: boolean
      is_referenced: boolean
    }, ExtArgs["result"]["pO"]>
    composites: {}
  }


  type POGetPayload<S extends boolean | null | undefined | PODefaultArgs> = $Result.GetResult<Prisma.$POPayload, S>

  type POCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<POFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: POCountAggregateInputType | true
    }

  export interface PODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PO'], meta: { name: 'PO' } }
    /**
     * Find zero or one PO that matches the filter.
     * @param {POFindUniqueArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends POFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, POFindUniqueArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PO that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {POFindUniqueOrThrowArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends POFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindFirstArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends POFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindFirstArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindFirstOrThrowArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends POFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more POS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POS
     * const pOS = await prisma.pO.findMany()
     * 
     * // Get first 10 POS
     * const pOS = await prisma.pO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOWithIdOnly = await prisma.pO.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends POFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PO.
     * @param {POCreateArgs} args - Arguments to create a PO.
     * @example
     * // Create one PO
     * const PO = await prisma.pO.create({
     *   data: {
     *     // ... data to create a PO
     *   }
     * })
     * 
    **/
    create<T extends POCreateArgs<ExtArgs>>(
      args: SelectSubset<T, POCreateArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many POS.
     *     @param {POCreateManyArgs} args - Arguments to create many POS.
     *     @example
     *     // Create many POS
     *     const pO = await prisma.pO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends POCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PO.
     * @param {PODeleteArgs} args - Arguments to delete one PO.
     * @example
     * // Delete one PO
     * const PO = await prisma.pO.delete({
     *   where: {
     *     // ... filter to delete one PO
     *   }
     * })
     * 
    **/
    delete<T extends PODeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PODeleteArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PO.
     * @param {POUpdateArgs} args - Arguments to update one PO.
     * @example
     * // Update one PO
     * const pO = await prisma.pO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends POUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, POUpdateArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more POS.
     * @param {PODeleteManyArgs} args - Arguments to filter POS to delete.
     * @example
     * // Delete a few POS
     * const { count } = await prisma.pO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PODeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PODeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POS
     * const pO = await prisma.pO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends POUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, POUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PO.
     * @param {POUpsertArgs} args - Arguments to update or create a PO.
     * @example
     * // Update or create a PO
     * const pO = await prisma.pO.upsert({
     *   create: {
     *     // ... data to create a PO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PO we want to update
     *   }
     * })
    **/
    upsert<T extends POUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, POUpsertArgs<ExtArgs>>
    ): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POCountArgs} args - Arguments to filter POS to count.
     * @example
     * // Count the number of POS
     * const count = await prisma.pO.count({
     *   where: {
     *     // ... the filter for the POS we want to count
     *   }
     * })
    **/
    count<T extends POCountArgs>(
      args?: Subset<T, POCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POAggregateArgs>(args: Subset<T, POAggregateArgs>): Prisma.PrismaPromise<GetPOAggregateType<T>>

    /**
     * Group by PO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POGroupByArgs['orderBy'] }
        : { orderBy?: POGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PO model
   */
  readonly fields: POFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    po_approvers<T extends PO$po_approversArgs<ExtArgs> = {}>(args?: Subset<T, PO$po_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    meqs_supplier<T extends MEQSSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MEQSSupplierDefaultArgs<ExtArgs>>): Prisma__MEQSSupplierClient<$Result.GetResult<Prisma.$MEQSSupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rr<T extends PO$rrArgs<ExtArgs> = {}>(args?: Subset<T, PO$rrArgs<ExtArgs>>): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PO model
   */ 
  interface POFieldRefs {
    readonly id: FieldRef<"PO", 'String'>
    readonly meqs_supplier_id: FieldRef<"PO", 'String'>
    readonly po_number: FieldRef<"PO", 'String'>
    readonly po_date: FieldRef<"PO", 'DateTime'>
    readonly status: FieldRef<"PO", 'Int'>
    readonly canceller_id: FieldRef<"PO", 'String'>
    readonly date_cancelled: FieldRef<"PO", 'DateTime'>
    readonly created_at: FieldRef<"PO", 'DateTime'>
    readonly updated_at: FieldRef<"PO", 'DateTime'>
    readonly is_deleted: FieldRef<"PO", 'Boolean'>
    readonly is_referenced: FieldRef<"PO", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * PO findUnique
   */
  export type POFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO findUniqueOrThrow
   */
  export type POFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO findFirst
   */
  export type POFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POS.
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POS.
     */
    distinct?: POScalarFieldEnum | POScalarFieldEnum[]
  }


  /**
   * PO findFirstOrThrow
   */
  export type POFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which PO to fetch.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POS.
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POS.
     */
    distinct?: POScalarFieldEnum | POScalarFieldEnum[]
  }


  /**
   * PO findMany
   */
  export type POFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter, which POS to fetch.
     */
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POOrderByWithRelationInput | POOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POS.
     */
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    distinct?: POScalarFieldEnum | POScalarFieldEnum[]
  }


  /**
   * PO create
   */
  export type POCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * The data needed to create a PO.
     */
    data: XOR<POCreateInput, POUncheckedCreateInput>
  }


  /**
   * PO createMany
   */
  export type POCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POS.
     */
    data: POCreateManyInput | POCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PO update
   */
  export type POUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * The data needed to update a PO.
     */
    data: XOR<POUpdateInput, POUncheckedUpdateInput>
    /**
     * Choose, which PO to update.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO updateMany
   */
  export type POUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POS.
     */
    data: XOR<POUpdateManyMutationInput, POUncheckedUpdateManyInput>
    /**
     * Filter which POS to update
     */
    where?: POWhereInput
  }


  /**
   * PO upsert
   */
  export type POUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * The filter to search for the PO to update in case it exists.
     */
    where: POWhereUniqueInput
    /**
     * In case the PO found by the `where` argument doesn't exist, create a new PO with this data.
     */
    create: XOR<POCreateInput, POUncheckedCreateInput>
    /**
     * In case the PO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POUpdateInput, POUncheckedUpdateInput>
  }


  /**
   * PO delete
   */
  export type PODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
    /**
     * Filter which PO to delete.
     */
    where: POWhereUniqueInput
  }


  /**
   * PO deleteMany
   */
  export type PODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POS to delete
     */
    where?: POWhereInput
  }


  /**
   * PO.po_approvers
   */
  export type PO$po_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    where?: POApproverWhereInput
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    cursor?: POApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * PO.rr
   */
  export type PO$rrArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    where?: RRWhereInput
  }


  /**
   * PO without action
   */
  export type PODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PO
     */
    select?: POSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POInclude<ExtArgs> | null
  }



  /**
   * Model POApprover
   */

  export type AggregatePOApprover = {
    _count: POApproverCountAggregateOutputType | null
    _avg: POApproverAvgAggregateOutputType | null
    _sum: POApproverSumAggregateOutputType | null
    _min: POApproverMinAggregateOutputType | null
    _max: POApproverMaxAggregateOutputType | null
  }

  export type POApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type POApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type POApproverMinAggregateOutputType = {
    id: string | null
    po_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type POApproverMaxAggregateOutputType = {
    id: string | null
    po_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type POApproverCountAggregateOutputType = {
    id: number
    po_id: number
    approver_id: number
    approver_proxy_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type POApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type POApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type POApproverMinAggregateInputType = {
    id?: true
    po_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type POApproverMaxAggregateInputType = {
    id?: true
    po_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type POApproverCountAggregateInputType = {
    id?: true
    po_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type POApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POApprover to aggregate.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POApprovers
    **/
    _count?: true | POApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POApproverMaxAggregateInputType
  }

  export type GetPOApproverAggregateType<T extends POApproverAggregateArgs> = {
        [P in keyof T & keyof AggregatePOApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOApprover[P]>
      : GetScalarType<T[P], AggregatePOApprover[P]>
  }




  export type POApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POApproverWhereInput
    orderBy?: POApproverOrderByWithAggregationInput | POApproverOrderByWithAggregationInput[]
    by: POApproverScalarFieldEnum[] | POApproverScalarFieldEnum
    having?: POApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POApproverCountAggregateInputType | true
    _avg?: POApproverAvgAggregateInputType
    _sum?: POApproverSumAggregateInputType
    _min?: POApproverMinAggregateInputType
    _max?: POApproverMaxAggregateInputType
  }

  export type POApproverGroupByOutputType = {
    id: string
    po_id: string
    approver_id: string
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number
    label: string
    order: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: POApproverCountAggregateOutputType | null
    _avg: POApproverAvgAggregateOutputType | null
    _sum: POApproverSumAggregateOutputType | null
    _min: POApproverMinAggregateOutputType | null
    _max: POApproverMaxAggregateOutputType | null
  }

  type GetPOApproverGroupByPayload<T extends POApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POApproverGroupByOutputType[P]>
            : GetScalarType<T[P], POApproverGroupByOutputType[P]>
        }
      >
    >


  export type POApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    po?: boolean | PODefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOApprover"]>

  export type POApproverSelectScalar = {
    id?: boolean
    po_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type POApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PODefaultArgs<ExtArgs>
  }


  export type $POApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POApprover"
    objects: {
      po: Prisma.$POPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      po_id: string
      approver_id: string
      approver_proxy_id: string | null
      date_approval: Date | null
      notes: string | null
      status: number
      label: string
      order: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["pOApprover"]>
    composites: {}
  }


  type POApproverGetPayload<S extends boolean | null | undefined | POApproverDefaultArgs> = $Result.GetResult<Prisma.$POApproverPayload, S>

  type POApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<POApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: POApproverCountAggregateInputType | true
    }

  export interface POApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POApprover'], meta: { name: 'POApprover' } }
    /**
     * Find zero or one POApprover that matches the filter.
     * @param {POApproverFindUniqueArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends POApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one POApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {POApproverFindUniqueOrThrowArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends POApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first POApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverFindFirstArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends POApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindFirstArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first POApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverFindFirstOrThrowArgs} args - Arguments to find a POApprover
     * @example
     * // Get one POApprover
     * const pOApprover = await prisma.pOApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends POApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more POApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POApprovers
     * const pOApprovers = await prisma.pOApprover.findMany()
     * 
     * // Get first 10 POApprovers
     * const pOApprovers = await prisma.pOApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOApproverWithIdOnly = await prisma.pOApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends POApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a POApprover.
     * @param {POApproverCreateArgs} args - Arguments to create a POApprover.
     * @example
     * // Create one POApprover
     * const POApprover = await prisma.pOApprover.create({
     *   data: {
     *     // ... data to create a POApprover
     *   }
     * })
     * 
    **/
    create<T extends POApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverCreateArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many POApprovers.
     *     @param {POApproverCreateManyArgs} args - Arguments to create many POApprovers.
     *     @example
     *     // Create many POApprovers
     *     const pOApprover = await prisma.pOApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends POApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a POApprover.
     * @param {POApproverDeleteArgs} args - Arguments to delete one POApprover.
     * @example
     * // Delete one POApprover
     * const POApprover = await prisma.pOApprover.delete({
     *   where: {
     *     // ... filter to delete one POApprover
     *   }
     * })
     * 
    **/
    delete<T extends POApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverDeleteArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one POApprover.
     * @param {POApproverUpdateArgs} args - Arguments to update one POApprover.
     * @example
     * // Update one POApprover
     * const pOApprover = await prisma.pOApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends POApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverUpdateArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more POApprovers.
     * @param {POApproverDeleteManyArgs} args - Arguments to filter POApprovers to delete.
     * @example
     * // Delete a few POApprovers
     * const { count } = await prisma.pOApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends POApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, POApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POApprovers
     * const pOApprover = await prisma.pOApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends POApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one POApprover.
     * @param {POApproverUpsertArgs} args - Arguments to update or create a POApprover.
     * @example
     * // Update or create a POApprover
     * const pOApprover = await prisma.pOApprover.upsert({
     *   create: {
     *     // ... data to create a POApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POApprover we want to update
     *   }
     * })
    **/
    upsert<T extends POApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, POApproverUpsertArgs<ExtArgs>>
    ): Prisma__POApproverClient<$Result.GetResult<Prisma.$POApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of POApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverCountArgs} args - Arguments to filter POApprovers to count.
     * @example
     * // Count the number of POApprovers
     * const count = await prisma.pOApprover.count({
     *   where: {
     *     // ... the filter for the POApprovers we want to count
     *   }
     * })
    **/
    count<T extends POApproverCountArgs>(
      args?: Subset<T, POApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POApproverAggregateArgs>(args: Subset<T, POApproverAggregateArgs>): Prisma.PrismaPromise<GetPOApproverAggregateType<T>>

    /**
     * Group by POApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POApproverGroupByArgs['orderBy'] }
        : { orderBy?: POApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POApprover model
   */
  readonly fields: POApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    po<T extends PODefaultArgs<ExtArgs> = {}>(args?: Subset<T, PODefaultArgs<ExtArgs>>): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the POApprover model
   */ 
  interface POApproverFieldRefs {
    readonly id: FieldRef<"POApprover", 'String'>
    readonly po_id: FieldRef<"POApprover", 'String'>
    readonly approver_id: FieldRef<"POApprover", 'String'>
    readonly approver_proxy_id: FieldRef<"POApprover", 'String'>
    readonly date_approval: FieldRef<"POApprover", 'DateTime'>
    readonly notes: FieldRef<"POApprover", 'String'>
    readonly status: FieldRef<"POApprover", 'Int'>
    readonly label: FieldRef<"POApprover", 'String'>
    readonly order: FieldRef<"POApprover", 'Int'>
    readonly created_at: FieldRef<"POApprover", 'DateTime'>
    readonly updated_at: FieldRef<"POApprover", 'DateTime'>
    readonly is_deleted: FieldRef<"POApprover", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * POApprover findUnique
   */
  export type POApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover findUniqueOrThrow
   */
  export type POApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover findFirst
   */
  export type POApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POApprovers.
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POApprovers.
     */
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * POApprover findFirstOrThrow
   */
  export type POApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprover to fetch.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POApprovers.
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POApprovers.
     */
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * POApprover findMany
   */
  export type POApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter, which POApprovers to fetch.
     */
    where?: POApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POApprovers to fetch.
     */
    orderBy?: POApproverOrderByWithRelationInput | POApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POApprovers.
     */
    cursor?: POApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POApprovers.
     */
    skip?: number
    distinct?: POApproverScalarFieldEnum | POApproverScalarFieldEnum[]
  }


  /**
   * POApprover create
   */
  export type POApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a POApprover.
     */
    data: XOR<POApproverCreateInput, POApproverUncheckedCreateInput>
  }


  /**
   * POApprover createMany
   */
  export type POApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POApprovers.
     */
    data: POApproverCreateManyInput | POApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * POApprover update
   */
  export type POApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a POApprover.
     */
    data: XOR<POApproverUpdateInput, POApproverUncheckedUpdateInput>
    /**
     * Choose, which POApprover to update.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover updateMany
   */
  export type POApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POApprovers.
     */
    data: XOR<POApproverUpdateManyMutationInput, POApproverUncheckedUpdateManyInput>
    /**
     * Filter which POApprovers to update
     */
    where?: POApproverWhereInput
  }


  /**
   * POApprover upsert
   */
  export type POApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the POApprover to update in case it exists.
     */
    where: POApproverWhereUniqueInput
    /**
     * In case the POApprover found by the `where` argument doesn't exist, create a new POApprover with this data.
     */
    create: XOR<POApproverCreateInput, POApproverUncheckedCreateInput>
    /**
     * In case the POApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POApproverUpdateInput, POApproverUncheckedUpdateInput>
  }


  /**
   * POApprover delete
   */
  export type POApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
    /**
     * Filter which POApprover to delete.
     */
    where: POApproverWhereUniqueInput
  }


  /**
   * POApprover deleteMany
   */
  export type POApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POApprovers to delete
     */
    where?: POApproverWhereInput
  }


  /**
   * POApprover without action
   */
  export type POApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POApprover
     */
    select?: POApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: POApproverInclude<ExtArgs> | null
  }



  /**
   * Model RR
   */

  export type AggregateRR = {
    _count: RRCountAggregateOutputType | null
    _avg: RRAvgAggregateOutputType | null
    _sum: RRSumAggregateOutputType | null
    _min: RRMinAggregateOutputType | null
    _max: RRMaxAggregateOutputType | null
  }

  export type RRAvgAggregateOutputType = {
    delivery_charge: number | null
    status: number | null
  }

  export type RRSumAggregateOutputType = {
    delivery_charge: number | null
    status: number | null
  }

  export type RRMinAggregateOutputType = {
    id: string | null
    po_id: string | null
    rr_number: string | null
    rr_date: Date | null
    received_by_id: string | null
    canceller_id: string | null
    date_cancelled: Date | null
    invoice_number: string | null
    delivery_number: string | null
    notes: string | null
    delivery_charge: number | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RRMaxAggregateOutputType = {
    id: string | null
    po_id: string | null
    rr_number: string | null
    rr_date: Date | null
    received_by_id: string | null
    canceller_id: string | null
    date_cancelled: Date | null
    invoice_number: string | null
    delivery_number: string | null
    notes: string | null
    delivery_charge: number | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RRCountAggregateOutputType = {
    id: number
    po_id: number
    rr_number: number
    rr_date: number
    received_by_id: number
    canceller_id: number
    date_cancelled: number
    invoice_number: number
    delivery_number: number
    notes: number
    delivery_charge: number
    status: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type RRAvgAggregateInputType = {
    delivery_charge?: true
    status?: true
  }

  export type RRSumAggregateInputType = {
    delivery_charge?: true
    status?: true
  }

  export type RRMinAggregateInputType = {
    id?: true
    po_id?: true
    rr_number?: true
    rr_date?: true
    received_by_id?: true
    canceller_id?: true
    date_cancelled?: true
    invoice_number?: true
    delivery_number?: true
    notes?: true
    delivery_charge?: true
    status?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RRMaxAggregateInputType = {
    id?: true
    po_id?: true
    rr_number?: true
    rr_date?: true
    received_by_id?: true
    canceller_id?: true
    date_cancelled?: true
    invoice_number?: true
    delivery_number?: true
    notes?: true
    delivery_charge?: true
    status?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RRCountAggregateInputType = {
    id?: true
    po_id?: true
    rr_number?: true
    rr_date?: true
    received_by_id?: true
    canceller_id?: true
    date_cancelled?: true
    invoice_number?: true
    delivery_number?: true
    notes?: true
    delivery_charge?: true
    status?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type RRAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RR to aggregate.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RRS
    **/
    _count?: true | RRCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RRAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RRSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RRMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RRMaxAggregateInputType
  }

  export type GetRRAggregateType<T extends RRAggregateArgs> = {
        [P in keyof T & keyof AggregateRR]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRR[P]>
      : GetScalarType<T[P], AggregateRR[P]>
  }




  export type RRGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRWhereInput
    orderBy?: RROrderByWithAggregationInput | RROrderByWithAggregationInput[]
    by: RRScalarFieldEnum[] | RRScalarFieldEnum
    having?: RRScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RRCountAggregateInputType | true
    _avg?: RRAvgAggregateInputType
    _sum?: RRSumAggregateInputType
    _min?: RRMinAggregateInputType
    _max?: RRMaxAggregateInputType
  }

  export type RRGroupByOutputType = {
    id: string
    po_id: string
    rr_number: string
    rr_date: Date
    received_by_id: string
    canceller_id: string | null
    date_cancelled: Date | null
    invoice_number: string
    delivery_number: string | null
    notes: string | null
    delivery_charge: number
    status: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: RRCountAggregateOutputType | null
    _avg: RRAvgAggregateOutputType | null
    _sum: RRSumAggregateOutputType | null
    _min: RRMinAggregateOutputType | null
    _max: RRMaxAggregateOutputType | null
  }

  type GetRRGroupByPayload<T extends RRGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RRGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RRGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RRGroupByOutputType[P]>
            : GetScalarType<T[P], RRGroupByOutputType[P]>
        }
      >
    >


  export type RRSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_id?: boolean
    rr_number?: boolean
    rr_date?: boolean
    received_by_id?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    invoice_number?: boolean
    delivery_number?: boolean
    notes?: boolean
    delivery_charge?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    po?: boolean | PODefaultArgs<ExtArgs>
    rr_approvers?: boolean | RR$rr_approversArgs<ExtArgs>
    rr_items?: boolean | RR$rr_itemsArgs<ExtArgs>
    _count?: boolean | RRCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rR"]>

  export type RRSelectScalar = {
    id?: boolean
    po_id?: boolean
    rr_number?: boolean
    rr_date?: boolean
    received_by_id?: boolean
    canceller_id?: boolean
    date_cancelled?: boolean
    invoice_number?: boolean
    delivery_number?: boolean
    notes?: boolean
    delivery_charge?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type RRInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PODefaultArgs<ExtArgs>
    rr_approvers?: boolean | RR$rr_approversArgs<ExtArgs>
    rr_items?: boolean | RR$rr_itemsArgs<ExtArgs>
    _count?: boolean | RRCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RRPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RR"
    objects: {
      po: Prisma.$POPayload<ExtArgs>
      rr_approvers: Prisma.$RRApproverPayload<ExtArgs>[]
      rr_items: Prisma.$RRItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      po_id: string
      rr_number: string
      rr_date: Date
      received_by_id: string
      canceller_id: string | null
      date_cancelled: Date | null
      invoice_number: string
      delivery_number: string | null
      notes: string | null
      delivery_charge: number
      status: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["rR"]>
    composites: {}
  }


  type RRGetPayload<S extends boolean | null | undefined | RRDefaultArgs> = $Result.GetResult<Prisma.$RRPayload, S>

  type RRCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RRFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RRCountAggregateInputType | true
    }

  export interface RRDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RR'], meta: { name: 'RR' } }
    /**
     * Find zero or one RR that matches the filter.
     * @param {RRFindUniqueArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RRFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RRFindUniqueArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RR that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RRFindUniqueOrThrowArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RRFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RR that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRFindFirstArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RRFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindFirstArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RR that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRFindFirstOrThrowArgs} args - Arguments to find a RR
     * @example
     * // Get one RR
     * const rR = await prisma.rR.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RRFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RRS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RRS
     * const rRS = await prisma.rR.findMany()
     * 
     * // Get first 10 RRS
     * const rRS = await prisma.rR.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rRWithIdOnly = await prisma.rR.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RRFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RR.
     * @param {RRCreateArgs} args - Arguments to create a RR.
     * @example
     * // Create one RR
     * const RR = await prisma.rR.create({
     *   data: {
     *     // ... data to create a RR
     *   }
     * })
     * 
    **/
    create<T extends RRCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RRCreateArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RRS.
     *     @param {RRCreateManyArgs} args - Arguments to create many RRS.
     *     @example
     *     // Create many RRS
     *     const rR = await prisma.rR.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RRCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RR.
     * @param {RRDeleteArgs} args - Arguments to delete one RR.
     * @example
     * // Delete one RR
     * const RR = await prisma.rR.delete({
     *   where: {
     *     // ... filter to delete one RR
     *   }
     * })
     * 
    **/
    delete<T extends RRDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RRDeleteArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RR.
     * @param {RRUpdateArgs} args - Arguments to update one RR.
     * @example
     * // Update one RR
     * const rR = await prisma.rR.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RRUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RRUpdateArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RRS.
     * @param {RRDeleteManyArgs} args - Arguments to filter RRS to delete.
     * @example
     * // Delete a few RRS
     * const { count } = await prisma.rR.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RRDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RRS
     * const rR = await prisma.rR.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RRUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RRUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RR.
     * @param {RRUpsertArgs} args - Arguments to update or create a RR.
     * @example
     * // Update or create a RR
     * const rR = await prisma.rR.upsert({
     *   create: {
     *     // ... data to create a RR
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RR we want to update
     *   }
     * })
    **/
    upsert<T extends RRUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RRUpsertArgs<ExtArgs>>
    ): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RRS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRCountArgs} args - Arguments to filter RRS to count.
     * @example
     * // Count the number of RRS
     * const count = await prisma.rR.count({
     *   where: {
     *     // ... the filter for the RRS we want to count
     *   }
     * })
    **/
    count<T extends RRCountArgs>(
      args?: Subset<T, RRCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RRCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RRAggregateArgs>(args: Subset<T, RRAggregateArgs>): Prisma.PrismaPromise<GetRRAggregateType<T>>

    /**
     * Group by RR.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RRGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RRGroupByArgs['orderBy'] }
        : { orderBy?: RRGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RRGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRRGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RR model
   */
  readonly fields: RRFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RR.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RRClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    po<T extends PODefaultArgs<ExtArgs> = {}>(args?: Subset<T, PODefaultArgs<ExtArgs>>): Prisma__POClient<$Result.GetResult<Prisma.$POPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rr_approvers<T extends RR$rr_approversArgs<ExtArgs> = {}>(args?: Subset<T, RR$rr_approversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findMany'> | Null>;

    rr_items<T extends RR$rr_itemsArgs<ExtArgs> = {}>(args?: Subset<T, RR$rr_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RR model
   */ 
  interface RRFieldRefs {
    readonly id: FieldRef<"RR", 'String'>
    readonly po_id: FieldRef<"RR", 'String'>
    readonly rr_number: FieldRef<"RR", 'String'>
    readonly rr_date: FieldRef<"RR", 'DateTime'>
    readonly received_by_id: FieldRef<"RR", 'String'>
    readonly canceller_id: FieldRef<"RR", 'String'>
    readonly date_cancelled: FieldRef<"RR", 'DateTime'>
    readonly invoice_number: FieldRef<"RR", 'String'>
    readonly delivery_number: FieldRef<"RR", 'String'>
    readonly notes: FieldRef<"RR", 'String'>
    readonly delivery_charge: FieldRef<"RR", 'Float'>
    readonly status: FieldRef<"RR", 'Int'>
    readonly created_at: FieldRef<"RR", 'DateTime'>
    readonly updated_at: FieldRef<"RR", 'DateTime'>
    readonly is_deleted: FieldRef<"RR", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * RR findUnique
   */
  export type RRFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR findUniqueOrThrow
   */
  export type RRFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR findFirst
   */
  export type RRFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRS.
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRS.
     */
    distinct?: RRScalarFieldEnum | RRScalarFieldEnum[]
  }


  /**
   * RR findFirstOrThrow
   */
  export type RRFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RR to fetch.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRS.
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRS.
     */
    distinct?: RRScalarFieldEnum | RRScalarFieldEnum[]
  }


  /**
   * RR findMany
   */
  export type RRFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter, which RRS to fetch.
     */
    where?: RRWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRS to fetch.
     */
    orderBy?: RROrderByWithRelationInput | RROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RRS.
     */
    cursor?: RRWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRS.
     */
    skip?: number
    distinct?: RRScalarFieldEnum | RRScalarFieldEnum[]
  }


  /**
   * RR create
   */
  export type RRCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * The data needed to create a RR.
     */
    data: XOR<RRCreateInput, RRUncheckedCreateInput>
  }


  /**
   * RR createMany
   */
  export type RRCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RRS.
     */
    data: RRCreateManyInput | RRCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RR update
   */
  export type RRUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * The data needed to update a RR.
     */
    data: XOR<RRUpdateInput, RRUncheckedUpdateInput>
    /**
     * Choose, which RR to update.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR updateMany
   */
  export type RRUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RRS.
     */
    data: XOR<RRUpdateManyMutationInput, RRUncheckedUpdateManyInput>
    /**
     * Filter which RRS to update
     */
    where?: RRWhereInput
  }


  /**
   * RR upsert
   */
  export type RRUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * The filter to search for the RR to update in case it exists.
     */
    where: RRWhereUniqueInput
    /**
     * In case the RR found by the `where` argument doesn't exist, create a new RR with this data.
     */
    create: XOR<RRCreateInput, RRUncheckedCreateInput>
    /**
     * In case the RR was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RRUpdateInput, RRUncheckedUpdateInput>
  }


  /**
   * RR delete
   */
  export type RRDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
    /**
     * Filter which RR to delete.
     */
    where: RRWhereUniqueInput
  }


  /**
   * RR deleteMany
   */
  export type RRDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRS to delete
     */
    where?: RRWhereInput
  }


  /**
   * RR.rr_approvers
   */
  export type RR$rr_approversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    where?: RRApproverWhereInput
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    cursor?: RRApproverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RR.rr_items
   */
  export type RR$rr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    cursor?: RRItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RR without action
   */
  export type RRDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RR
     */
    select?: RRSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRInclude<ExtArgs> | null
  }



  /**
   * Model RRApprover
   */

  export type AggregateRRApprover = {
    _count: RRApproverCountAggregateOutputType | null
    _avg: RRApproverAvgAggregateOutputType | null
    _sum: RRApproverSumAggregateOutputType | null
    _min: RRApproverMinAggregateOutputType | null
    _max: RRApproverMaxAggregateOutputType | null
  }

  export type RRApproverAvgAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RRApproverSumAggregateOutputType = {
    status: number | null
    order: number | null
  }

  export type RRApproverMinAggregateOutputType = {
    id: string | null
    rr_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RRApproverMaxAggregateOutputType = {
    id: string | null
    rr_id: string | null
    approver_id: string | null
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number | null
    label: string | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RRApproverCountAggregateOutputType = {
    id: number
    rr_id: number
    approver_id: number
    approver_proxy_id: number
    date_approval: number
    notes: number
    status: number
    label: number
    order: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type RRApproverAvgAggregateInputType = {
    status?: true
    order?: true
  }

  export type RRApproverSumAggregateInputType = {
    status?: true
    order?: true
  }

  export type RRApproverMinAggregateInputType = {
    id?: true
    rr_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RRApproverMaxAggregateInputType = {
    id?: true
    rr_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RRApproverCountAggregateInputType = {
    id?: true
    rr_id?: true
    approver_id?: true
    approver_proxy_id?: true
    date_approval?: true
    notes?: true
    status?: true
    label?: true
    order?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type RRApproverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRApprover to aggregate.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RRApprovers
    **/
    _count?: true | RRApproverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RRApproverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RRApproverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RRApproverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RRApproverMaxAggregateInputType
  }

  export type GetRRApproverAggregateType<T extends RRApproverAggregateArgs> = {
        [P in keyof T & keyof AggregateRRApprover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRRApprover[P]>
      : GetScalarType<T[P], AggregateRRApprover[P]>
  }




  export type RRApproverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRApproverWhereInput
    orderBy?: RRApproverOrderByWithAggregationInput | RRApproverOrderByWithAggregationInput[]
    by: RRApproverScalarFieldEnum[] | RRApproverScalarFieldEnum
    having?: RRApproverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RRApproverCountAggregateInputType | true
    _avg?: RRApproverAvgAggregateInputType
    _sum?: RRApproverSumAggregateInputType
    _min?: RRApproverMinAggregateInputType
    _max?: RRApproverMaxAggregateInputType
  }

  export type RRApproverGroupByOutputType = {
    id: string
    rr_id: string
    approver_id: string
    approver_proxy_id: string | null
    date_approval: Date | null
    notes: string | null
    status: number
    label: string
    order: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: RRApproverCountAggregateOutputType | null
    _avg: RRApproverAvgAggregateOutputType | null
    _sum: RRApproverSumAggregateOutputType | null
    _min: RRApproverMinAggregateOutputType | null
    _max: RRApproverMaxAggregateOutputType | null
  }

  type GetRRApproverGroupByPayload<T extends RRApproverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RRApproverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RRApproverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RRApproverGroupByOutputType[P]>
            : GetScalarType<T[P], RRApproverGroupByOutputType[P]>
        }
      >
    >


  export type RRApproverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rr_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    rr?: boolean | RRDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rRApprover"]>

  export type RRApproverSelectScalar = {
    id?: boolean
    rr_id?: boolean
    approver_id?: boolean
    approver_proxy_id?: boolean
    date_approval?: boolean
    notes?: boolean
    status?: boolean
    label?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type RRApproverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rr?: boolean | RRDefaultArgs<ExtArgs>
  }


  export type $RRApproverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RRApprover"
    objects: {
      rr: Prisma.$RRPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rr_id: string
      approver_id: string
      approver_proxy_id: string | null
      date_approval: Date | null
      notes: string | null
      status: number
      label: string
      order: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["rRApprover"]>
    composites: {}
  }


  type RRApproverGetPayload<S extends boolean | null | undefined | RRApproverDefaultArgs> = $Result.GetResult<Prisma.$RRApproverPayload, S>

  type RRApproverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RRApproverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RRApproverCountAggregateInputType | true
    }

  export interface RRApproverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RRApprover'], meta: { name: 'RRApprover' } }
    /**
     * Find zero or one RRApprover that matches the filter.
     * @param {RRApproverFindUniqueArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RRApproverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverFindUniqueArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RRApprover that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RRApproverFindUniqueOrThrowArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RRApproverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RRApprover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverFindFirstArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RRApproverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindFirstArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RRApprover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverFindFirstOrThrowArgs} args - Arguments to find a RRApprover
     * @example
     * // Get one RRApprover
     * const rRApprover = await prisma.rRApprover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RRApproverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RRApprovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RRApprovers
     * const rRApprovers = await prisma.rRApprover.findMany()
     * 
     * // Get first 10 RRApprovers
     * const rRApprovers = await prisma.rRApprover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rRApproverWithIdOnly = await prisma.rRApprover.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RRApproverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RRApprover.
     * @param {RRApproverCreateArgs} args - Arguments to create a RRApprover.
     * @example
     * // Create one RRApprover
     * const RRApprover = await prisma.rRApprover.create({
     *   data: {
     *     // ... data to create a RRApprover
     *   }
     * })
     * 
    **/
    create<T extends RRApproverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverCreateArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RRApprovers.
     *     @param {RRApproverCreateManyArgs} args - Arguments to create many RRApprovers.
     *     @example
     *     // Create many RRApprovers
     *     const rRApprover = await prisma.rRApprover.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RRApproverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RRApprover.
     * @param {RRApproverDeleteArgs} args - Arguments to delete one RRApprover.
     * @example
     * // Delete one RRApprover
     * const RRApprover = await prisma.rRApprover.delete({
     *   where: {
     *     // ... filter to delete one RRApprover
     *   }
     * })
     * 
    **/
    delete<T extends RRApproverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverDeleteArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RRApprover.
     * @param {RRApproverUpdateArgs} args - Arguments to update one RRApprover.
     * @example
     * // Update one RRApprover
     * const rRApprover = await prisma.rRApprover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RRApproverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverUpdateArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RRApprovers.
     * @param {RRApproverDeleteManyArgs} args - Arguments to filter RRApprovers to delete.
     * @example
     * // Delete a few RRApprovers
     * const { count } = await prisma.rRApprover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RRApproverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRApproverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RRApprovers
     * const rRApprover = await prisma.rRApprover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RRApproverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RRApprover.
     * @param {RRApproverUpsertArgs} args - Arguments to update or create a RRApprover.
     * @example
     * // Update or create a RRApprover
     * const rRApprover = await prisma.rRApprover.upsert({
     *   create: {
     *     // ... data to create a RRApprover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RRApprover we want to update
     *   }
     * })
    **/
    upsert<T extends RRApproverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RRApproverUpsertArgs<ExtArgs>>
    ): Prisma__RRApproverClient<$Result.GetResult<Prisma.$RRApproverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RRApprovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverCountArgs} args - Arguments to filter RRApprovers to count.
     * @example
     * // Count the number of RRApprovers
     * const count = await prisma.rRApprover.count({
     *   where: {
     *     // ... the filter for the RRApprovers we want to count
     *   }
     * })
    **/
    count<T extends RRApproverCountArgs>(
      args?: Subset<T, RRApproverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RRApproverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RRApproverAggregateArgs>(args: Subset<T, RRApproverAggregateArgs>): Prisma.PrismaPromise<GetRRApproverAggregateType<T>>

    /**
     * Group by RRApprover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRApproverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RRApproverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RRApproverGroupByArgs['orderBy'] }
        : { orderBy?: RRApproverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RRApproverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRRApproverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RRApprover model
   */
  readonly fields: RRApproverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RRApprover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RRApproverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rr<T extends RRDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RRDefaultArgs<ExtArgs>>): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RRApprover model
   */ 
  interface RRApproverFieldRefs {
    readonly id: FieldRef<"RRApprover", 'String'>
    readonly rr_id: FieldRef<"RRApprover", 'String'>
    readonly approver_id: FieldRef<"RRApprover", 'String'>
    readonly approver_proxy_id: FieldRef<"RRApprover", 'String'>
    readonly date_approval: FieldRef<"RRApprover", 'DateTime'>
    readonly notes: FieldRef<"RRApprover", 'String'>
    readonly status: FieldRef<"RRApprover", 'Int'>
    readonly label: FieldRef<"RRApprover", 'String'>
    readonly order: FieldRef<"RRApprover", 'Int'>
    readonly created_at: FieldRef<"RRApprover", 'DateTime'>
    readonly updated_at: FieldRef<"RRApprover", 'DateTime'>
    readonly is_deleted: FieldRef<"RRApprover", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * RRApprover findUnique
   */
  export type RRApproverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover findUniqueOrThrow
   */
  export type RRApproverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover findFirst
   */
  export type RRApproverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRApprovers.
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRApprovers.
     */
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RRApprover findFirstOrThrow
   */
  export type RRApproverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprover to fetch.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRApprovers.
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRApprovers.
     */
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RRApprover findMany
   */
  export type RRApproverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter, which RRApprovers to fetch.
     */
    where?: RRApproverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRApprovers to fetch.
     */
    orderBy?: RRApproverOrderByWithRelationInput | RRApproverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RRApprovers.
     */
    cursor?: RRApproverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRApprovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRApprovers.
     */
    skip?: number
    distinct?: RRApproverScalarFieldEnum | RRApproverScalarFieldEnum[]
  }


  /**
   * RRApprover create
   */
  export type RRApproverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * The data needed to create a RRApprover.
     */
    data: XOR<RRApproverCreateInput, RRApproverUncheckedCreateInput>
  }


  /**
   * RRApprover createMany
   */
  export type RRApproverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RRApprovers.
     */
    data: RRApproverCreateManyInput | RRApproverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RRApprover update
   */
  export type RRApproverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * The data needed to update a RRApprover.
     */
    data: XOR<RRApproverUpdateInput, RRApproverUncheckedUpdateInput>
    /**
     * Choose, which RRApprover to update.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover updateMany
   */
  export type RRApproverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RRApprovers.
     */
    data: XOR<RRApproverUpdateManyMutationInput, RRApproverUncheckedUpdateManyInput>
    /**
     * Filter which RRApprovers to update
     */
    where?: RRApproverWhereInput
  }


  /**
   * RRApprover upsert
   */
  export type RRApproverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * The filter to search for the RRApprover to update in case it exists.
     */
    where: RRApproverWhereUniqueInput
    /**
     * In case the RRApprover found by the `where` argument doesn't exist, create a new RRApprover with this data.
     */
    create: XOR<RRApproverCreateInput, RRApproverUncheckedCreateInput>
    /**
     * In case the RRApprover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RRApproverUpdateInput, RRApproverUncheckedUpdateInput>
  }


  /**
   * RRApprover delete
   */
  export type RRApproverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
    /**
     * Filter which RRApprover to delete.
     */
    where: RRApproverWhereUniqueInput
  }


  /**
   * RRApprover deleteMany
   */
  export type RRApproverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRApprovers to delete
     */
    where?: RRApproverWhereInput
  }


  /**
   * RRApprover without action
   */
  export type RRApproverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRApprover
     */
    select?: RRApproverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRApproverInclude<ExtArgs> | null
  }



  /**
   * Model RRItem
   */

  export type AggregateRRItem = {
    _count: RRItemCountAggregateOutputType | null
    _avg: RRItemAvgAggregateOutputType | null
    _sum: RRItemSumAggregateOutputType | null
    _min: RRItemMinAggregateOutputType | null
    _max: RRItemMaxAggregateOutputType | null
  }

  export type RRItemAvgAggregateOutputType = {
    item_class: number | null
    quantity_delivered: number | null
    quantity_accepted: number | null
    vat_type: number | null
    gross_price: number | null
    net_price: number | null
    vat_amount: number | null
  }

  export type RRItemSumAggregateOutputType = {
    item_class: number | null
    quantity_delivered: number | null
    quantity_accepted: number | null
    vat_type: number | null
    gross_price: number | null
    net_price: number | null
    vat_amount: number | null
  }

  export type RRItemMinAggregateOutputType = {
    id: string | null
    rr_id: string | null
    item_id: string | null
    item_brand_id: string | null
    unit_id: string | null
    item_class: number | null
    quantity_delivered: number | null
    quantity_accepted: number | null
    description: string | null
    vat_type: number | null
    gross_price: number | null
    net_price: number | null
    vat_amount: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RRItemMaxAggregateOutputType = {
    id: string | null
    rr_id: string | null
    item_id: string | null
    item_brand_id: string | null
    unit_id: string | null
    item_class: number | null
    quantity_delivered: number | null
    quantity_accepted: number | null
    description: string | null
    vat_type: number | null
    gross_price: number | null
    net_price: number | null
    vat_amount: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type RRItemCountAggregateOutputType = {
    id: number
    rr_id: number
    item_id: number
    item_brand_id: number
    unit_id: number
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: number
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type RRItemAvgAggregateInputType = {
    item_class?: true
    quantity_delivered?: true
    quantity_accepted?: true
    vat_type?: true
    gross_price?: true
    net_price?: true
    vat_amount?: true
  }

  export type RRItemSumAggregateInputType = {
    item_class?: true
    quantity_delivered?: true
    quantity_accepted?: true
    vat_type?: true
    gross_price?: true
    net_price?: true
    vat_amount?: true
  }

  export type RRItemMinAggregateInputType = {
    id?: true
    rr_id?: true
    item_id?: true
    item_brand_id?: true
    unit_id?: true
    item_class?: true
    quantity_delivered?: true
    quantity_accepted?: true
    description?: true
    vat_type?: true
    gross_price?: true
    net_price?: true
    vat_amount?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RRItemMaxAggregateInputType = {
    id?: true
    rr_id?: true
    item_id?: true
    item_brand_id?: true
    unit_id?: true
    item_class?: true
    quantity_delivered?: true
    quantity_accepted?: true
    description?: true
    vat_type?: true
    gross_price?: true
    net_price?: true
    vat_amount?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type RRItemCountAggregateInputType = {
    id?: true
    rr_id?: true
    item_id?: true
    item_brand_id?: true
    unit_id?: true
    item_class?: true
    quantity_delivered?: true
    quantity_accepted?: true
    description?: true
    vat_type?: true
    gross_price?: true
    net_price?: true
    vat_amount?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type RRItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRItem to aggregate.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RRItems
    **/
    _count?: true | RRItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RRItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RRItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RRItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RRItemMaxAggregateInputType
  }

  export type GetRRItemAggregateType<T extends RRItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRRItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRRItem[P]>
      : GetScalarType<T[P], AggregateRRItem[P]>
  }




  export type RRItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithAggregationInput | RRItemOrderByWithAggregationInput[]
    by: RRItemScalarFieldEnum[] | RRItemScalarFieldEnum
    having?: RRItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RRItemCountAggregateInputType | true
    _avg?: RRItemAvgAggregateInputType
    _sum?: RRItemSumAggregateInputType
    _min?: RRItemMinAggregateInputType
    _max?: RRItemMaxAggregateInputType
  }

  export type RRItemGroupByOutputType = {
    id: string
    rr_id: string
    item_id: string | null
    item_brand_id: string | null
    unit_id: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: RRItemCountAggregateOutputType | null
    _avg: RRItemAvgAggregateOutputType | null
    _sum: RRItemSumAggregateOutputType | null
    _min: RRItemMinAggregateOutputType | null
    _max: RRItemMaxAggregateOutputType | null
  }

  type GetRRItemGroupByPayload<T extends RRItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RRItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RRItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RRItemGroupByOutputType[P]>
            : GetScalarType<T[P], RRItemGroupByOutputType[P]>
        }
      >
    >


  export type RRItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rr_id?: boolean
    item_id?: boolean
    item_brand_id?: boolean
    unit_id?: boolean
    item_class?: boolean
    quantity_delivered?: boolean
    quantity_accepted?: boolean
    description?: boolean
    vat_type?: boolean
    gross_price?: boolean
    net_price?: boolean
    vat_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    rr?: boolean | RRDefaultArgs<ExtArgs>
    item?: boolean | RRItem$itemArgs<ExtArgs>
    item_brand?: boolean | RRItem$item_brandArgs<ExtArgs>
    unit?: boolean | RRItem$unitArgs<ExtArgs>
    item_transaction?: boolean | RRItem$item_transactionArgs<ExtArgs>
  }, ExtArgs["result"]["rRItem"]>

  export type RRItemSelectScalar = {
    id?: boolean
    rr_id?: boolean
    item_id?: boolean
    item_brand_id?: boolean
    unit_id?: boolean
    item_class?: boolean
    quantity_delivered?: boolean
    quantity_accepted?: boolean
    description?: boolean
    vat_type?: boolean
    gross_price?: boolean
    net_price?: boolean
    vat_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type RRItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rr?: boolean | RRDefaultArgs<ExtArgs>
    item?: boolean | RRItem$itemArgs<ExtArgs>
    item_brand?: boolean | RRItem$item_brandArgs<ExtArgs>
    unit?: boolean | RRItem$unitArgs<ExtArgs>
    item_transaction?: boolean | RRItem$item_transactionArgs<ExtArgs>
  }


  export type $RRItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RRItem"
    objects: {
      rr: Prisma.$RRPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs> | null
      item_brand: Prisma.$BrandPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
      item_transaction: Prisma.$ItemTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rr_id: string
      item_id: string | null
      item_brand_id: string | null
      unit_id: string | null
      item_class: number
      quantity_delivered: number
      quantity_accepted: number
      description: string
      vat_type: number
      gross_price: number
      net_price: number
      vat_amount: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["rRItem"]>
    composites: {}
  }


  type RRItemGetPayload<S extends boolean | null | undefined | RRItemDefaultArgs> = $Result.GetResult<Prisma.$RRItemPayload, S>

  type RRItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RRItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RRItemCountAggregateInputType | true
    }

  export interface RRItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RRItem'], meta: { name: 'RRItem' } }
    /**
     * Find zero or one RRItem that matches the filter.
     * @param {RRItemFindUniqueArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RRItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemFindUniqueArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RRItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RRItemFindUniqueOrThrowArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RRItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RRItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemFindFirstArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RRItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindFirstArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RRItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemFindFirstOrThrowArgs} args - Arguments to find a RRItem
     * @example
     * // Get one RRItem
     * const rRItem = await prisma.rRItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RRItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RRItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RRItems
     * const rRItems = await prisma.rRItem.findMany()
     * 
     * // Get first 10 RRItems
     * const rRItems = await prisma.rRItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rRItemWithIdOnly = await prisma.rRItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RRItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RRItem.
     * @param {RRItemCreateArgs} args - Arguments to create a RRItem.
     * @example
     * // Create one RRItem
     * const RRItem = await prisma.rRItem.create({
     *   data: {
     *     // ... data to create a RRItem
     *   }
     * })
     * 
    **/
    create<T extends RRItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemCreateArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RRItems.
     *     @param {RRItemCreateManyArgs} args - Arguments to create many RRItems.
     *     @example
     *     // Create many RRItems
     *     const rRItem = await prisma.rRItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RRItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RRItem.
     * @param {RRItemDeleteArgs} args - Arguments to delete one RRItem.
     * @example
     * // Delete one RRItem
     * const RRItem = await prisma.rRItem.delete({
     *   where: {
     *     // ... filter to delete one RRItem
     *   }
     * })
     * 
    **/
    delete<T extends RRItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemDeleteArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RRItem.
     * @param {RRItemUpdateArgs} args - Arguments to update one RRItem.
     * @example
     * // Update one RRItem
     * const rRItem = await prisma.rRItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RRItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemUpdateArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RRItems.
     * @param {RRItemDeleteManyArgs} args - Arguments to filter RRItems to delete.
     * @example
     * // Delete a few RRItems
     * const { count } = await prisma.rRItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RRItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RRItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RRItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RRItems
     * const rRItem = await prisma.rRItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RRItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RRItem.
     * @param {RRItemUpsertArgs} args - Arguments to update or create a RRItem.
     * @example
     * // Update or create a RRItem
     * const rRItem = await prisma.rRItem.upsert({
     *   create: {
     *     // ... data to create a RRItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RRItem we want to update
     *   }
     * })
    **/
    upsert<T extends RRItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RRItemUpsertArgs<ExtArgs>>
    ): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RRItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemCountArgs} args - Arguments to filter RRItems to count.
     * @example
     * // Count the number of RRItems
     * const count = await prisma.rRItem.count({
     *   where: {
     *     // ... the filter for the RRItems we want to count
     *   }
     * })
    **/
    count<T extends RRItemCountArgs>(
      args?: Subset<T, RRItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RRItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RRItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RRItemAggregateArgs>(args: Subset<T, RRItemAggregateArgs>): Prisma.PrismaPromise<GetRRItemAggregateType<T>>

    /**
     * Group by RRItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RRItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RRItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RRItemGroupByArgs['orderBy'] }
        : { orderBy?: RRItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RRItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRRItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RRItem model
   */
  readonly fields: RRItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RRItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RRItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rr<T extends RRDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RRDefaultArgs<ExtArgs>>): Prisma__RRClient<$Result.GetResult<Prisma.$RRPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends RRItem$itemArgs<ExtArgs> = {}>(args?: Subset<T, RRItem$itemArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    item_brand<T extends RRItem$item_brandArgs<ExtArgs> = {}>(args?: Subset<T, RRItem$item_brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    unit<T extends RRItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, RRItem$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    item_transaction<T extends RRItem$item_transactionArgs<ExtArgs> = {}>(args?: Subset<T, RRItem$item_transactionArgs<ExtArgs>>): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RRItem model
   */ 
  interface RRItemFieldRefs {
    readonly id: FieldRef<"RRItem", 'String'>
    readonly rr_id: FieldRef<"RRItem", 'String'>
    readonly item_id: FieldRef<"RRItem", 'String'>
    readonly item_brand_id: FieldRef<"RRItem", 'String'>
    readonly unit_id: FieldRef<"RRItem", 'String'>
    readonly item_class: FieldRef<"RRItem", 'Int'>
    readonly quantity_delivered: FieldRef<"RRItem", 'Int'>
    readonly quantity_accepted: FieldRef<"RRItem", 'Int'>
    readonly description: FieldRef<"RRItem", 'String'>
    readonly vat_type: FieldRef<"RRItem", 'Int'>
    readonly gross_price: FieldRef<"RRItem", 'Float'>
    readonly net_price: FieldRef<"RRItem", 'Float'>
    readonly vat_amount: FieldRef<"RRItem", 'Float'>
    readonly created_at: FieldRef<"RRItem", 'DateTime'>
    readonly updated_at: FieldRef<"RRItem", 'DateTime'>
    readonly is_deleted: FieldRef<"RRItem", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * RRItem findUnique
   */
  export type RRItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem findUniqueOrThrow
   */
  export type RRItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem findFirst
   */
  export type RRItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRItems.
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRItems.
     */
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RRItem findFirstOrThrow
   */
  export type RRItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItem to fetch.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RRItems.
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RRItems.
     */
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RRItem findMany
   */
  export type RRItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter, which RRItems to fetch.
     */
    where?: RRItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RRItems to fetch.
     */
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RRItems.
     */
    cursor?: RRItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RRItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RRItems.
     */
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * RRItem create
   */
  export type RRItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RRItem.
     */
    data: XOR<RRItemCreateInput, RRItemUncheckedCreateInput>
  }


  /**
   * RRItem createMany
   */
  export type RRItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RRItems.
     */
    data: RRItemCreateManyInput | RRItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RRItem update
   */
  export type RRItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RRItem.
     */
    data: XOR<RRItemUpdateInput, RRItemUncheckedUpdateInput>
    /**
     * Choose, which RRItem to update.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem updateMany
   */
  export type RRItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RRItems.
     */
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyInput>
    /**
     * Filter which RRItems to update
     */
    where?: RRItemWhereInput
  }


  /**
   * RRItem upsert
   */
  export type RRItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RRItem to update in case it exists.
     */
    where: RRItemWhereUniqueInput
    /**
     * In case the RRItem found by the `where` argument doesn't exist, create a new RRItem with this data.
     */
    create: XOR<RRItemCreateInput, RRItemUncheckedCreateInput>
    /**
     * In case the RRItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RRItemUpdateInput, RRItemUncheckedUpdateInput>
  }


  /**
   * RRItem delete
   */
  export type RRItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    /**
     * Filter which RRItem to delete.
     */
    where: RRItemWhereUniqueInput
  }


  /**
   * RRItem deleteMany
   */
  export type RRItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RRItems to delete
     */
    where?: RRItemWhereInput
  }


  /**
   * RRItem.item
   */
  export type RRItem$itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }


  /**
   * RRItem.item_brand
   */
  export type RRItem$item_brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }


  /**
   * RRItem.unit
   */
  export type RRItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }


  /**
   * RRItem.item_transaction
   */
  export type RRItem$item_transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
  }


  /**
   * RRItem without action
   */
  export type RRItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
  }



  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    quantity: number | null
    initial_quantity: number | null
  }

  export type ItemSumAggregateOutputType = {
    quantity: number | null
    initial_quantity: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    item_type_id: string | null
    unit_id: string | null
    code: string | null
    description: string | null
    quantity: number | null
    initial_quantity: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    item_type_id: string | null
    unit_id: string | null
    code: string | null
    description: string | null
    quantity: number | null
    initial_quantity: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    item_type_id: number
    unit_id: number
    code: number
    description: number
    quantity: number
    initial_quantity: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    quantity?: true
    initial_quantity?: true
  }

  export type ItemSumAggregateInputType = {
    quantity?: true
    initial_quantity?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    item_type_id?: true
    unit_id?: true
    code?: true
    description?: true
    quantity?: true
    initial_quantity?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    item_type_id?: true
    unit_id?: true
    code?: true
    description?: true
    quantity?: true
    initial_quantity?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    item_type_id?: true
    unit_id?: true
    code?: true
    description?: true
    quantity?: true
    initial_quantity?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    item_type_id: string
    unit_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_type_id?: boolean
    unit_id?: boolean
    code?: boolean
    description?: boolean
    quantity?: boolean
    initial_quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    item_type?: boolean | ItemTypeDefaultArgs<ExtArgs>
    item_transactions?: boolean | Item$item_transactionsArgs<ExtArgs>
    rr_items?: boolean | Item$rr_itemsArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    item_type_id?: boolean
    unit_id?: boolean
    code?: boolean
    description?: boolean
    quantity?: boolean
    initial_quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_type?: boolean | ItemTypeDefaultArgs<ExtArgs>
    item_transactions?: boolean | Item$item_transactionsArgs<ExtArgs>
    rr_items?: boolean | Item$rr_itemsArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      item_type: Prisma.$ItemTypePayload<ExtArgs>
      item_transactions: Prisma.$ItemTransactionPayload<ExtArgs>[]
      rr_items: Prisma.$RRItemPayload<ExtArgs>[]
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item_type_id: string
      unit_id: string
      code: string
      description: string
      quantity: number
      initial_quantity: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["item"]>
    composites: {}
  }


  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCreateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item_type<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item_transactions<T extends Item$item_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Item$item_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    rr_items<T extends Item$rr_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$rr_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly item_type_id: FieldRef<"Item", 'String'>
    readonly unit_id: FieldRef<"Item", 'String'>
    readonly code: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly quantity: FieldRef<"Item", 'Int'>
    readonly initial_quantity: FieldRef<"Item", 'Int'>
    readonly created_at: FieldRef<"Item", 'DateTime'>
    readonly updated_at: FieldRef<"Item", 'DateTime'>
    readonly is_deleted: FieldRef<"Item", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }


  /**
   * Item.item_transactions
   */
  export type Item$item_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    where?: ItemTransactionWhereInput
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    cursor?: ItemTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * Item.rr_items
   */
  export type Item$rr_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
    orderBy?: RRItemOrderByWithRelationInput | RRItemOrderByWithRelationInput[]
    cursor?: RRItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RRItemScalarFieldEnum | RRItemScalarFieldEnum[]
  }


  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
  }



  /**
   * Model ItemType
   */

  export type AggregateItemType = {
    _count: ItemTypeCountAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  export type ItemTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type ItemTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type ItemTypeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type ItemTypeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type ItemTypeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type ItemTypeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type ItemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemType to aggregate.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTypes
    **/
    _count?: true | ItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTypeMaxAggregateInputType
  }

  export type GetItemTypeAggregateType<T extends ItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemType[P]>
      : GetScalarType<T[P], AggregateItemType[P]>
  }




  export type ItemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTypeWhereInput
    orderBy?: ItemTypeOrderByWithAggregationInput | ItemTypeOrderByWithAggregationInput[]
    by: ItemTypeScalarFieldEnum[] | ItemTypeScalarFieldEnum
    having?: ItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTypeCountAggregateInputType | true
    _min?: ItemTypeMinAggregateInputType
    _max?: ItemTypeMaxAggregateInputType
  }

  export type ItemTypeGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: ItemTypeCountAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  type GetItemTypeGroupByPayload<T extends ItemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type ItemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    items?: boolean | ItemType$itemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type ItemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemType$itemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemType"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["itemType"]>
    composites: {}
  }


  type ItemTypeGetPayload<S extends boolean | null | undefined | ItemTypeDefaultArgs> = $Result.GetResult<Prisma.$ItemTypePayload, S>

  type ItemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemTypeCountAggregateInputType | true
    }

  export interface ItemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemType'], meta: { name: 'ItemType' } }
    /**
     * Find zero or one ItemType that matches the filter.
     * @param {ItemTypeFindUniqueArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemTypeFindUniqueOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindFirstArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTypes
     * const itemTypes = await prisma.itemType.findMany()
     * 
     * // Get first 10 ItemTypes
     * const itemTypes = await prisma.itemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemType.
     * @param {ItemTypeCreateArgs} args - Arguments to create a ItemType.
     * @example
     * // Create one ItemType
     * const ItemType = await prisma.itemType.create({
     *   data: {
     *     // ... data to create a ItemType
     *   }
     * })
     * 
    **/
    create<T extends ItemTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeCreateArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemTypes.
     *     @param {ItemTypeCreateManyArgs} args - Arguments to create many ItemTypes.
     *     @example
     *     // Create many ItemTypes
     *     const itemType = await prisma.itemType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemType.
     * @param {ItemTypeDeleteArgs} args - Arguments to delete one ItemType.
     * @example
     * // Delete one ItemType
     * const ItemType = await prisma.itemType.delete({
     *   where: {
     *     // ... filter to delete one ItemType
     *   }
     * })
     * 
    **/
    delete<T extends ItemTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeDeleteArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemType.
     * @param {ItemTypeUpdateArgs} args - Arguments to update one ItemType.
     * @example
     * // Update one ItemType
     * const itemType = await prisma.itemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeUpdateArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemTypes.
     * @param {ItemTypeDeleteManyArgs} args - Arguments to filter ItemTypes to delete.
     * @example
     * // Delete a few ItemTypes
     * const { count } = await prisma.itemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemType.
     * @param {ItemTypeUpsertArgs} args - Arguments to update or create a ItemType.
     * @example
     * // Update or create a ItemType
     * const itemType = await prisma.itemType.upsert({
     *   create: {
     *     // ... data to create a ItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemType we want to update
     *   }
     * })
    **/
    upsert<T extends ItemTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTypeUpsertArgs<ExtArgs>>
    ): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeCountArgs} args - Arguments to filter ItemTypes to count.
     * @example
     * // Count the number of ItemTypes
     * const count = await prisma.itemType.count({
     *   where: {
     *     // ... the filter for the ItemTypes we want to count
     *   }
     * })
    **/
    count<T extends ItemTypeCountArgs>(
      args?: Subset<T, ItemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTypeAggregateArgs>(args: Subset<T, ItemTypeAggregateArgs>): Prisma.PrismaPromise<GetItemTypeAggregateType<T>>

    /**
     * Group by ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: ItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemType model
   */
  readonly fields: ItemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends ItemType$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemType model
   */ 
  interface ItemTypeFieldRefs {
    readonly id: FieldRef<"ItemType", 'String'>
    readonly name: FieldRef<"ItemType", 'String'>
    readonly created_at: FieldRef<"ItemType", 'DateTime'>
    readonly updated_at: FieldRef<"ItemType", 'DateTime'>
    readonly is_deleted: FieldRef<"ItemType", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ItemType findUnique
   */
  export type ItemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType findUniqueOrThrow
   */
  export type ItemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType findFirst
   */
  export type ItemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }


  /**
   * ItemType findFirstOrThrow
   */
  export type ItemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }


  /**
   * ItemType findMany
   */
  export type ItemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemTypes to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }


  /**
   * ItemType create
   */
  export type ItemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemType.
     */
    data: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
  }


  /**
   * ItemType createMany
   */
  export type ItemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemType update
   */
  export type ItemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemType.
     */
    data: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
    /**
     * Choose, which ItemType to update.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType updateMany
   */
  export type ItemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
  }


  /**
   * ItemType upsert
   */
  export type ItemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemType to update in case it exists.
     */
    where: ItemTypeWhereUniqueInput
    /**
     * In case the ItemType found by the `where` argument doesn't exist, create a new ItemType with this data.
     */
    create: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
    /**
     * In case the ItemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
  }


  /**
   * ItemType delete
   */
  export type ItemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter which ItemType to delete.
     */
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType deleteMany
   */
  export type ItemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTypes to delete
     */
    where?: ItemTypeWhereInput
  }


  /**
   * ItemType.items
   */
  export type ItemType$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * ItemType without action
   */
  export type ItemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTypeInclude<ExtArgs> | null
  }



  /**
   * Model ItemTransaction
   */

  export type AggregateItemTransaction = {
    _count: ItemTransactionCountAggregateOutputType | null
    _avg: ItemTransactionAvgAggregateOutputType | null
    _sum: ItemTransactionSumAggregateOutputType | null
    _min: ItemTransactionMinAggregateOutputType | null
    _max: ItemTransactionMaxAggregateOutputType | null
  }

  export type ItemTransactionAvgAggregateOutputType = {
    type: number | null
    quantity: number | null
    price: number | null
  }

  export type ItemTransactionSumAggregateOutputType = {
    type: number | null
    quantity: number | null
    price: number | null
  }

  export type ItemTransactionMinAggregateOutputType = {
    id: string | null
    item_id: string | null
    rr_item_id: string | null
    type: number | null
    quantity: number | null
    price: number | null
    remarks: string | null
    is_initial: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type ItemTransactionMaxAggregateOutputType = {
    id: string | null
    item_id: string | null
    rr_item_id: string | null
    type: number | null
    quantity: number | null
    price: number | null
    remarks: string | null
    is_initial: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
  }

  export type ItemTransactionCountAggregateOutputType = {
    id: number
    item_id: number
    rr_item_id: number
    type: number
    quantity: number
    price: number
    remarks: number
    is_initial: number
    created_at: number
    updated_at: number
    is_deleted: number
    _all: number
  }


  export type ItemTransactionAvgAggregateInputType = {
    type?: true
    quantity?: true
    price?: true
  }

  export type ItemTransactionSumAggregateInputType = {
    type?: true
    quantity?: true
    price?: true
  }

  export type ItemTransactionMinAggregateInputType = {
    id?: true
    item_id?: true
    rr_item_id?: true
    type?: true
    quantity?: true
    price?: true
    remarks?: true
    is_initial?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type ItemTransactionMaxAggregateInputType = {
    id?: true
    item_id?: true
    rr_item_id?: true
    type?: true
    quantity?: true
    price?: true
    remarks?: true
    is_initial?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
  }

  export type ItemTransactionCountAggregateInputType = {
    id?: true
    item_id?: true
    rr_item_id?: true
    type?: true
    quantity?: true
    price?: true
    remarks?: true
    is_initial?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    _all?: true
  }

  export type ItemTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTransaction to aggregate.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTransactions
    **/
    _count?: true | ItemTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTransactionMaxAggregateInputType
  }

  export type GetItemTransactionAggregateType<T extends ItemTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateItemTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemTransaction[P]>
      : GetScalarType<T[P], AggregateItemTransaction[P]>
  }




  export type ItemTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTransactionWhereInput
    orderBy?: ItemTransactionOrderByWithAggregationInput | ItemTransactionOrderByWithAggregationInput[]
    by: ItemTransactionScalarFieldEnum[] | ItemTransactionScalarFieldEnum
    having?: ItemTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTransactionCountAggregateInputType | true
    _avg?: ItemTransactionAvgAggregateInputType
    _sum?: ItemTransactionSumAggregateInputType
    _min?: ItemTransactionMinAggregateInputType
    _max?: ItemTransactionMaxAggregateInputType
  }

  export type ItemTransactionGroupByOutputType = {
    id: string
    item_id: string
    rr_item_id: string | null
    type: number
    quantity: number
    price: number
    remarks: string | null
    is_initial: boolean
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    _count: ItemTransactionCountAggregateOutputType | null
    _avg: ItemTransactionAvgAggregateOutputType | null
    _sum: ItemTransactionSumAggregateOutputType | null
    _min: ItemTransactionMinAggregateOutputType | null
    _max: ItemTransactionMaxAggregateOutputType | null
  }

  type GetItemTransactionGroupByPayload<T extends ItemTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTransactionGroupByOutputType[P]>
        }
      >
    >


  export type ItemTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    rr_item_id?: boolean
    type?: boolean
    quantity?: boolean
    price?: boolean
    remarks?: boolean
    is_initial?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    rr_item?: boolean | ItemTransaction$rr_itemArgs<ExtArgs>
  }, ExtArgs["result"]["itemTransaction"]>

  export type ItemTransactionSelectScalar = {
    id?: boolean
    item_id?: boolean
    rr_item_id?: boolean
    type?: boolean
    quantity?: boolean
    price?: boolean
    remarks?: boolean
    is_initial?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
  }

  export type ItemTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    rr_item?: boolean | ItemTransaction$rr_itemArgs<ExtArgs>
  }


  export type $ItemTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemTransaction"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      rr_item: Prisma.$RRItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item_id: string
      rr_item_id: string | null
      type: number
      quantity: number
      price: number
      remarks: string | null
      is_initial: boolean
      created_at: Date
      updated_at: Date
      is_deleted: boolean
    }, ExtArgs["result"]["itemTransaction"]>
    composites: {}
  }


  type ItemTransactionGetPayload<S extends boolean | null | undefined | ItemTransactionDefaultArgs> = $Result.GetResult<Prisma.$ItemTransactionPayload, S>

  type ItemTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemTransactionCountAggregateInputType | true
    }

  export interface ItemTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemTransaction'], meta: { name: 'ItemTransaction' } }
    /**
     * Find zero or one ItemTransaction that matches the filter.
     * @param {ItemTransactionFindUniqueArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemTransactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemTransaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemTransactionFindUniqueOrThrowArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemTransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionFindFirstArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemTransactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindFirstArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionFindFirstOrThrowArgs} args - Arguments to find a ItemTransaction
     * @example
     * // Get one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemTransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTransactions
     * const itemTransactions = await prisma.itemTransaction.findMany()
     * 
     * // Get first 10 ItemTransactions
     * const itemTransactions = await prisma.itemTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTransactionWithIdOnly = await prisma.itemTransaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemTransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemTransaction.
     * @param {ItemTransactionCreateArgs} args - Arguments to create a ItemTransaction.
     * @example
     * // Create one ItemTransaction
     * const ItemTransaction = await prisma.itemTransaction.create({
     *   data: {
     *     // ... data to create a ItemTransaction
     *   }
     * })
     * 
    **/
    create<T extends ItemTransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionCreateArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemTransactions.
     *     @param {ItemTransactionCreateManyArgs} args - Arguments to create many ItemTransactions.
     *     @example
     *     // Create many ItemTransactions
     *     const itemTransaction = await prisma.itemTransaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemTransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemTransaction.
     * @param {ItemTransactionDeleteArgs} args - Arguments to delete one ItemTransaction.
     * @example
     * // Delete one ItemTransaction
     * const ItemTransaction = await prisma.itemTransaction.delete({
     *   where: {
     *     // ... filter to delete one ItemTransaction
     *   }
     * })
     * 
    **/
    delete<T extends ItemTransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionDeleteArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemTransaction.
     * @param {ItemTransactionUpdateArgs} args - Arguments to update one ItemTransaction.
     * @example
     * // Update one ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemTransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionUpdateArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemTransactions.
     * @param {ItemTransactionDeleteManyArgs} args - Arguments to filter ItemTransactions to delete.
     * @example
     * // Delete a few ItemTransactions
     * const { count } = await prisma.itemTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemTransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTransactions
     * const itemTransaction = await prisma.itemTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemTransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemTransaction.
     * @param {ItemTransactionUpsertArgs} args - Arguments to update or create a ItemTransaction.
     * @example
     * // Update or create a ItemTransaction
     * const itemTransaction = await prisma.itemTransaction.upsert({
     *   create: {
     *     // ... data to create a ItemTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemTransaction we want to update
     *   }
     * })
    **/
    upsert<T extends ItemTransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTransactionUpsertArgs<ExtArgs>>
    ): Prisma__ItemTransactionClient<$Result.GetResult<Prisma.$ItemTransactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionCountArgs} args - Arguments to filter ItemTransactions to count.
     * @example
     * // Count the number of ItemTransactions
     * const count = await prisma.itemTransaction.count({
     *   where: {
     *     // ... the filter for the ItemTransactions we want to count
     *   }
     * })
    **/
    count<T extends ItemTransactionCountArgs>(
      args?: Subset<T, ItemTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTransactionAggregateArgs>(args: Subset<T, ItemTransactionAggregateArgs>): Prisma.PrismaPromise<GetItemTransactionAggregateType<T>>

    /**
     * Group by ItemTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTransactionGroupByArgs['orderBy'] }
        : { orderBy?: ItemTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemTransaction model
   */
  readonly fields: ItemTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rr_item<T extends ItemTransaction$rr_itemArgs<ExtArgs> = {}>(args?: Subset<T, ItemTransaction$rr_itemArgs<ExtArgs>>): Prisma__RRItemClient<$Result.GetResult<Prisma.$RRItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemTransaction model
   */ 
  interface ItemTransactionFieldRefs {
    readonly id: FieldRef<"ItemTransaction", 'String'>
    readonly item_id: FieldRef<"ItemTransaction", 'String'>
    readonly rr_item_id: FieldRef<"ItemTransaction", 'String'>
    readonly type: FieldRef<"ItemTransaction", 'Int'>
    readonly quantity: FieldRef<"ItemTransaction", 'Float'>
    readonly price: FieldRef<"ItemTransaction", 'Float'>
    readonly remarks: FieldRef<"ItemTransaction", 'String'>
    readonly is_initial: FieldRef<"ItemTransaction", 'Boolean'>
    readonly created_at: FieldRef<"ItemTransaction", 'DateTime'>
    readonly updated_at: FieldRef<"ItemTransaction", 'DateTime'>
    readonly is_deleted: FieldRef<"ItemTransaction", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ItemTransaction findUnique
   */
  export type ItemTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction findUniqueOrThrow
   */
  export type ItemTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction findFirst
   */
  export type ItemTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTransactions.
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTransactions.
     */
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * ItemTransaction findFirstOrThrow
   */
  export type ItemTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransaction to fetch.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTransactions.
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTransactions.
     */
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * ItemTransaction findMany
   */
  export type ItemTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ItemTransactions to fetch.
     */
    where?: ItemTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTransactions to fetch.
     */
    orderBy?: ItemTransactionOrderByWithRelationInput | ItemTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTransactions.
     */
    cursor?: ItemTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTransactions.
     */
    skip?: number
    distinct?: ItemTransactionScalarFieldEnum | ItemTransactionScalarFieldEnum[]
  }


  /**
   * ItemTransaction create
   */
  export type ItemTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemTransaction.
     */
    data: XOR<ItemTransactionCreateInput, ItemTransactionUncheckedCreateInput>
  }


  /**
   * ItemTransaction createMany
   */
  export type ItemTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTransactions.
     */
    data: ItemTransactionCreateManyInput | ItemTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemTransaction update
   */
  export type ItemTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemTransaction.
     */
    data: XOR<ItemTransactionUpdateInput, ItemTransactionUncheckedUpdateInput>
    /**
     * Choose, which ItemTransaction to update.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction updateMany
   */
  export type ItemTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTransactions.
     */
    data: XOR<ItemTransactionUpdateManyMutationInput, ItemTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ItemTransactions to update
     */
    where?: ItemTransactionWhereInput
  }


  /**
   * ItemTransaction upsert
   */
  export type ItemTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemTransaction to update in case it exists.
     */
    where: ItemTransactionWhereUniqueInput
    /**
     * In case the ItemTransaction found by the `where` argument doesn't exist, create a new ItemTransaction with this data.
     */
    create: XOR<ItemTransactionCreateInput, ItemTransactionUncheckedCreateInput>
    /**
     * In case the ItemTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTransactionUpdateInput, ItemTransactionUncheckedUpdateInput>
  }


  /**
   * ItemTransaction delete
   */
  export type ItemTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
    /**
     * Filter which ItemTransaction to delete.
     */
    where: ItemTransactionWhereUniqueInput
  }


  /**
   * ItemTransaction deleteMany
   */
  export type ItemTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTransactions to delete
     */
    where?: ItemTransactionWhereInput
  }


  /**
   * ItemTransaction.rr_item
   */
  export type ItemTransaction$rr_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RRItem
     */
    select?: RRItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RRItemInclude<ExtArgs> | null
    where?: RRItemWhereInput
  }


  /**
   * ItemTransaction without action
   */
  export type ItemTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTransaction
     */
    select?: ItemTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemTransactionInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plate_number: 'plate_number',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const CanvassItemScalarFieldEnum: {
    id: 'id',
    canvass_id: 'canvass_id',
    description: 'description',
    brand_id: 'brand_id',
    unit_id: 'unit_id',
    quantity: 'quantity',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type CanvassItemScalarFieldEnum = (typeof CanvassItemScalarFieldEnum)[keyof typeof CanvassItemScalarFieldEnum]


  export const CanvassScalarFieldEnum: {
    id: 'id',
    rc_number: 'rc_number',
    date_requested: 'date_requested',
    purpose: 'purpose',
    notes: 'notes',
    requested_by_id: 'requested_by_id',
    is_referenced: 'is_referenced',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type CanvassScalarFieldEnum = (typeof CanvassScalarFieldEnum)[keyof typeof CanvassScalarFieldEnum]


  export const JOScalarFieldEnum: {
    id: 'id',
    jo_number: 'jo_number',
    date_requested: 'date_requested',
    canvass_id: 'canvass_id',
    equipment: 'equipment',
    classification_id: 'classification_id',
    department_id: 'department_id',
    supervisor_id: 'supervisor_id',
    status: 'status',
    canceller_id: 'canceller_id',
    date_cancelled: 'date_cancelled',
    is_referenced: 'is_referenced',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type JOScalarFieldEnum = (typeof JOScalarFieldEnum)[keyof typeof JOScalarFieldEnum]


  export const JOApproverScalarFieldEnum: {
    id: 'id',
    jo_id: 'jo_id',
    approver_proxy_id: 'approver_proxy_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type JOApproverScalarFieldEnum = (typeof JOApproverScalarFieldEnum)[keyof typeof JOApproverScalarFieldEnum]


  export const RVScalarFieldEnum: {
    id: 'id',
    canvass_id: 'canvass_id',
    classification_id: 'classification_id',
    supervisor_id: 'supervisor_id',
    canceller_id: 'canceller_id',
    date_cancelled: 'date_cancelled',
    rv_number: 'rv_number',
    date_requested: 'date_requested',
    work_order_no: 'work_order_no',
    work_order_date: 'work_order_date',
    status: 'status',
    is_referenced: 'is_referenced',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type RVScalarFieldEnum = (typeof RVScalarFieldEnum)[keyof typeof RVScalarFieldEnum]


  export const RVApproverScalarFieldEnum: {
    id: 'id',
    rv_id: 'rv_id',
    approver_id: 'approver_id',
    approver_proxy_id: 'approver_proxy_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type RVApproverScalarFieldEnum = (typeof RVApproverScalarFieldEnum)[keyof typeof RVApproverScalarFieldEnum]


  export const SPRScalarFieldEnum: {
    id: 'id',
    spr_number: 'spr_number',
    date_requested: 'date_requested',
    canvass_id: 'canvass_id',
    vehicle_id: 'vehicle_id',
    classification_id: 'classification_id',
    supervisor_id: 'supervisor_id',
    status: 'status',
    canceller_id: 'canceller_id',
    date_cancelled: 'date_cancelled',
    is_referenced: 'is_referenced',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type SPRScalarFieldEnum = (typeof SPRScalarFieldEnum)[keyof typeof SPRScalarFieldEnum]


  export const SPRApproverScalarFieldEnum: {
    id: 'id',
    spr_id: 'spr_id',
    approver_id: 'approver_id',
    approver_proxy_id: 'approver_proxy_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type SPRApproverScalarFieldEnum = (typeof SPRApproverScalarFieldEnum)[keyof typeof SPRApproverScalarFieldEnum]


  export const MEQSScalarFieldEnum: {
    id: 'id',
    jo_id: 'jo_id',
    rv_id: 'rv_id',
    spr_id: 'spr_id',
    meqs_number: 'meqs_number',
    request_type: 'request_type',
    meqs_date: 'meqs_date',
    status: 'status',
    notes: 'notes',
    canceller_id: 'canceller_id',
    date_cancelled: 'date_cancelled',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type MEQSScalarFieldEnum = (typeof MEQSScalarFieldEnum)[keyof typeof MEQSScalarFieldEnum]


  export const MEQSSupplierScalarFieldEnum: {
    id: 'id',
    meqs_id: 'meqs_id',
    supplier_id: 'supplier_id',
    payment_terms: 'payment_terms',
    is_referenced: 'is_referenced',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type MEQSSupplierScalarFieldEnum = (typeof MEQSSupplierScalarFieldEnum)[keyof typeof MEQSSupplierScalarFieldEnum]


  export const MEQSSupplierItemScalarFieldEnum: {
    id: 'id',
    canvass_item_id: 'canvass_item_id',
    meqs_supplier_id: 'meqs_supplier_id',
    price: 'price',
    is_awarded: 'is_awarded',
    notes: 'notes',
    vat_type: 'vat_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type MEQSSupplierItemScalarFieldEnum = (typeof MEQSSupplierItemScalarFieldEnum)[keyof typeof MEQSSupplierItemScalarFieldEnum]


  export const MEQSSupplierAttachmentScalarFieldEnum: {
    id: 'id',
    meqs_supplier_id: 'meqs_supplier_id',
    src: 'src',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type MEQSSupplierAttachmentScalarFieldEnum = (typeof MEQSSupplierAttachmentScalarFieldEnum)[keyof typeof MEQSSupplierAttachmentScalarFieldEnum]


  export const MEQSApproverScalarFieldEnum: {
    id: 'id',
    meqs_id: 'meqs_id',
    approver_id: 'approver_id',
    approver_proxy_id: 'approver_proxy_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type MEQSApproverScalarFieldEnum = (typeof MEQSApproverScalarFieldEnum)[keyof typeof MEQSApproverScalarFieldEnum]


  export const POScalarFieldEnum: {
    id: 'id',
    meqs_supplier_id: 'meqs_supplier_id',
    po_number: 'po_number',
    po_date: 'po_date',
    status: 'status',
    canceller_id: 'canceller_id',
    date_cancelled: 'date_cancelled',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    is_referenced: 'is_referenced'
  };

  export type POScalarFieldEnum = (typeof POScalarFieldEnum)[keyof typeof POScalarFieldEnum]


  export const POApproverScalarFieldEnum: {
    id: 'id',
    po_id: 'po_id',
    approver_id: 'approver_id',
    approver_proxy_id: 'approver_proxy_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type POApproverScalarFieldEnum = (typeof POApproverScalarFieldEnum)[keyof typeof POApproverScalarFieldEnum]


  export const RRScalarFieldEnum: {
    id: 'id',
    po_id: 'po_id',
    rr_number: 'rr_number',
    rr_date: 'rr_date',
    received_by_id: 'received_by_id',
    canceller_id: 'canceller_id',
    date_cancelled: 'date_cancelled',
    invoice_number: 'invoice_number',
    delivery_number: 'delivery_number',
    notes: 'notes',
    delivery_charge: 'delivery_charge',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type RRScalarFieldEnum = (typeof RRScalarFieldEnum)[keyof typeof RRScalarFieldEnum]


  export const RRApproverScalarFieldEnum: {
    id: 'id',
    rr_id: 'rr_id',
    approver_id: 'approver_id',
    approver_proxy_id: 'approver_proxy_id',
    date_approval: 'date_approval',
    notes: 'notes',
    status: 'status',
    label: 'label',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type RRApproverScalarFieldEnum = (typeof RRApproverScalarFieldEnum)[keyof typeof RRApproverScalarFieldEnum]


  export const RRItemScalarFieldEnum: {
    id: 'id',
    rr_id: 'rr_id',
    item_id: 'item_id',
    item_brand_id: 'item_brand_id',
    unit_id: 'unit_id',
    item_class: 'item_class',
    quantity_delivered: 'quantity_delivered',
    quantity_accepted: 'quantity_accepted',
    description: 'description',
    vat_type: 'vat_type',
    gross_price: 'gross_price',
    net_price: 'net_price',
    vat_amount: 'vat_amount',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type RRItemScalarFieldEnum = (typeof RRItemScalarFieldEnum)[keyof typeof RRItemScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    item_type_id: 'item_type_id',
    unit_id: 'unit_id',
    code: 'code',
    description: 'description',
    quantity: 'quantity',
    initial_quantity: 'initial_quantity',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type ItemTypeScalarFieldEnum = (typeof ItemTypeScalarFieldEnum)[keyof typeof ItemTypeScalarFieldEnum]


  export const ItemTransactionScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    rr_item_id: 'rr_item_id',
    type: 'type',
    quantity: 'quantity',
    price: 'price',
    remarks: 'remarks',
    is_initial: 'is_initial',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted'
  };

  export type ItemTransactionScalarFieldEnum = (typeof ItemTransactionScalarFieldEnum)[keyof typeof ItemTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contact?: StringFilter<"Supplier"> | string
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    is_deleted?: BoolFilter<"Supplier"> | boolean
    MEQSSupplier?: MEQSSupplierListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    MEQSSupplier?: MEQSSupplierOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contact?: StringFilter<"Supplier"> | string
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    is_deleted?: BoolFilter<"Supplier"> | boolean
    MEQSSupplier?: MEQSSupplierListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contact?: StringWithAggregatesFilter<"Supplier"> | string
    created_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"Supplier"> | boolean
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    created_at?: DateTimeFilter<"Unit"> | Date | string
    updated_at?: DateTimeFilter<"Unit"> | Date | string
    is_deleted?: BoolFilter<"Unit"> | boolean
    canvass_items?: CanvassItemListRelationFilter
    rr_items?: RRItemListRelationFilter
    items?: ItemListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    canvass_items?: CanvassItemOrderByRelationAggregateInput
    rr_items?: RRItemOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    created_at?: DateTimeFilter<"Unit"> | Date | string
    updated_at?: DateTimeFilter<"Unit"> | Date | string
    is_deleted?: BoolFilter<"Unit"> | boolean
    canvass_items?: CanvassItemListRelationFilter
    rr_items?: RRItemListRelationFilter
    items?: ItemListRelationFilter
  }, "id" | "name">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    created_at?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"Unit"> | boolean
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    name?: StringFilter<"Brand"> | string
    created_at?: DateTimeFilter<"Brand"> | Date | string
    updated_at?: DateTimeFilter<"Brand"> | Date | string
    is_deleted?: BoolFilter<"Brand"> | boolean
    canvass_items?: CanvassItemListRelationFilter
    rr_items?: RRItemListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    canvass_items?: CanvassItemOrderByRelationAggregateInput
    rr_items?: RRItemOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    name?: StringFilter<"Brand"> | string
    created_at?: DateTimeFilter<"Brand"> | Date | string
    updated_at?: DateTimeFilter<"Brand"> | Date | string
    is_deleted?: BoolFilter<"Brand"> | boolean
    canvass_items?: CanvassItemListRelationFilter
    rr_items?: RRItemListRelationFilter
  }, "id">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    name?: StringWithAggregatesFilter<"Brand"> | string
    created_at?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"Brand"> | boolean
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    name?: StringFilter<"Vehicle"> | string
    plate_number?: StringFilter<"Vehicle"> | string
    created_at?: DateTimeFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeFilter<"Vehicle"> | Date | string
    is_deleted?: BoolFilter<"Vehicle"> | boolean
    sprs?: SPRListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    sprs?: SPROrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    name?: StringFilter<"Vehicle"> | string
    plate_number?: StringFilter<"Vehicle"> | string
    created_at?: DateTimeFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeFilter<"Vehicle"> | Date | string
    is_deleted?: BoolFilter<"Vehicle"> | boolean
    sprs?: SPRListRelationFilter
  }, "id">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    name?: StringWithAggregatesFilter<"Vehicle"> | string
    plate_number?: StringWithAggregatesFilter<"Vehicle"> | string
    created_at?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"Vehicle"> | boolean
  }

  export type CanvassItemWhereInput = {
    AND?: CanvassItemWhereInput | CanvassItemWhereInput[]
    OR?: CanvassItemWhereInput[]
    NOT?: CanvassItemWhereInput | CanvassItemWhereInput[]
    id?: StringFilter<"CanvassItem"> | string
    canvass_id?: StringFilter<"CanvassItem"> | string
    description?: StringFilter<"CanvassItem"> | string
    brand_id?: StringNullableFilter<"CanvassItem"> | string | null
    unit_id?: StringFilter<"CanvassItem"> | string
    quantity?: IntFilter<"CanvassItem"> | number
    created_at?: DateTimeFilter<"CanvassItem"> | Date | string
    updated_at?: DateTimeFilter<"CanvassItem"> | Date | string
    is_deleted?: BoolFilter<"CanvassItem"> | boolean
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
  }

  export type CanvassItemOrderByWithRelationInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    description?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    canvass?: CanvassOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    meqs_supplier_items?: MEQSSupplierItemOrderByRelationAggregateInput
  }

  export type CanvassItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CanvassItemWhereInput | CanvassItemWhereInput[]
    OR?: CanvassItemWhereInput[]
    NOT?: CanvassItemWhereInput | CanvassItemWhereInput[]
    canvass_id?: StringFilter<"CanvassItem"> | string
    description?: StringFilter<"CanvassItem"> | string
    brand_id?: StringNullableFilter<"CanvassItem"> | string | null
    unit_id?: StringFilter<"CanvassItem"> | string
    quantity?: IntFilter<"CanvassItem"> | number
    created_at?: DateTimeFilter<"CanvassItem"> | Date | string
    updated_at?: DateTimeFilter<"CanvassItem"> | Date | string
    is_deleted?: BoolFilter<"CanvassItem"> | boolean
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
  }, "id">

  export type CanvassItemOrderByWithAggregationInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    description?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: CanvassItemCountOrderByAggregateInput
    _avg?: CanvassItemAvgOrderByAggregateInput
    _max?: CanvassItemMaxOrderByAggregateInput
    _min?: CanvassItemMinOrderByAggregateInput
    _sum?: CanvassItemSumOrderByAggregateInput
  }

  export type CanvassItemScalarWhereWithAggregatesInput = {
    AND?: CanvassItemScalarWhereWithAggregatesInput | CanvassItemScalarWhereWithAggregatesInput[]
    OR?: CanvassItemScalarWhereWithAggregatesInput[]
    NOT?: CanvassItemScalarWhereWithAggregatesInput | CanvassItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CanvassItem"> | string
    canvass_id?: StringWithAggregatesFilter<"CanvassItem"> | string
    description?: StringWithAggregatesFilter<"CanvassItem"> | string
    brand_id?: StringNullableWithAggregatesFilter<"CanvassItem"> | string | null
    unit_id?: StringWithAggregatesFilter<"CanvassItem"> | string
    quantity?: IntWithAggregatesFilter<"CanvassItem"> | number
    created_at?: DateTimeWithAggregatesFilter<"CanvassItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CanvassItem"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"CanvassItem"> | boolean
  }

  export type CanvassWhereInput = {
    AND?: CanvassWhereInput | CanvassWhereInput[]
    OR?: CanvassWhereInput[]
    NOT?: CanvassWhereInput | CanvassWhereInput[]
    id?: StringFilter<"Canvass"> | string
    rc_number?: StringFilter<"Canvass"> | string
    date_requested?: DateTimeFilter<"Canvass"> | Date | string
    purpose?: StringFilter<"Canvass"> | string
    notes?: StringNullableFilter<"Canvass"> | string | null
    requested_by_id?: StringFilter<"Canvass"> | string
    is_referenced?: BoolFilter<"Canvass"> | boolean
    created_at?: DateTimeFilter<"Canvass"> | Date | string
    updated_at?: DateTimeFilter<"Canvass"> | Date | string
    is_deleted?: BoolFilter<"Canvass"> | boolean
    canvass_items?: CanvassItemListRelationFilter
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
  }

  export type CanvassOrderByWithRelationInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrderInput | SortOrder
    requested_by_id?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    canvass_items?: CanvassItemOrderByRelationAggregateInput
    jo?: JOOrderByWithRelationInput
    rv?: RVOrderByWithRelationInput
    spr?: SPROrderByWithRelationInput
  }

  export type CanvassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rc_number?: string
    AND?: CanvassWhereInput | CanvassWhereInput[]
    OR?: CanvassWhereInput[]
    NOT?: CanvassWhereInput | CanvassWhereInput[]
    date_requested?: DateTimeFilter<"Canvass"> | Date | string
    purpose?: StringFilter<"Canvass"> | string
    notes?: StringNullableFilter<"Canvass"> | string | null
    requested_by_id?: StringFilter<"Canvass"> | string
    is_referenced?: BoolFilter<"Canvass"> | boolean
    created_at?: DateTimeFilter<"Canvass"> | Date | string
    updated_at?: DateTimeFilter<"Canvass"> | Date | string
    is_deleted?: BoolFilter<"Canvass"> | boolean
    canvass_items?: CanvassItemListRelationFilter
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
  }, "id" | "rc_number">

  export type CanvassOrderByWithAggregationInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrderInput | SortOrder
    requested_by_id?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: CanvassCountOrderByAggregateInput
    _max?: CanvassMaxOrderByAggregateInput
    _min?: CanvassMinOrderByAggregateInput
  }

  export type CanvassScalarWhereWithAggregatesInput = {
    AND?: CanvassScalarWhereWithAggregatesInput | CanvassScalarWhereWithAggregatesInput[]
    OR?: CanvassScalarWhereWithAggregatesInput[]
    NOT?: CanvassScalarWhereWithAggregatesInput | CanvassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Canvass"> | string
    rc_number?: StringWithAggregatesFilter<"Canvass"> | string
    date_requested?: DateTimeWithAggregatesFilter<"Canvass"> | Date | string
    purpose?: StringWithAggregatesFilter<"Canvass"> | string
    notes?: StringNullableWithAggregatesFilter<"Canvass"> | string | null
    requested_by_id?: StringWithAggregatesFilter<"Canvass"> | string
    is_referenced?: BoolWithAggregatesFilter<"Canvass"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Canvass"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Canvass"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"Canvass"> | boolean
  }

  export type JOWhereInput = {
    AND?: JOWhereInput | JOWhereInput[]
    OR?: JOWhereInput[]
    NOT?: JOWhereInput | JOWhereInput[]
    id?: StringFilter<"JO"> | string
    jo_number?: StringFilter<"JO"> | string
    date_requested?: DateTimeFilter<"JO"> | Date | string
    canvass_id?: StringFilter<"JO"> | string
    equipment?: StringFilter<"JO"> | string
    classification_id?: StringNullableFilter<"JO"> | string | null
    department_id?: StringFilter<"JO"> | string
    supervisor_id?: StringFilter<"JO"> | string
    status?: IntFilter<"JO"> | number
    canceller_id?: StringNullableFilter<"JO"> | string | null
    date_cancelled?: DateTimeNullableFilter<"JO"> | Date | string | null
    is_referenced?: BoolFilter<"JO"> | boolean
    created_at?: DateTimeFilter<"JO"> | Date | string
    updated_at?: DateTimeFilter<"JO"> | Date | string
    is_deleted?: BoolFilter<"JO"> | boolean
    jo_approvers?: JOApproverListRelationFilter
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
  }

  export type JOOrderByWithRelationInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    jo_approvers?: JOApproverOrderByRelationAggregateInput
    canvass?: CanvassOrderByWithRelationInput
    meqs?: MEQSOrderByWithRelationInput
  }

  export type JOWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jo_number?: string
    canvass_id?: string
    AND?: JOWhereInput | JOWhereInput[]
    OR?: JOWhereInput[]
    NOT?: JOWhereInput | JOWhereInput[]
    date_requested?: DateTimeFilter<"JO"> | Date | string
    equipment?: StringFilter<"JO"> | string
    classification_id?: StringNullableFilter<"JO"> | string | null
    department_id?: StringFilter<"JO"> | string
    supervisor_id?: StringFilter<"JO"> | string
    status?: IntFilter<"JO"> | number
    canceller_id?: StringNullableFilter<"JO"> | string | null
    date_cancelled?: DateTimeNullableFilter<"JO"> | Date | string | null
    is_referenced?: BoolFilter<"JO"> | boolean
    created_at?: DateTimeFilter<"JO"> | Date | string
    updated_at?: DateTimeFilter<"JO"> | Date | string
    is_deleted?: BoolFilter<"JO"> | boolean
    jo_approvers?: JOApproverListRelationFilter
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
  }, "id" | "jo_number" | "canvass_id">

  export type JOOrderByWithAggregationInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: JOCountOrderByAggregateInput
    _avg?: JOAvgOrderByAggregateInput
    _max?: JOMaxOrderByAggregateInput
    _min?: JOMinOrderByAggregateInput
    _sum?: JOSumOrderByAggregateInput
  }

  export type JOScalarWhereWithAggregatesInput = {
    AND?: JOScalarWhereWithAggregatesInput | JOScalarWhereWithAggregatesInput[]
    OR?: JOScalarWhereWithAggregatesInput[]
    NOT?: JOScalarWhereWithAggregatesInput | JOScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JO"> | string
    jo_number?: StringWithAggregatesFilter<"JO"> | string
    date_requested?: DateTimeWithAggregatesFilter<"JO"> | Date | string
    canvass_id?: StringWithAggregatesFilter<"JO"> | string
    equipment?: StringWithAggregatesFilter<"JO"> | string
    classification_id?: StringNullableWithAggregatesFilter<"JO"> | string | null
    department_id?: StringWithAggregatesFilter<"JO"> | string
    supervisor_id?: StringWithAggregatesFilter<"JO"> | string
    status?: IntWithAggregatesFilter<"JO"> | number
    canceller_id?: StringNullableWithAggregatesFilter<"JO"> | string | null
    date_cancelled?: DateTimeNullableWithAggregatesFilter<"JO"> | Date | string | null
    is_referenced?: BoolWithAggregatesFilter<"JO"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"JO"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"JO"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"JO"> | boolean
  }

  export type JOApproverWhereInput = {
    AND?: JOApproverWhereInput | JOApproverWhereInput[]
    OR?: JOApproverWhereInput[]
    NOT?: JOApproverWhereInput | JOApproverWhereInput[]
    id?: StringFilter<"JOApprover"> | string
    jo_id?: StringFilter<"JOApprover"> | string
    approver_proxy_id?: StringNullableFilter<"JOApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"JOApprover"> | Date | string | null
    notes?: StringNullableFilter<"JOApprover"> | string | null
    status?: IntFilter<"JOApprover"> | number
    label?: StringFilter<"JOApprover"> | string
    order?: IntFilter<"JOApprover"> | number
    created_at?: DateTimeFilter<"JOApprover"> | Date | string
    updated_at?: DateTimeFilter<"JOApprover"> | Date | string
    is_deleted?: BoolFilter<"JOApprover"> | boolean
    jo?: XOR<JORelationFilter, JOWhereInput>
  }

  export type JOApproverOrderByWithRelationInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    jo?: JOOrderByWithRelationInput
  }

  export type JOApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JOApproverWhereInput | JOApproverWhereInput[]
    OR?: JOApproverWhereInput[]
    NOT?: JOApproverWhereInput | JOApproverWhereInput[]
    jo_id?: StringFilter<"JOApprover"> | string
    approver_proxy_id?: StringNullableFilter<"JOApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"JOApprover"> | Date | string | null
    notes?: StringNullableFilter<"JOApprover"> | string | null
    status?: IntFilter<"JOApprover"> | number
    label?: StringFilter<"JOApprover"> | string
    order?: IntFilter<"JOApprover"> | number
    created_at?: DateTimeFilter<"JOApprover"> | Date | string
    updated_at?: DateTimeFilter<"JOApprover"> | Date | string
    is_deleted?: BoolFilter<"JOApprover"> | boolean
    jo?: XOR<JORelationFilter, JOWhereInput>
  }, "id">

  export type JOApproverOrderByWithAggregationInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: JOApproverCountOrderByAggregateInput
    _avg?: JOApproverAvgOrderByAggregateInput
    _max?: JOApproverMaxOrderByAggregateInput
    _min?: JOApproverMinOrderByAggregateInput
    _sum?: JOApproverSumOrderByAggregateInput
  }

  export type JOApproverScalarWhereWithAggregatesInput = {
    AND?: JOApproverScalarWhereWithAggregatesInput | JOApproverScalarWhereWithAggregatesInput[]
    OR?: JOApproverScalarWhereWithAggregatesInput[]
    NOT?: JOApproverScalarWhereWithAggregatesInput | JOApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JOApprover"> | string
    jo_id?: StringWithAggregatesFilter<"JOApprover"> | string
    approver_proxy_id?: StringNullableWithAggregatesFilter<"JOApprover"> | string | null
    date_approval?: DateTimeNullableWithAggregatesFilter<"JOApprover"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"JOApprover"> | string | null
    status?: IntWithAggregatesFilter<"JOApprover"> | number
    label?: StringWithAggregatesFilter<"JOApprover"> | string
    order?: IntWithAggregatesFilter<"JOApprover"> | number
    created_at?: DateTimeWithAggregatesFilter<"JOApprover"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"JOApprover"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"JOApprover"> | boolean
  }

  export type RVWhereInput = {
    AND?: RVWhereInput | RVWhereInput[]
    OR?: RVWhereInput[]
    NOT?: RVWhereInput | RVWhereInput[]
    id?: StringFilter<"RV"> | string
    canvass_id?: StringFilter<"RV"> | string
    classification_id?: StringNullableFilter<"RV"> | string | null
    supervisor_id?: StringFilter<"RV"> | string
    canceller_id?: StringNullableFilter<"RV"> | string | null
    date_cancelled?: DateTimeNullableFilter<"RV"> | Date | string | null
    rv_number?: StringFilter<"RV"> | string
    date_requested?: DateTimeFilter<"RV"> | Date | string
    work_order_no?: StringNullableFilter<"RV"> | string | null
    work_order_date?: DateTimeNullableFilter<"RV"> | Date | string | null
    status?: IntFilter<"RV"> | number
    is_referenced?: BoolFilter<"RV"> | boolean
    created_at?: DateTimeFilter<"RV"> | Date | string
    updated_at?: DateTimeFilter<"RV"> | Date | string
    is_deleted?: BoolFilter<"RV"> | boolean
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    rv_approvers?: RVApproverListRelationFilter
  }

  export type RVOrderByWithRelationInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    rv_number?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrderInput | SortOrder
    work_order_date?: SortOrderInput | SortOrder
    status?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    canvass?: CanvassOrderByWithRelationInput
    meqs?: MEQSOrderByWithRelationInput
    rv_approvers?: RVApproverOrderByRelationAggregateInput
  }

  export type RVWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    canvass_id?: string
    rv_number?: string
    AND?: RVWhereInput | RVWhereInput[]
    OR?: RVWhereInput[]
    NOT?: RVWhereInput | RVWhereInput[]
    classification_id?: StringNullableFilter<"RV"> | string | null
    supervisor_id?: StringFilter<"RV"> | string
    canceller_id?: StringNullableFilter<"RV"> | string | null
    date_cancelled?: DateTimeNullableFilter<"RV"> | Date | string | null
    date_requested?: DateTimeFilter<"RV"> | Date | string
    work_order_no?: StringNullableFilter<"RV"> | string | null
    work_order_date?: DateTimeNullableFilter<"RV"> | Date | string | null
    status?: IntFilter<"RV"> | number
    is_referenced?: BoolFilter<"RV"> | boolean
    created_at?: DateTimeFilter<"RV"> | Date | string
    updated_at?: DateTimeFilter<"RV"> | Date | string
    is_deleted?: BoolFilter<"RV"> | boolean
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    rv_approvers?: RVApproverListRelationFilter
  }, "id" | "canvass_id" | "rv_number">

  export type RVOrderByWithAggregationInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    rv_number?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrderInput | SortOrder
    work_order_date?: SortOrderInput | SortOrder
    status?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: RVCountOrderByAggregateInput
    _avg?: RVAvgOrderByAggregateInput
    _max?: RVMaxOrderByAggregateInput
    _min?: RVMinOrderByAggregateInput
    _sum?: RVSumOrderByAggregateInput
  }

  export type RVScalarWhereWithAggregatesInput = {
    AND?: RVScalarWhereWithAggregatesInput | RVScalarWhereWithAggregatesInput[]
    OR?: RVScalarWhereWithAggregatesInput[]
    NOT?: RVScalarWhereWithAggregatesInput | RVScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RV"> | string
    canvass_id?: StringWithAggregatesFilter<"RV"> | string
    classification_id?: StringNullableWithAggregatesFilter<"RV"> | string | null
    supervisor_id?: StringWithAggregatesFilter<"RV"> | string
    canceller_id?: StringNullableWithAggregatesFilter<"RV"> | string | null
    date_cancelled?: DateTimeNullableWithAggregatesFilter<"RV"> | Date | string | null
    rv_number?: StringWithAggregatesFilter<"RV"> | string
    date_requested?: DateTimeWithAggregatesFilter<"RV"> | Date | string
    work_order_no?: StringNullableWithAggregatesFilter<"RV"> | string | null
    work_order_date?: DateTimeNullableWithAggregatesFilter<"RV"> | Date | string | null
    status?: IntWithAggregatesFilter<"RV"> | number
    is_referenced?: BoolWithAggregatesFilter<"RV"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"RV"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RV"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"RV"> | boolean
  }

  export type RVApproverWhereInput = {
    AND?: RVApproverWhereInput | RVApproverWhereInput[]
    OR?: RVApproverWhereInput[]
    NOT?: RVApproverWhereInput | RVApproverWhereInput[]
    id?: StringFilter<"RVApprover"> | string
    rv_id?: StringFilter<"RVApprover"> | string
    approver_id?: StringFilter<"RVApprover"> | string
    approver_proxy_id?: StringNullableFilter<"RVApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"RVApprover"> | Date | string | null
    notes?: StringNullableFilter<"RVApprover"> | string | null
    status?: IntFilter<"RVApprover"> | number
    label?: StringFilter<"RVApprover"> | string
    order?: IntFilter<"RVApprover"> | number
    created_at?: DateTimeFilter<"RVApprover"> | Date | string
    updated_at?: DateTimeFilter<"RVApprover"> | Date | string
    is_deleted?: BoolFilter<"RVApprover"> | boolean
    rv?: XOR<RVRelationFilter, RVWhereInput>
  }

  export type RVApproverOrderByWithRelationInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    rv?: RVOrderByWithRelationInput
  }

  export type RVApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RVApproverWhereInput | RVApproverWhereInput[]
    OR?: RVApproverWhereInput[]
    NOT?: RVApproverWhereInput | RVApproverWhereInput[]
    rv_id?: StringFilter<"RVApprover"> | string
    approver_id?: StringFilter<"RVApprover"> | string
    approver_proxy_id?: StringNullableFilter<"RVApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"RVApprover"> | Date | string | null
    notes?: StringNullableFilter<"RVApprover"> | string | null
    status?: IntFilter<"RVApprover"> | number
    label?: StringFilter<"RVApprover"> | string
    order?: IntFilter<"RVApprover"> | number
    created_at?: DateTimeFilter<"RVApprover"> | Date | string
    updated_at?: DateTimeFilter<"RVApprover"> | Date | string
    is_deleted?: BoolFilter<"RVApprover"> | boolean
    rv?: XOR<RVRelationFilter, RVWhereInput>
  }, "id">

  export type RVApproverOrderByWithAggregationInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: RVApproverCountOrderByAggregateInput
    _avg?: RVApproverAvgOrderByAggregateInput
    _max?: RVApproverMaxOrderByAggregateInput
    _min?: RVApproverMinOrderByAggregateInput
    _sum?: RVApproverSumOrderByAggregateInput
  }

  export type RVApproverScalarWhereWithAggregatesInput = {
    AND?: RVApproverScalarWhereWithAggregatesInput | RVApproverScalarWhereWithAggregatesInput[]
    OR?: RVApproverScalarWhereWithAggregatesInput[]
    NOT?: RVApproverScalarWhereWithAggregatesInput | RVApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RVApprover"> | string
    rv_id?: StringWithAggregatesFilter<"RVApprover"> | string
    approver_id?: StringWithAggregatesFilter<"RVApprover"> | string
    approver_proxy_id?: StringNullableWithAggregatesFilter<"RVApprover"> | string | null
    date_approval?: DateTimeNullableWithAggregatesFilter<"RVApprover"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"RVApprover"> | string | null
    status?: IntWithAggregatesFilter<"RVApprover"> | number
    label?: StringWithAggregatesFilter<"RVApprover"> | string
    order?: IntWithAggregatesFilter<"RVApprover"> | number
    created_at?: DateTimeWithAggregatesFilter<"RVApprover"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RVApprover"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"RVApprover"> | boolean
  }

  export type SPRWhereInput = {
    AND?: SPRWhereInput | SPRWhereInput[]
    OR?: SPRWhereInput[]
    NOT?: SPRWhereInput | SPRWhereInput[]
    id?: StringFilter<"SPR"> | string
    spr_number?: StringFilter<"SPR"> | string
    date_requested?: DateTimeFilter<"SPR"> | Date | string
    canvass_id?: StringFilter<"SPR"> | string
    vehicle_id?: StringFilter<"SPR"> | string
    classification_id?: StringNullableFilter<"SPR"> | string | null
    supervisor_id?: StringFilter<"SPR"> | string
    status?: IntFilter<"SPR"> | number
    canceller_id?: StringNullableFilter<"SPR"> | string | null
    date_cancelled?: DateTimeNullableFilter<"SPR"> | Date | string | null
    is_referenced?: BoolFilter<"SPR"> | boolean
    created_at?: DateTimeFilter<"SPR"> | Date | string
    updated_at?: DateTimeFilter<"SPR"> | Date | string
    is_deleted?: BoolFilter<"SPR"> | boolean
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    spr_approvers?: SPRApproverListRelationFilter
  }

  export type SPROrderByWithRelationInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    meqs?: MEQSOrderByWithRelationInput
    canvass?: CanvassOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    spr_approvers?: SPRApproverOrderByRelationAggregateInput
  }

  export type SPRWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    spr_number?: string
    canvass_id?: string
    AND?: SPRWhereInput | SPRWhereInput[]
    OR?: SPRWhereInput[]
    NOT?: SPRWhereInput | SPRWhereInput[]
    date_requested?: DateTimeFilter<"SPR"> | Date | string
    vehicle_id?: StringFilter<"SPR"> | string
    classification_id?: StringNullableFilter<"SPR"> | string | null
    supervisor_id?: StringFilter<"SPR"> | string
    status?: IntFilter<"SPR"> | number
    canceller_id?: StringNullableFilter<"SPR"> | string | null
    date_cancelled?: DateTimeNullableFilter<"SPR"> | Date | string | null
    is_referenced?: BoolFilter<"SPR"> | boolean
    created_at?: DateTimeFilter<"SPR"> | Date | string
    updated_at?: DateTimeFilter<"SPR"> | Date | string
    is_deleted?: BoolFilter<"SPR"> | boolean
    meqs?: XOR<MEQSNullableRelationFilter, MEQSWhereInput> | null
    canvass?: XOR<CanvassRelationFilter, CanvassWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    spr_approvers?: SPRApproverListRelationFilter
  }, "id" | "spr_number" | "canvass_id">

  export type SPROrderByWithAggregationInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrderInput | SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: SPRCountOrderByAggregateInput
    _avg?: SPRAvgOrderByAggregateInput
    _max?: SPRMaxOrderByAggregateInput
    _min?: SPRMinOrderByAggregateInput
    _sum?: SPRSumOrderByAggregateInput
  }

  export type SPRScalarWhereWithAggregatesInput = {
    AND?: SPRScalarWhereWithAggregatesInput | SPRScalarWhereWithAggregatesInput[]
    OR?: SPRScalarWhereWithAggregatesInput[]
    NOT?: SPRScalarWhereWithAggregatesInput | SPRScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SPR"> | string
    spr_number?: StringWithAggregatesFilter<"SPR"> | string
    date_requested?: DateTimeWithAggregatesFilter<"SPR"> | Date | string
    canvass_id?: StringWithAggregatesFilter<"SPR"> | string
    vehicle_id?: StringWithAggregatesFilter<"SPR"> | string
    classification_id?: StringNullableWithAggregatesFilter<"SPR"> | string | null
    supervisor_id?: StringWithAggregatesFilter<"SPR"> | string
    status?: IntWithAggregatesFilter<"SPR"> | number
    canceller_id?: StringNullableWithAggregatesFilter<"SPR"> | string | null
    date_cancelled?: DateTimeNullableWithAggregatesFilter<"SPR"> | Date | string | null
    is_referenced?: BoolWithAggregatesFilter<"SPR"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"SPR"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SPR"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"SPR"> | boolean
  }

  export type SPRApproverWhereInput = {
    AND?: SPRApproverWhereInput | SPRApproverWhereInput[]
    OR?: SPRApproverWhereInput[]
    NOT?: SPRApproverWhereInput | SPRApproverWhereInput[]
    id?: StringFilter<"SPRApprover"> | string
    spr_id?: StringFilter<"SPRApprover"> | string
    approver_id?: StringFilter<"SPRApprover"> | string
    approver_proxy_id?: StringNullableFilter<"SPRApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"SPRApprover"> | Date | string | null
    notes?: StringNullableFilter<"SPRApprover"> | string | null
    status?: IntFilter<"SPRApprover"> | number
    label?: StringFilter<"SPRApprover"> | string
    order?: IntFilter<"SPRApprover"> | number
    created_at?: DateTimeFilter<"SPRApprover"> | Date | string
    updated_at?: DateTimeFilter<"SPRApprover"> | Date | string
    is_deleted?: BoolFilter<"SPRApprover"> | boolean
    spr?: XOR<SPRRelationFilter, SPRWhereInput>
  }

  export type SPRApproverOrderByWithRelationInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    spr?: SPROrderByWithRelationInput
  }

  export type SPRApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SPRApproverWhereInput | SPRApproverWhereInput[]
    OR?: SPRApproverWhereInput[]
    NOT?: SPRApproverWhereInput | SPRApproverWhereInput[]
    spr_id?: StringFilter<"SPRApprover"> | string
    approver_id?: StringFilter<"SPRApprover"> | string
    approver_proxy_id?: StringNullableFilter<"SPRApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"SPRApprover"> | Date | string | null
    notes?: StringNullableFilter<"SPRApprover"> | string | null
    status?: IntFilter<"SPRApprover"> | number
    label?: StringFilter<"SPRApprover"> | string
    order?: IntFilter<"SPRApprover"> | number
    created_at?: DateTimeFilter<"SPRApprover"> | Date | string
    updated_at?: DateTimeFilter<"SPRApprover"> | Date | string
    is_deleted?: BoolFilter<"SPRApprover"> | boolean
    spr?: XOR<SPRRelationFilter, SPRWhereInput>
  }, "id">

  export type SPRApproverOrderByWithAggregationInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: SPRApproverCountOrderByAggregateInput
    _avg?: SPRApproverAvgOrderByAggregateInput
    _max?: SPRApproverMaxOrderByAggregateInput
    _min?: SPRApproverMinOrderByAggregateInput
    _sum?: SPRApproverSumOrderByAggregateInput
  }

  export type SPRApproverScalarWhereWithAggregatesInput = {
    AND?: SPRApproverScalarWhereWithAggregatesInput | SPRApproverScalarWhereWithAggregatesInput[]
    OR?: SPRApproverScalarWhereWithAggregatesInput[]
    NOT?: SPRApproverScalarWhereWithAggregatesInput | SPRApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SPRApprover"> | string
    spr_id?: StringWithAggregatesFilter<"SPRApprover"> | string
    approver_id?: StringWithAggregatesFilter<"SPRApprover"> | string
    approver_proxy_id?: StringNullableWithAggregatesFilter<"SPRApprover"> | string | null
    date_approval?: DateTimeNullableWithAggregatesFilter<"SPRApprover"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"SPRApprover"> | string | null
    status?: IntWithAggregatesFilter<"SPRApprover"> | number
    label?: StringWithAggregatesFilter<"SPRApprover"> | string
    order?: IntWithAggregatesFilter<"SPRApprover"> | number
    created_at?: DateTimeWithAggregatesFilter<"SPRApprover"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SPRApprover"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"SPRApprover"> | boolean
  }

  export type MEQSWhereInput = {
    AND?: MEQSWhereInput | MEQSWhereInput[]
    OR?: MEQSWhereInput[]
    NOT?: MEQSWhereInput | MEQSWhereInput[]
    id?: StringFilter<"MEQS"> | string
    jo_id?: StringNullableFilter<"MEQS"> | string | null
    rv_id?: StringNullableFilter<"MEQS"> | string | null
    spr_id?: StringNullableFilter<"MEQS"> | string | null
    meqs_number?: StringFilter<"MEQS"> | string
    request_type?: IntFilter<"MEQS"> | number
    meqs_date?: DateTimeFilter<"MEQS"> | Date | string
    status?: IntFilter<"MEQS"> | number
    notes?: StringNullableFilter<"MEQS"> | string | null
    canceller_id?: StringNullableFilter<"MEQS"> | string | null
    date_cancelled?: DateTimeNullableFilter<"MEQS"> | Date | string | null
    created_at?: DateTimeFilter<"MEQS"> | Date | string
    updated_at?: DateTimeFilter<"MEQS"> | Date | string
    is_deleted?: BoolFilter<"MEQS"> | boolean
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
    meqs_approvers?: MEQSApproverListRelationFilter
    meqs_suppliers?: MEQSSupplierListRelationFilter
  }

  export type MEQSOrderByWithRelationInput = {
    id?: SortOrder
    jo_id?: SortOrderInput | SortOrder
    rv_id?: SortOrderInput | SortOrder
    spr_id?: SortOrderInput | SortOrder
    meqs_number?: SortOrder
    request_type?: SortOrder
    meqs_date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    jo?: JOOrderByWithRelationInput
    rv?: RVOrderByWithRelationInput
    spr?: SPROrderByWithRelationInput
    meqs_approvers?: MEQSApproverOrderByRelationAggregateInput
    meqs_suppliers?: MEQSSupplierOrderByRelationAggregateInput
  }

  export type MEQSWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jo_id?: string
    rv_id?: string
    spr_id?: string
    meqs_number?: string
    AND?: MEQSWhereInput | MEQSWhereInput[]
    OR?: MEQSWhereInput[]
    NOT?: MEQSWhereInput | MEQSWhereInput[]
    request_type?: IntFilter<"MEQS"> | number
    meqs_date?: DateTimeFilter<"MEQS"> | Date | string
    status?: IntFilter<"MEQS"> | number
    notes?: StringNullableFilter<"MEQS"> | string | null
    canceller_id?: StringNullableFilter<"MEQS"> | string | null
    date_cancelled?: DateTimeNullableFilter<"MEQS"> | Date | string | null
    created_at?: DateTimeFilter<"MEQS"> | Date | string
    updated_at?: DateTimeFilter<"MEQS"> | Date | string
    is_deleted?: BoolFilter<"MEQS"> | boolean
    jo?: XOR<JONullableRelationFilter, JOWhereInput> | null
    rv?: XOR<RVNullableRelationFilter, RVWhereInput> | null
    spr?: XOR<SPRNullableRelationFilter, SPRWhereInput> | null
    meqs_approvers?: MEQSApproverListRelationFilter
    meqs_suppliers?: MEQSSupplierListRelationFilter
  }, "id" | "jo_id" | "rv_id" | "spr_id" | "meqs_number">

  export type MEQSOrderByWithAggregationInput = {
    id?: SortOrder
    jo_id?: SortOrderInput | SortOrder
    rv_id?: SortOrderInput | SortOrder
    spr_id?: SortOrderInput | SortOrder
    meqs_number?: SortOrder
    request_type?: SortOrder
    meqs_date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: MEQSCountOrderByAggregateInput
    _avg?: MEQSAvgOrderByAggregateInput
    _max?: MEQSMaxOrderByAggregateInput
    _min?: MEQSMinOrderByAggregateInput
    _sum?: MEQSSumOrderByAggregateInput
  }

  export type MEQSScalarWhereWithAggregatesInput = {
    AND?: MEQSScalarWhereWithAggregatesInput | MEQSScalarWhereWithAggregatesInput[]
    OR?: MEQSScalarWhereWithAggregatesInput[]
    NOT?: MEQSScalarWhereWithAggregatesInput | MEQSScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQS"> | string
    jo_id?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    rv_id?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    spr_id?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    meqs_number?: StringWithAggregatesFilter<"MEQS"> | string
    request_type?: IntWithAggregatesFilter<"MEQS"> | number
    meqs_date?: DateTimeWithAggregatesFilter<"MEQS"> | Date | string
    status?: IntWithAggregatesFilter<"MEQS"> | number
    notes?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    canceller_id?: StringNullableWithAggregatesFilter<"MEQS"> | string | null
    date_cancelled?: DateTimeNullableWithAggregatesFilter<"MEQS"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"MEQS"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MEQS"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"MEQS"> | boolean
  }

  export type MEQSSupplierWhereInput = {
    AND?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    OR?: MEQSSupplierWhereInput[]
    NOT?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    id?: StringFilter<"MEQSSupplier"> | string
    meqs_id?: StringFilter<"MEQSSupplier"> | string
    supplier_id?: StringFilter<"MEQSSupplier"> | string
    payment_terms?: StringFilter<"MEQSSupplier"> | string
    is_referenced?: BoolFilter<"MEQSSupplier"> | boolean
    created_at?: DateTimeFilter<"MEQSSupplier"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplier"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplier"> | boolean
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    attachments?: MEQSSupplierAttachmentListRelationFilter
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
    po?: XOR<PONullableRelationFilter, POWhereInput> | null
  }

  export type MEQSSupplierOrderByWithRelationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    meqs?: MEQSOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    attachments?: MEQSSupplierAttachmentOrderByRelationAggregateInput
    meqs_supplier_items?: MEQSSupplierItemOrderByRelationAggregateInput
    po?: POOrderByWithRelationInput
  }

  export type MEQSSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    OR?: MEQSSupplierWhereInput[]
    NOT?: MEQSSupplierWhereInput | MEQSSupplierWhereInput[]
    meqs_id?: StringFilter<"MEQSSupplier"> | string
    supplier_id?: StringFilter<"MEQSSupplier"> | string
    payment_terms?: StringFilter<"MEQSSupplier"> | string
    is_referenced?: BoolFilter<"MEQSSupplier"> | boolean
    created_at?: DateTimeFilter<"MEQSSupplier"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplier"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplier"> | boolean
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    attachments?: MEQSSupplierAttachmentListRelationFilter
    meqs_supplier_items?: MEQSSupplierItemListRelationFilter
    po?: XOR<PONullableRelationFilter, POWhereInput> | null
  }, "id">

  export type MEQSSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: MEQSSupplierCountOrderByAggregateInput
    _max?: MEQSSupplierMaxOrderByAggregateInput
    _min?: MEQSSupplierMinOrderByAggregateInput
  }

  export type MEQSSupplierScalarWhereWithAggregatesInput = {
    AND?: MEQSSupplierScalarWhereWithAggregatesInput | MEQSSupplierScalarWhereWithAggregatesInput[]
    OR?: MEQSSupplierScalarWhereWithAggregatesInput[]
    NOT?: MEQSSupplierScalarWhereWithAggregatesInput | MEQSSupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    meqs_id?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    supplier_id?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    payment_terms?: StringWithAggregatesFilter<"MEQSSupplier"> | string
    is_referenced?: BoolWithAggregatesFilter<"MEQSSupplier"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"MEQSSupplier"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MEQSSupplier"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"MEQSSupplier"> | boolean
  }

  export type MEQSSupplierItemWhereInput = {
    AND?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    OR?: MEQSSupplierItemWhereInput[]
    NOT?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    id?: StringFilter<"MEQSSupplierItem"> | string
    canvass_item_id?: StringFilter<"MEQSSupplierItem"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierItem"> | string
    price?: FloatFilter<"MEQSSupplierItem"> | number
    is_awarded?: BoolFilter<"MEQSSupplierItem"> | boolean
    notes?: StringNullableFilter<"MEQSSupplierItem"> | string | null
    vat_type?: IntFilter<"MEQSSupplierItem"> | number
    created_at?: DateTimeFilter<"MEQSSupplierItem"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplierItem"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplierItem"> | boolean
    canvass_item?: XOR<CanvassItemRelationFilter, CanvassItemWhereInput>
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
  }

  export type MEQSSupplierItemOrderByWithRelationInput = {
    id?: SortOrder
    canvass_item_id?: SortOrder
    meqs_supplier_id?: SortOrder
    price?: SortOrder
    is_awarded?: SortOrder
    notes?: SortOrderInput | SortOrder
    vat_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    canvass_item?: CanvassItemOrderByWithRelationInput
    meqs_supplier?: MEQSSupplierOrderByWithRelationInput
  }

  export type MEQSSupplierItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    OR?: MEQSSupplierItemWhereInput[]
    NOT?: MEQSSupplierItemWhereInput | MEQSSupplierItemWhereInput[]
    canvass_item_id?: StringFilter<"MEQSSupplierItem"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierItem"> | string
    price?: FloatFilter<"MEQSSupplierItem"> | number
    is_awarded?: BoolFilter<"MEQSSupplierItem"> | boolean
    notes?: StringNullableFilter<"MEQSSupplierItem"> | string | null
    vat_type?: IntFilter<"MEQSSupplierItem"> | number
    created_at?: DateTimeFilter<"MEQSSupplierItem"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplierItem"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplierItem"> | boolean
    canvass_item?: XOR<CanvassItemRelationFilter, CanvassItemWhereInput>
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
  }, "id">

  export type MEQSSupplierItemOrderByWithAggregationInput = {
    id?: SortOrder
    canvass_item_id?: SortOrder
    meqs_supplier_id?: SortOrder
    price?: SortOrder
    is_awarded?: SortOrder
    notes?: SortOrderInput | SortOrder
    vat_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: MEQSSupplierItemCountOrderByAggregateInput
    _avg?: MEQSSupplierItemAvgOrderByAggregateInput
    _max?: MEQSSupplierItemMaxOrderByAggregateInput
    _min?: MEQSSupplierItemMinOrderByAggregateInput
    _sum?: MEQSSupplierItemSumOrderByAggregateInput
  }

  export type MEQSSupplierItemScalarWhereWithAggregatesInput = {
    AND?: MEQSSupplierItemScalarWhereWithAggregatesInput | MEQSSupplierItemScalarWhereWithAggregatesInput[]
    OR?: MEQSSupplierItemScalarWhereWithAggregatesInput[]
    NOT?: MEQSSupplierItemScalarWhereWithAggregatesInput | MEQSSupplierItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSSupplierItem"> | string
    canvass_item_id?: StringWithAggregatesFilter<"MEQSSupplierItem"> | string
    meqs_supplier_id?: StringWithAggregatesFilter<"MEQSSupplierItem"> | string
    price?: FloatWithAggregatesFilter<"MEQSSupplierItem"> | number
    is_awarded?: BoolWithAggregatesFilter<"MEQSSupplierItem"> | boolean
    notes?: StringNullableWithAggregatesFilter<"MEQSSupplierItem"> | string | null
    vat_type?: IntWithAggregatesFilter<"MEQSSupplierItem"> | number
    created_at?: DateTimeWithAggregatesFilter<"MEQSSupplierItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MEQSSupplierItem"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"MEQSSupplierItem"> | boolean
  }

  export type MEQSSupplierAttachmentWhereInput = {
    AND?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    OR?: MEQSSupplierAttachmentWhereInput[]
    NOT?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    id?: StringFilter<"MEQSSupplierAttachment"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierAttachment"> | string
    src?: StringFilter<"MEQSSupplierAttachment"> | string
    created_at?: DateTimeFilter<"MEQSSupplierAttachment"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplierAttachment"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplierAttachment"> | boolean
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
  }

  export type MEQSSupplierAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    src?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    meqs_supplier?: MEQSSupplierOrderByWithRelationInput
  }

  export type MEQSSupplierAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    OR?: MEQSSupplierAttachmentWhereInput[]
    NOT?: MEQSSupplierAttachmentWhereInput | MEQSSupplierAttachmentWhereInput[]
    meqs_supplier_id?: StringFilter<"MEQSSupplierAttachment"> | string
    src?: StringFilter<"MEQSSupplierAttachment"> | string
    created_at?: DateTimeFilter<"MEQSSupplierAttachment"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplierAttachment"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplierAttachment"> | boolean
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
  }, "id">

  export type MEQSSupplierAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    src?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: MEQSSupplierAttachmentCountOrderByAggregateInput
    _max?: MEQSSupplierAttachmentMaxOrderByAggregateInput
    _min?: MEQSSupplierAttachmentMinOrderByAggregateInput
  }

  export type MEQSSupplierAttachmentScalarWhereWithAggregatesInput = {
    AND?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput | MEQSSupplierAttachmentScalarWhereWithAggregatesInput[]
    OR?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MEQSSupplierAttachmentScalarWhereWithAggregatesInput | MEQSSupplierAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSSupplierAttachment"> | string
    meqs_supplier_id?: StringWithAggregatesFilter<"MEQSSupplierAttachment"> | string
    src?: StringWithAggregatesFilter<"MEQSSupplierAttachment"> | string
    created_at?: DateTimeWithAggregatesFilter<"MEQSSupplierAttachment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MEQSSupplierAttachment"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"MEQSSupplierAttachment"> | boolean
  }

  export type MEQSApproverWhereInput = {
    AND?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    OR?: MEQSApproverWhereInput[]
    NOT?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    id?: StringFilter<"MEQSApprover"> | string
    meqs_id?: StringFilter<"MEQSApprover"> | string
    approver_id?: StringFilter<"MEQSApprover"> | string
    approver_proxy_id?: StringNullableFilter<"MEQSApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"MEQSApprover"> | Date | string | null
    notes?: StringNullableFilter<"MEQSApprover"> | string | null
    status?: IntFilter<"MEQSApprover"> | number
    label?: StringFilter<"MEQSApprover"> | string
    order?: IntFilter<"MEQSApprover"> | number
    created_at?: DateTimeFilter<"MEQSApprover"> | Date | string
    updated_at?: DateTimeFilter<"MEQSApprover"> | Date | string
    is_deleted?: BoolFilter<"MEQSApprover"> | boolean
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
  }

  export type MEQSApproverOrderByWithRelationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    meqs?: MEQSOrderByWithRelationInput
  }

  export type MEQSApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    OR?: MEQSApproverWhereInput[]
    NOT?: MEQSApproverWhereInput | MEQSApproverWhereInput[]
    meqs_id?: StringFilter<"MEQSApprover"> | string
    approver_id?: StringFilter<"MEQSApprover"> | string
    approver_proxy_id?: StringNullableFilter<"MEQSApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"MEQSApprover"> | Date | string | null
    notes?: StringNullableFilter<"MEQSApprover"> | string | null
    status?: IntFilter<"MEQSApprover"> | number
    label?: StringFilter<"MEQSApprover"> | string
    order?: IntFilter<"MEQSApprover"> | number
    created_at?: DateTimeFilter<"MEQSApprover"> | Date | string
    updated_at?: DateTimeFilter<"MEQSApprover"> | Date | string
    is_deleted?: BoolFilter<"MEQSApprover"> | boolean
    meqs?: XOR<MEQSRelationFilter, MEQSWhereInput>
  }, "id">

  export type MEQSApproverOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: MEQSApproverCountOrderByAggregateInput
    _avg?: MEQSApproverAvgOrderByAggregateInput
    _max?: MEQSApproverMaxOrderByAggregateInput
    _min?: MEQSApproverMinOrderByAggregateInput
    _sum?: MEQSApproverSumOrderByAggregateInput
  }

  export type MEQSApproverScalarWhereWithAggregatesInput = {
    AND?: MEQSApproverScalarWhereWithAggregatesInput | MEQSApproverScalarWhereWithAggregatesInput[]
    OR?: MEQSApproverScalarWhereWithAggregatesInput[]
    NOT?: MEQSApproverScalarWhereWithAggregatesInput | MEQSApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MEQSApprover"> | string
    meqs_id?: StringWithAggregatesFilter<"MEQSApprover"> | string
    approver_id?: StringWithAggregatesFilter<"MEQSApprover"> | string
    approver_proxy_id?: StringNullableWithAggregatesFilter<"MEQSApprover"> | string | null
    date_approval?: DateTimeNullableWithAggregatesFilter<"MEQSApprover"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"MEQSApprover"> | string | null
    status?: IntWithAggregatesFilter<"MEQSApprover"> | number
    label?: StringWithAggregatesFilter<"MEQSApprover"> | string
    order?: IntWithAggregatesFilter<"MEQSApprover"> | number
    created_at?: DateTimeWithAggregatesFilter<"MEQSApprover"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MEQSApprover"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"MEQSApprover"> | boolean
  }

  export type POWhereInput = {
    AND?: POWhereInput | POWhereInput[]
    OR?: POWhereInput[]
    NOT?: POWhereInput | POWhereInput[]
    id?: StringFilter<"PO"> | string
    meqs_supplier_id?: StringFilter<"PO"> | string
    po_number?: StringFilter<"PO"> | string
    po_date?: DateTimeFilter<"PO"> | Date | string
    status?: IntFilter<"PO"> | number
    canceller_id?: StringNullableFilter<"PO"> | string | null
    date_cancelled?: DateTimeNullableFilter<"PO"> | Date | string | null
    created_at?: DateTimeFilter<"PO"> | Date | string
    updated_at?: DateTimeFilter<"PO"> | Date | string
    is_deleted?: BoolFilter<"PO"> | boolean
    is_referenced?: BoolFilter<"PO"> | boolean
    po_approvers?: POApproverListRelationFilter
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
    rr?: XOR<RRNullableRelationFilter, RRWhereInput> | null
  }

  export type POOrderByWithRelationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    po_number?: SortOrder
    po_date?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    is_referenced?: SortOrder
    po_approvers?: POApproverOrderByRelationAggregateInput
    meqs_supplier?: MEQSSupplierOrderByWithRelationInput
    rr?: RROrderByWithRelationInput
  }

  export type POWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    meqs_supplier_id?: string
    po_number?: string
    AND?: POWhereInput | POWhereInput[]
    OR?: POWhereInput[]
    NOT?: POWhereInput | POWhereInput[]
    po_date?: DateTimeFilter<"PO"> | Date | string
    status?: IntFilter<"PO"> | number
    canceller_id?: StringNullableFilter<"PO"> | string | null
    date_cancelled?: DateTimeNullableFilter<"PO"> | Date | string | null
    created_at?: DateTimeFilter<"PO"> | Date | string
    updated_at?: DateTimeFilter<"PO"> | Date | string
    is_deleted?: BoolFilter<"PO"> | boolean
    is_referenced?: BoolFilter<"PO"> | boolean
    po_approvers?: POApproverListRelationFilter
    meqs_supplier?: XOR<MEQSSupplierRelationFilter, MEQSSupplierWhereInput>
    rr?: XOR<RRNullableRelationFilter, RRWhereInput> | null
  }, "id" | "meqs_supplier_id" | "po_number">

  export type POOrderByWithAggregationInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    po_number?: SortOrder
    po_date?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    is_referenced?: SortOrder
    _count?: POCountOrderByAggregateInput
    _avg?: POAvgOrderByAggregateInput
    _max?: POMaxOrderByAggregateInput
    _min?: POMinOrderByAggregateInput
    _sum?: POSumOrderByAggregateInput
  }

  export type POScalarWhereWithAggregatesInput = {
    AND?: POScalarWhereWithAggregatesInput | POScalarWhereWithAggregatesInput[]
    OR?: POScalarWhereWithAggregatesInput[]
    NOT?: POScalarWhereWithAggregatesInput | POScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PO"> | string
    meqs_supplier_id?: StringWithAggregatesFilter<"PO"> | string
    po_number?: StringWithAggregatesFilter<"PO"> | string
    po_date?: DateTimeWithAggregatesFilter<"PO"> | Date | string
    status?: IntWithAggregatesFilter<"PO"> | number
    canceller_id?: StringNullableWithAggregatesFilter<"PO"> | string | null
    date_cancelled?: DateTimeNullableWithAggregatesFilter<"PO"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"PO"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PO"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"PO"> | boolean
    is_referenced?: BoolWithAggregatesFilter<"PO"> | boolean
  }

  export type POApproverWhereInput = {
    AND?: POApproverWhereInput | POApproverWhereInput[]
    OR?: POApproverWhereInput[]
    NOT?: POApproverWhereInput | POApproverWhereInput[]
    id?: StringFilter<"POApprover"> | string
    po_id?: StringFilter<"POApprover"> | string
    approver_id?: StringFilter<"POApprover"> | string
    approver_proxy_id?: StringNullableFilter<"POApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"POApprover"> | Date | string | null
    notes?: StringNullableFilter<"POApprover"> | string | null
    status?: IntFilter<"POApprover"> | number
    label?: StringFilter<"POApprover"> | string
    order?: IntFilter<"POApprover"> | number
    created_at?: DateTimeFilter<"POApprover"> | Date | string
    updated_at?: DateTimeFilter<"POApprover"> | Date | string
    is_deleted?: BoolFilter<"POApprover"> | boolean
    po?: XOR<PORelationFilter, POWhereInput>
  }

  export type POApproverOrderByWithRelationInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    po?: POOrderByWithRelationInput
  }

  export type POApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: POApproverWhereInput | POApproverWhereInput[]
    OR?: POApproverWhereInput[]
    NOT?: POApproverWhereInput | POApproverWhereInput[]
    po_id?: StringFilter<"POApprover"> | string
    approver_id?: StringFilter<"POApprover"> | string
    approver_proxy_id?: StringNullableFilter<"POApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"POApprover"> | Date | string | null
    notes?: StringNullableFilter<"POApprover"> | string | null
    status?: IntFilter<"POApprover"> | number
    label?: StringFilter<"POApprover"> | string
    order?: IntFilter<"POApprover"> | number
    created_at?: DateTimeFilter<"POApprover"> | Date | string
    updated_at?: DateTimeFilter<"POApprover"> | Date | string
    is_deleted?: BoolFilter<"POApprover"> | boolean
    po?: XOR<PORelationFilter, POWhereInput>
  }, "id">

  export type POApproverOrderByWithAggregationInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: POApproverCountOrderByAggregateInput
    _avg?: POApproverAvgOrderByAggregateInput
    _max?: POApproverMaxOrderByAggregateInput
    _min?: POApproverMinOrderByAggregateInput
    _sum?: POApproverSumOrderByAggregateInput
  }

  export type POApproverScalarWhereWithAggregatesInput = {
    AND?: POApproverScalarWhereWithAggregatesInput | POApproverScalarWhereWithAggregatesInput[]
    OR?: POApproverScalarWhereWithAggregatesInput[]
    NOT?: POApproverScalarWhereWithAggregatesInput | POApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"POApprover"> | string
    po_id?: StringWithAggregatesFilter<"POApprover"> | string
    approver_id?: StringWithAggregatesFilter<"POApprover"> | string
    approver_proxy_id?: StringNullableWithAggregatesFilter<"POApprover"> | string | null
    date_approval?: DateTimeNullableWithAggregatesFilter<"POApprover"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"POApprover"> | string | null
    status?: IntWithAggregatesFilter<"POApprover"> | number
    label?: StringWithAggregatesFilter<"POApprover"> | string
    order?: IntWithAggregatesFilter<"POApprover"> | number
    created_at?: DateTimeWithAggregatesFilter<"POApprover"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"POApprover"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"POApprover"> | boolean
  }

  export type RRWhereInput = {
    AND?: RRWhereInput | RRWhereInput[]
    OR?: RRWhereInput[]
    NOT?: RRWhereInput | RRWhereInput[]
    id?: StringFilter<"RR"> | string
    po_id?: StringFilter<"RR"> | string
    rr_number?: StringFilter<"RR"> | string
    rr_date?: DateTimeFilter<"RR"> | Date | string
    received_by_id?: StringFilter<"RR"> | string
    canceller_id?: StringNullableFilter<"RR"> | string | null
    date_cancelled?: DateTimeNullableFilter<"RR"> | Date | string | null
    invoice_number?: StringFilter<"RR"> | string
    delivery_number?: StringNullableFilter<"RR"> | string | null
    notes?: StringNullableFilter<"RR"> | string | null
    delivery_charge?: FloatFilter<"RR"> | number
    status?: IntFilter<"RR"> | number
    created_at?: DateTimeFilter<"RR"> | Date | string
    updated_at?: DateTimeFilter<"RR"> | Date | string
    is_deleted?: BoolFilter<"RR"> | boolean
    po?: XOR<PORelationFilter, POWhereInput>
    rr_approvers?: RRApproverListRelationFilter
    rr_items?: RRItemListRelationFilter
  }

  export type RROrderByWithRelationInput = {
    id?: SortOrder
    po_id?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    delivery_charge?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    po?: POOrderByWithRelationInput
    rr_approvers?: RRApproverOrderByRelationAggregateInput
    rr_items?: RRItemOrderByRelationAggregateInput
  }

  export type RRWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    po_id?: string
    rr_number?: string
    AND?: RRWhereInput | RRWhereInput[]
    OR?: RRWhereInput[]
    NOT?: RRWhereInput | RRWhereInput[]
    rr_date?: DateTimeFilter<"RR"> | Date | string
    received_by_id?: StringFilter<"RR"> | string
    canceller_id?: StringNullableFilter<"RR"> | string | null
    date_cancelled?: DateTimeNullableFilter<"RR"> | Date | string | null
    invoice_number?: StringFilter<"RR"> | string
    delivery_number?: StringNullableFilter<"RR"> | string | null
    notes?: StringNullableFilter<"RR"> | string | null
    delivery_charge?: FloatFilter<"RR"> | number
    status?: IntFilter<"RR"> | number
    created_at?: DateTimeFilter<"RR"> | Date | string
    updated_at?: DateTimeFilter<"RR"> | Date | string
    is_deleted?: BoolFilter<"RR"> | boolean
    po?: XOR<PORelationFilter, POWhereInput>
    rr_approvers?: RRApproverListRelationFilter
    rr_items?: RRItemListRelationFilter
  }, "id" | "po_id" | "rr_number">

  export type RROrderByWithAggregationInput = {
    id?: SortOrder
    po_id?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    canceller_id?: SortOrderInput | SortOrder
    date_cancelled?: SortOrderInput | SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    delivery_charge?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: RRCountOrderByAggregateInput
    _avg?: RRAvgOrderByAggregateInput
    _max?: RRMaxOrderByAggregateInput
    _min?: RRMinOrderByAggregateInput
    _sum?: RRSumOrderByAggregateInput
  }

  export type RRScalarWhereWithAggregatesInput = {
    AND?: RRScalarWhereWithAggregatesInput | RRScalarWhereWithAggregatesInput[]
    OR?: RRScalarWhereWithAggregatesInput[]
    NOT?: RRScalarWhereWithAggregatesInput | RRScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RR"> | string
    po_id?: StringWithAggregatesFilter<"RR"> | string
    rr_number?: StringWithAggregatesFilter<"RR"> | string
    rr_date?: DateTimeWithAggregatesFilter<"RR"> | Date | string
    received_by_id?: StringWithAggregatesFilter<"RR"> | string
    canceller_id?: StringNullableWithAggregatesFilter<"RR"> | string | null
    date_cancelled?: DateTimeNullableWithAggregatesFilter<"RR"> | Date | string | null
    invoice_number?: StringWithAggregatesFilter<"RR"> | string
    delivery_number?: StringNullableWithAggregatesFilter<"RR"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RR"> | string | null
    delivery_charge?: FloatWithAggregatesFilter<"RR"> | number
    status?: IntWithAggregatesFilter<"RR"> | number
    created_at?: DateTimeWithAggregatesFilter<"RR"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RR"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"RR"> | boolean
  }

  export type RRApproverWhereInput = {
    AND?: RRApproverWhereInput | RRApproverWhereInput[]
    OR?: RRApproverWhereInput[]
    NOT?: RRApproverWhereInput | RRApproverWhereInput[]
    id?: StringFilter<"RRApprover"> | string
    rr_id?: StringFilter<"RRApprover"> | string
    approver_id?: StringFilter<"RRApprover"> | string
    approver_proxy_id?: StringNullableFilter<"RRApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"RRApprover"> | Date | string | null
    notes?: StringNullableFilter<"RRApprover"> | string | null
    status?: IntFilter<"RRApprover"> | number
    label?: StringFilter<"RRApprover"> | string
    order?: IntFilter<"RRApprover"> | number
    created_at?: DateTimeFilter<"RRApprover"> | Date | string
    updated_at?: DateTimeFilter<"RRApprover"> | Date | string
    is_deleted?: BoolFilter<"RRApprover"> | boolean
    rr?: XOR<RRRelationFilter, RRWhereInput>
  }

  export type RRApproverOrderByWithRelationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    rr?: RROrderByWithRelationInput
  }

  export type RRApproverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RRApproverWhereInput | RRApproverWhereInput[]
    OR?: RRApproverWhereInput[]
    NOT?: RRApproverWhereInput | RRApproverWhereInput[]
    rr_id?: StringFilter<"RRApprover"> | string
    approver_id?: StringFilter<"RRApprover"> | string
    approver_proxy_id?: StringNullableFilter<"RRApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"RRApprover"> | Date | string | null
    notes?: StringNullableFilter<"RRApprover"> | string | null
    status?: IntFilter<"RRApprover"> | number
    label?: StringFilter<"RRApprover"> | string
    order?: IntFilter<"RRApprover"> | number
    created_at?: DateTimeFilter<"RRApprover"> | Date | string
    updated_at?: DateTimeFilter<"RRApprover"> | Date | string
    is_deleted?: BoolFilter<"RRApprover"> | boolean
    rr?: XOR<RRRelationFilter, RRWhereInput>
  }, "id">

  export type RRApproverOrderByWithAggregationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrderInput | SortOrder
    date_approval?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: RRApproverCountOrderByAggregateInput
    _avg?: RRApproverAvgOrderByAggregateInput
    _max?: RRApproverMaxOrderByAggregateInput
    _min?: RRApproverMinOrderByAggregateInput
    _sum?: RRApproverSumOrderByAggregateInput
  }

  export type RRApproverScalarWhereWithAggregatesInput = {
    AND?: RRApproverScalarWhereWithAggregatesInput | RRApproverScalarWhereWithAggregatesInput[]
    OR?: RRApproverScalarWhereWithAggregatesInput[]
    NOT?: RRApproverScalarWhereWithAggregatesInput | RRApproverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RRApprover"> | string
    rr_id?: StringWithAggregatesFilter<"RRApprover"> | string
    approver_id?: StringWithAggregatesFilter<"RRApprover"> | string
    approver_proxy_id?: StringNullableWithAggregatesFilter<"RRApprover"> | string | null
    date_approval?: DateTimeNullableWithAggregatesFilter<"RRApprover"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"RRApprover"> | string | null
    status?: IntWithAggregatesFilter<"RRApprover"> | number
    label?: StringWithAggregatesFilter<"RRApprover"> | string
    order?: IntWithAggregatesFilter<"RRApprover"> | number
    created_at?: DateTimeWithAggregatesFilter<"RRApprover"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RRApprover"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"RRApprover"> | boolean
  }

  export type RRItemWhereInput = {
    AND?: RRItemWhereInput | RRItemWhereInput[]
    OR?: RRItemWhereInput[]
    NOT?: RRItemWhereInput | RRItemWhereInput[]
    id?: StringFilter<"RRItem"> | string
    rr_id?: StringFilter<"RRItem"> | string
    item_id?: StringNullableFilter<"RRItem"> | string | null
    item_brand_id?: StringNullableFilter<"RRItem"> | string | null
    unit_id?: StringNullableFilter<"RRItem"> | string | null
    item_class?: IntFilter<"RRItem"> | number
    quantity_delivered?: IntFilter<"RRItem"> | number
    quantity_accepted?: IntFilter<"RRItem"> | number
    description?: StringFilter<"RRItem"> | string
    vat_type?: IntFilter<"RRItem"> | number
    gross_price?: FloatFilter<"RRItem"> | number
    net_price?: FloatFilter<"RRItem"> | number
    vat_amount?: FloatFilter<"RRItem"> | number
    created_at?: DateTimeFilter<"RRItem"> | Date | string
    updated_at?: DateTimeFilter<"RRItem"> | Date | string
    is_deleted?: BoolFilter<"RRItem"> | boolean
    rr?: XOR<RRRelationFilter, RRWhereInput>
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
    item_brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }

  export type RRItemOrderByWithRelationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    item_id?: SortOrderInput | SortOrder
    item_brand_id?: SortOrderInput | SortOrder
    unit_id?: SortOrderInput | SortOrder
    item_class?: SortOrder
    quantity_delivered?: SortOrder
    quantity_accepted?: SortOrder
    description?: SortOrder
    vat_type?: SortOrder
    gross_price?: SortOrder
    net_price?: SortOrder
    vat_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    rr?: RROrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    item_brand?: BrandOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    item_transaction?: ItemTransactionOrderByWithRelationInput
  }

  export type RRItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RRItemWhereInput | RRItemWhereInput[]
    OR?: RRItemWhereInput[]
    NOT?: RRItemWhereInput | RRItemWhereInput[]
    rr_id?: StringFilter<"RRItem"> | string
    item_id?: StringNullableFilter<"RRItem"> | string | null
    item_brand_id?: StringNullableFilter<"RRItem"> | string | null
    unit_id?: StringNullableFilter<"RRItem"> | string | null
    item_class?: IntFilter<"RRItem"> | number
    quantity_delivered?: IntFilter<"RRItem"> | number
    quantity_accepted?: IntFilter<"RRItem"> | number
    description?: StringFilter<"RRItem"> | string
    vat_type?: IntFilter<"RRItem"> | number
    gross_price?: FloatFilter<"RRItem"> | number
    net_price?: FloatFilter<"RRItem"> | number
    vat_amount?: FloatFilter<"RRItem"> | number
    created_at?: DateTimeFilter<"RRItem"> | Date | string
    updated_at?: DateTimeFilter<"RRItem"> | Date | string
    is_deleted?: BoolFilter<"RRItem"> | boolean
    rr?: XOR<RRRelationFilter, RRWhereInput>
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
    item_brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    item_transaction?: XOR<ItemTransactionNullableRelationFilter, ItemTransactionWhereInput> | null
  }, "id">

  export type RRItemOrderByWithAggregationInput = {
    id?: SortOrder
    rr_id?: SortOrder
    item_id?: SortOrderInput | SortOrder
    item_brand_id?: SortOrderInput | SortOrder
    unit_id?: SortOrderInput | SortOrder
    item_class?: SortOrder
    quantity_delivered?: SortOrder
    quantity_accepted?: SortOrder
    description?: SortOrder
    vat_type?: SortOrder
    gross_price?: SortOrder
    net_price?: SortOrder
    vat_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: RRItemCountOrderByAggregateInput
    _avg?: RRItemAvgOrderByAggregateInput
    _max?: RRItemMaxOrderByAggregateInput
    _min?: RRItemMinOrderByAggregateInput
    _sum?: RRItemSumOrderByAggregateInput
  }

  export type RRItemScalarWhereWithAggregatesInput = {
    AND?: RRItemScalarWhereWithAggregatesInput | RRItemScalarWhereWithAggregatesInput[]
    OR?: RRItemScalarWhereWithAggregatesInput[]
    NOT?: RRItemScalarWhereWithAggregatesInput | RRItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RRItem"> | string
    rr_id?: StringWithAggregatesFilter<"RRItem"> | string
    item_id?: StringNullableWithAggregatesFilter<"RRItem"> | string | null
    item_brand_id?: StringNullableWithAggregatesFilter<"RRItem"> | string | null
    unit_id?: StringNullableWithAggregatesFilter<"RRItem"> | string | null
    item_class?: IntWithAggregatesFilter<"RRItem"> | number
    quantity_delivered?: IntWithAggregatesFilter<"RRItem"> | number
    quantity_accepted?: IntWithAggregatesFilter<"RRItem"> | number
    description?: StringWithAggregatesFilter<"RRItem"> | string
    vat_type?: IntWithAggregatesFilter<"RRItem"> | number
    gross_price?: FloatWithAggregatesFilter<"RRItem"> | number
    net_price?: FloatWithAggregatesFilter<"RRItem"> | number
    vat_amount?: FloatWithAggregatesFilter<"RRItem"> | number
    created_at?: DateTimeWithAggregatesFilter<"RRItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RRItem"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"RRItem"> | boolean
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    item_type_id?: StringFilter<"Item"> | string
    unit_id?: StringFilter<"Item"> | string
    code?: StringFilter<"Item"> | string
    description?: StringFilter<"Item"> | string
    quantity?: IntFilter<"Item"> | number
    initial_quantity?: IntFilter<"Item"> | number
    created_at?: DateTimeFilter<"Item"> | Date | string
    updated_at?: DateTimeFilter<"Item"> | Date | string
    is_deleted?: BoolFilter<"Item"> | boolean
    item_type?: XOR<ItemTypeRelationFilter, ItemTypeWhereInput>
    item_transactions?: ItemTransactionListRelationFilter
    rr_items?: RRItemListRelationFilter
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    initial_quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    item_type?: ItemTypeOrderByWithRelationInput
    item_transactions?: ItemTransactionOrderByRelationAggregateInput
    rr_items?: RRItemOrderByRelationAggregateInput
    unit?: UnitOrderByWithRelationInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    item_type_id?: StringFilter<"Item"> | string
    unit_id?: StringFilter<"Item"> | string
    description?: StringFilter<"Item"> | string
    quantity?: IntFilter<"Item"> | number
    initial_quantity?: IntFilter<"Item"> | number
    created_at?: DateTimeFilter<"Item"> | Date | string
    updated_at?: DateTimeFilter<"Item"> | Date | string
    is_deleted?: BoolFilter<"Item"> | boolean
    item_type?: XOR<ItemTypeRelationFilter, ItemTypeWhereInput>
    item_transactions?: ItemTransactionListRelationFilter
    rr_items?: RRItemListRelationFilter
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
  }, "id" | "code">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    initial_quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    item_type_id?: StringWithAggregatesFilter<"Item"> | string
    unit_id?: StringWithAggregatesFilter<"Item"> | string
    code?: StringWithAggregatesFilter<"Item"> | string
    description?: StringWithAggregatesFilter<"Item"> | string
    quantity?: IntWithAggregatesFilter<"Item"> | number
    initial_quantity?: IntWithAggregatesFilter<"Item"> | number
    created_at?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"Item"> | boolean
  }

  export type ItemTypeWhereInput = {
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    id?: StringFilter<"ItemType"> | string
    name?: StringFilter<"ItemType"> | string
    created_at?: DateTimeFilter<"ItemType"> | Date | string
    updated_at?: DateTimeFilter<"ItemType"> | Date | string
    is_deleted?: BoolFilter<"ItemType"> | boolean
    items?: ItemListRelationFilter
  }

  export type ItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type ItemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    name?: StringFilter<"ItemType"> | string
    created_at?: DateTimeFilter<"ItemType"> | Date | string
    updated_at?: DateTimeFilter<"ItemType"> | Date | string
    is_deleted?: BoolFilter<"ItemType"> | boolean
    items?: ItemListRelationFilter
  }, "id">

  export type ItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: ItemTypeCountOrderByAggregateInput
    _max?: ItemTypeMaxOrderByAggregateInput
    _min?: ItemTypeMinOrderByAggregateInput
  }

  export type ItemTypeScalarWhereWithAggregatesInput = {
    AND?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    OR?: ItemTypeScalarWhereWithAggregatesInput[]
    NOT?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemType"> | string
    name?: StringWithAggregatesFilter<"ItemType"> | string
    created_at?: DateTimeWithAggregatesFilter<"ItemType"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ItemType"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"ItemType"> | boolean
  }

  export type ItemTransactionWhereInput = {
    AND?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    OR?: ItemTransactionWhereInput[]
    NOT?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    id?: StringFilter<"ItemTransaction"> | string
    item_id?: StringFilter<"ItemTransaction"> | string
    rr_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    type?: IntFilter<"ItemTransaction"> | number
    quantity?: FloatFilter<"ItemTransaction"> | number
    price?: FloatFilter<"ItemTransaction"> | number
    remarks?: StringNullableFilter<"ItemTransaction"> | string | null
    is_initial?: BoolFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    updated_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    is_deleted?: BoolFilter<"ItemTransaction"> | boolean
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    rr_item?: XOR<RRItemNullableRelationFilter, RRItemWhereInput> | null
  }

  export type ItemTransactionOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrderInput | SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    item?: ItemOrderByWithRelationInput
    rr_item?: RRItemOrderByWithRelationInput
  }

  export type ItemTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rr_item_id?: string
    AND?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    OR?: ItemTransactionWhereInput[]
    NOT?: ItemTransactionWhereInput | ItemTransactionWhereInput[]
    item_id?: StringFilter<"ItemTransaction"> | string
    type?: IntFilter<"ItemTransaction"> | number
    quantity?: FloatFilter<"ItemTransaction"> | number
    price?: FloatFilter<"ItemTransaction"> | number
    remarks?: StringNullableFilter<"ItemTransaction"> | string | null
    is_initial?: BoolFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    updated_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    is_deleted?: BoolFilter<"ItemTransaction"> | boolean
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    rr_item?: XOR<RRItemNullableRelationFilter, RRItemWhereInput> | null
  }, "id" | "rr_item_id">

  export type ItemTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrderInput | SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    _count?: ItemTransactionCountOrderByAggregateInput
    _avg?: ItemTransactionAvgOrderByAggregateInput
    _max?: ItemTransactionMaxOrderByAggregateInput
    _min?: ItemTransactionMinOrderByAggregateInput
    _sum?: ItemTransactionSumOrderByAggregateInput
  }

  export type ItemTransactionScalarWhereWithAggregatesInput = {
    AND?: ItemTransactionScalarWhereWithAggregatesInput | ItemTransactionScalarWhereWithAggregatesInput[]
    OR?: ItemTransactionScalarWhereWithAggregatesInput[]
    NOT?: ItemTransactionScalarWhereWithAggregatesInput | ItemTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemTransaction"> | string
    item_id?: StringWithAggregatesFilter<"ItemTransaction"> | string
    rr_item_id?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    type?: IntWithAggregatesFilter<"ItemTransaction"> | number
    quantity?: FloatWithAggregatesFilter<"ItemTransaction"> | number
    price?: FloatWithAggregatesFilter<"ItemTransaction"> | number
    remarks?: StringNullableWithAggregatesFilter<"ItemTransaction"> | string | null
    is_initial?: BoolWithAggregatesFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"ItemTransaction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ItemTransaction"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"ItemTransaction"> | boolean
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contact: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    MEQSSupplier?: MEQSSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    contact: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    MEQSSupplier?: MEQSSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    MEQSSupplier?: MEQSSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    MEQSSupplier?: MEQSSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    contact: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnitCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutUnitInput
    rr_items?: RRItemCreateNestedManyWithoutUnitInput
    items?: ItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutUnitInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutUnitInput
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutUnitNestedInput
    rr_items?: RRItemUpdateManyWithoutUnitNestedInput
    items?: ItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutUnitNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutUnitNestedInput
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BrandCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutBrandInput
    rr_items?: RRItemCreateNestedManyWithoutItem_brandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutBrandInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutItem_brandInput
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutBrandNestedInput
    rr_items?: RRItemUpdateManyWithoutItem_brandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutBrandNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutItem_brandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleCreateInput = {
    id?: string
    name: string
    plate_number: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    sprs?: SPRCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    name: string
    plate_number: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    sprs?: SPRUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    sprs?: SPRUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    sprs?: SPRUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: string
    name: string
    plate_number: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CanvassItemCreateInput = {
    id?: string
    description: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    brand?: BrandCreateNestedOneWithoutCanvass_itemsInput
    unit: UnitCreateNestedOneWithoutCanvass_itemsInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemUncheckedCreateInput = {
    id?: string
    canvass_id: string
    description: string
    brand_id?: string | null
    unit_id: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    brand?: BrandUpdateOneWithoutCanvass_itemsNestedInput
    unit?: UnitUpdateOneRequiredWithoutCanvass_itemsNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemCreateManyInput = {
    id?: string
    canvass_id: string
    description: string
    brand_id?: string | null
    unit_id: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type CanvassItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CanvassItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CanvassCreateInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    jo?: JOCreateNestedOneWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    jo?: JOUpdateOneWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassCreateManyInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type CanvassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CanvassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOCreateInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo_approvers?: JOApproverCreateNestedManyWithoutJoInput
    canvass: CanvassCreateNestedOneWithoutJoInput
    meqs?: MEQSCreateNestedOneWithoutJoInput
  }

  export type JOUncheckedCreateInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id: string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo_approvers?: JOApproverUncheckedCreateNestedManyWithoutJoInput
    meqs?: MEQSUncheckedCreateNestedOneWithoutJoInput
  }

  export type JOUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo_approvers?: JOApproverUpdateManyWithoutJoNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutJoNestedInput
    meqs?: MEQSUpdateOneWithoutJoNestedInput
  }

  export type JOUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo_approvers?: JOApproverUncheckedUpdateManyWithoutJoNestedInput
    meqs?: MEQSUncheckedUpdateOneWithoutJoNestedInput
  }

  export type JOCreateManyInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id: string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type JOUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOApproverCreateInput = {
    id?: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo: JOCreateNestedOneWithoutJo_approversInput
  }

  export type JOApproverUncheckedCreateInput = {
    id?: string
    jo_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type JOApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUpdateOneRequiredWithoutJo_approversNestedInput
  }

  export type JOApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOApproverCreateManyInput = {
    id?: string
    jo_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type JOApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVCreateInput = {
    id?: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutRvInput
    meqs?: MEQSCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverCreateNestedManyWithoutRvInput
  }

  export type RVUncheckedCreateInput = {
    id?: string
    canvass_id: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverUncheckedCreateNestedManyWithoutRvInput
  }

  export type RVUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutRvNestedInput
    meqs?: MEQSUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUpdateManyWithoutRvNestedInput
  }

  export type RVUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUncheckedUpdateManyWithoutRvNestedInput
  }

  export type RVCreateManyInput = {
    id?: string
    canvass_id: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RVUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVApproverCreateInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rv: RVCreateNestedOneWithoutRv_approversInput
  }

  export type RVApproverUncheckedCreateInput = {
    id?: string
    rv_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RVApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rv?: RVUpdateOneRequiredWithoutRv_approversNestedInput
  }

  export type RVApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVApproverCreateManyInput = {
    id?: string
    rv_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RVApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRCreateInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSCreateNestedOneWithoutSprInput
    canvass: CanvassCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id: string
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type SPRCreateManyInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id: string
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SPRUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRApproverCreateInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    spr: SPRCreateNestedOneWithoutSpr_approversInput
  }

  export type SPRApproverUncheckedCreateInput = {
    id?: string
    spr_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SPRApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    spr?: SPRUpdateOneRequiredWithoutSpr_approversNestedInput
  }

  export type SPRApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRApproverCreateManyInput = {
    id?: string
    spr_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SPRApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSCreateInput = {
    id?: string
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateInput = {
    id?: string
    jo_id?: string | null
    rv_id?: string | null
    spr_id?: string | null
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSCreateManyInput = {
    id?: string
    jo_id?: string | null
    rv_id?: string | null
    spr_id?: string | null
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierCreateInput = {
    id?: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierCreateManyInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierItemCreateInput = {
    id?: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_item: CanvassItemCreateNestedOneWithoutMeqs_supplier_itemsInput
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutMeqs_supplier_itemsInput
  }

  export type MEQSSupplierItemUncheckedCreateInput = {
    id?: string
    canvass_item_id: string
    meqs_supplier_id: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_item?: CanvassItemUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierItemCreateManyInput = {
    id?: string
    canvass_item_id: string
    meqs_supplier_id: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierAttachmentCreateInput = {
    id?: string
    src: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutAttachmentsInput
  }

  export type MEQSSupplierAttachmentUncheckedCreateInput = {
    id?: string
    meqs_supplier_id: string
    src: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MEQSSupplierAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierAttachmentCreateManyInput = {
    id?: string
    meqs_supplier_id: string
    src: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSApproverCreateInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs: MEQSCreateNestedOneWithoutMeqs_approversInput
  }

  export type MEQSApproverUncheckedCreateInput = {
    id?: string
    meqs_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_approversNestedInput
  }

  export type MEQSApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSApproverCreateManyInput = {
    id?: string
    meqs_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POCreateInput = {
    id?: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    po_approvers?: POApproverCreateNestedManyWithoutPoInput
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutPoInput
    rr?: RRCreateNestedOneWithoutPoInput
  }

  export type POUncheckedCreateInput = {
    id?: string
    meqs_supplier_id: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    po_approvers?: POApproverUncheckedCreateNestedManyWithoutPoInput
    rr?: RRUncheckedCreateNestedOneWithoutPoInput
  }

  export type POUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    po_approvers?: POApproverUpdateManyWithoutPoNestedInput
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutPoNestedInput
    rr?: RRUpdateOneWithoutPoNestedInput
  }

  export type POUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    po_approvers?: POApproverUncheckedUpdateManyWithoutPoNestedInput
    rr?: RRUncheckedUpdateOneWithoutPoNestedInput
  }

  export type POCreateManyInput = {
    id?: string
    meqs_supplier_id: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
  }

  export type POUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POApproverCreateInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    po: POCreateNestedOneWithoutPo_approversInput
  }

  export type POApproverUncheckedCreateInput = {
    id?: string
    po_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type POApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    po?: POUpdateOneRequiredWithoutPo_approversNestedInput
  }

  export type POApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POApproverCreateManyInput = {
    id?: string
    po_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type POApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRCreateInput = {
    id?: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    po: POCreateNestedOneWithoutRrInput
    rr_approvers?: RRApproverCreateNestedManyWithoutRrInput
    rr_items?: RRItemCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateInput = {
    id?: string
    po_id: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_approvers?: RRApproverUncheckedCreateNestedManyWithoutRrInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    po?: POUpdateOneRequiredWithoutRrNestedInput
    rr_approvers?: RRApproverUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_approvers?: RRApproverUncheckedUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutRrNestedInput
  }

  export type RRCreateManyInput = {
    id?: string
    po_id: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRApproverCreateInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr: RRCreateNestedOneWithoutRr_approversInput
  }

  export type RRApproverUncheckedCreateInput = {
    id?: string
    rr_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRApproverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr?: RRUpdateOneRequiredWithoutRr_approversNestedInput
  }

  export type RRApproverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRApproverCreateManyInput = {
    id?: string
    rr_id: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRApproverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRApproverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRItemCreateInput = {
    id?: string
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr: RRCreateNestedOneWithoutRr_itemsInput
    item?: ItemCreateNestedOneWithoutRr_itemsInput
    item_brand?: BrandCreateNestedOneWithoutRr_itemsInput
    unit?: UnitCreateNestedOneWithoutRr_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUncheckedCreateInput = {
    id?: string
    rr_id: string
    item_id?: string | null
    item_brand_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    item?: ItemUpdateOneWithoutRr_itemsNestedInput
    item_brand?: BrandUpdateOneWithoutRr_itemsNestedInput
    unit?: UnitUpdateOneWithoutRr_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemCreateManyInput = {
    id?: string
    rr_id: string
    item_id?: string | null
    item_brand_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCreateInput = {
    id?: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    rr_items?: RRItemCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    item_type_id: string
    unit_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    rr_items?: RRItemUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    item_type_id: string
    unit_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTypeCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    items?: ItemCreateNestedManyWithoutItem_typeInput
  }

  export type ItemTypeUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    items?: ItemUncheckedCreateNestedManyWithoutItem_typeInput
  }

  export type ItemTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    items?: ItemUpdateManyWithoutItem_typeNestedInput
  }

  export type ItemTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    items?: ItemUncheckedUpdateManyWithoutItem_typeNestedInput
  }

  export type ItemTypeCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTransactionCreateInput = {
    id?: string
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item: ItemCreateNestedOneWithoutItem_transactionsInput
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateInput = {
    id?: string
    item_id: string
    rr_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTransactionCreateManyInput = {
    id?: string
    item_id: string
    rr_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MEQSSupplierListRelationFilter = {
    every?: MEQSSupplierWhereInput
    some?: MEQSSupplierWhereInput
    none?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CanvassItemListRelationFilter = {
    every?: CanvassItemWhereInput
    some?: CanvassItemWhereInput
    none?: CanvassItemWhereInput
  }

  export type RRItemListRelationFilter = {
    every?: RRItemWhereInput
    some?: RRItemWhereInput
    none?: RRItemWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type CanvassItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RRItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SPRListRelationFilter = {
    every?: SPRWhereInput
    some?: SPRWhereInput
    none?: SPRWhereInput
  }

  export type SPROrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plate_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CanvassRelationFilter = {
    is?: CanvassWhereInput
    isNot?: CanvassWhereInput
  }

  export type BrandNullableRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type UnitRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type MEQSSupplierItemListRelationFilter = {
    every?: MEQSSupplierItemWhereInput
    some?: MEQSSupplierItemWhereInput
    none?: MEQSSupplierItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MEQSSupplierItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvassItemCountOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    description?: SortOrder
    brand_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type CanvassItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CanvassItemMaxOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    description?: SortOrder
    brand_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type CanvassItemMinOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    description?: SortOrder
    brand_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type CanvassItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type JONullableRelationFilter = {
    is?: JOWhereInput | null
    isNot?: JOWhereInput | null
  }

  export type RVNullableRelationFilter = {
    is?: RVWhereInput | null
    isNot?: RVWhereInput | null
  }

  export type SPRNullableRelationFilter = {
    is?: SPRWhereInput | null
    isNot?: SPRWhereInput | null
  }

  export type CanvassCountOrderByAggregateInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    requested_by_id?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type CanvassMaxOrderByAggregateInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    requested_by_id?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type CanvassMinOrderByAggregateInput = {
    id?: SortOrder
    rc_number?: SortOrder
    date_requested?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    requested_by_id?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type JOApproverListRelationFilter = {
    every?: JOApproverWhereInput
    some?: JOApproverWhereInput
    none?: JOApproverWhereInput
  }

  export type MEQSNullableRelationFilter = {
    is?: MEQSWhereInput | null
    isNot?: MEQSWhereInput | null
  }

  export type JOApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JOCountOrderByAggregateInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type JOAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type JOMaxOrderByAggregateInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type JOMinOrderByAggregateInput = {
    id?: SortOrder
    jo_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    equipment?: SortOrder
    classification_id?: SortOrder
    department_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type JOSumOrderByAggregateInput = {
    status?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type JORelationFilter = {
    is?: JOWhereInput
    isNot?: JOWhereInput
  }

  export type JOApproverCountOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type JOApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type JOApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type JOApproverMinOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type JOApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type RVApproverListRelationFilter = {
    every?: RVApproverWhereInput
    some?: RVApproverWhereInput
    none?: RVApproverWhereInput
  }

  export type RVApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RVCountOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    rv_number?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrder
    work_order_date?: SortOrder
    status?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RVAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type RVMaxOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    rv_number?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrder
    work_order_date?: SortOrder
    status?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RVMinOrderByAggregateInput = {
    id?: SortOrder
    canvass_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    rv_number?: SortOrder
    date_requested?: SortOrder
    work_order_no?: SortOrder
    work_order_date?: SortOrder
    status?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RVSumOrderByAggregateInput = {
    status?: SortOrder
  }

  export type RVRelationFilter = {
    is?: RVWhereInput
    isNot?: RVWhereInput
  }

  export type RVApproverCountOrderByAggregateInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RVApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type RVApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RVApproverMinOrderByAggregateInput = {
    id?: SortOrder
    rv_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RVApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type VehicleRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type SPRApproverListRelationFilter = {
    every?: SPRApproverWhereInput
    some?: SPRApproverWhereInput
    none?: SPRApproverWhereInput
  }

  export type SPRApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SPRCountOrderByAggregateInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SPRAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type SPRMaxOrderByAggregateInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SPRMinOrderByAggregateInput = {
    id?: SortOrder
    spr_number?: SortOrder
    date_requested?: SortOrder
    canvass_id?: SortOrder
    vehicle_id?: SortOrder
    classification_id?: SortOrder
    supervisor_id?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SPRSumOrderByAggregateInput = {
    status?: SortOrder
  }

  export type SPRRelationFilter = {
    is?: SPRWhereInput
    isNot?: SPRWhereInput
  }

  export type SPRApproverCountOrderByAggregateInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SPRApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type SPRApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SPRApproverMinOrderByAggregateInput = {
    id?: SortOrder
    spr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type SPRApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MEQSApproverListRelationFilter = {
    every?: MEQSApproverWhereInput
    some?: MEQSApproverWhereInput
    none?: MEQSApproverWhereInput
  }

  export type MEQSApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MEQSCountOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    rv_id?: SortOrder
    spr_id?: SortOrder
    meqs_number?: SortOrder
    request_type?: SortOrder
    meqs_date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSAvgOrderByAggregateInput = {
    request_type?: SortOrder
    status?: SortOrder
  }

  export type MEQSMaxOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    rv_id?: SortOrder
    spr_id?: SortOrder
    meqs_number?: SortOrder
    request_type?: SortOrder
    meqs_date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSMinOrderByAggregateInput = {
    id?: SortOrder
    jo_id?: SortOrder
    rv_id?: SortOrder
    spr_id?: SortOrder
    meqs_number?: SortOrder
    request_type?: SortOrder
    meqs_date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSumOrderByAggregateInput = {
    request_type?: SortOrder
    status?: SortOrder
  }

  export type MEQSRelationFilter = {
    is?: MEQSWhereInput
    isNot?: MEQSWhereInput
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type MEQSSupplierAttachmentListRelationFilter = {
    every?: MEQSSupplierAttachmentWhereInput
    some?: MEQSSupplierAttachmentWhereInput
    none?: MEQSSupplierAttachmentWhereInput
  }

  export type PONullableRelationFilter = {
    is?: POWhereInput | null
    isNot?: POWhereInput | null
  }

  export type MEQSSupplierAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MEQSSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    supplier_id?: SortOrder
    payment_terms?: SortOrder
    is_referenced?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CanvassItemRelationFilter = {
    is?: CanvassItemWhereInput
    isNot?: CanvassItemWhereInput
  }

  export type MEQSSupplierRelationFilter = {
    is?: MEQSSupplierWhereInput
    isNot?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierItemCountOrderByAggregateInput = {
    id?: SortOrder
    canvass_item_id?: SortOrder
    meqs_supplier_id?: SortOrder
    price?: SortOrder
    is_awarded?: SortOrder
    notes?: SortOrder
    vat_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSupplierItemAvgOrderByAggregateInput = {
    price?: SortOrder
    vat_type?: SortOrder
  }

  export type MEQSSupplierItemMaxOrderByAggregateInput = {
    id?: SortOrder
    canvass_item_id?: SortOrder
    meqs_supplier_id?: SortOrder
    price?: SortOrder
    is_awarded?: SortOrder
    notes?: SortOrder
    vat_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSupplierItemMinOrderByAggregateInput = {
    id?: SortOrder
    canvass_item_id?: SortOrder
    meqs_supplier_id?: SortOrder
    price?: SortOrder
    is_awarded?: SortOrder
    notes?: SortOrder
    vat_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSupplierItemSumOrderByAggregateInput = {
    price?: SortOrder
    vat_type?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type MEQSSupplierAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    src?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSupplierAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    src?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSSupplierAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    src?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSApproverCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type MEQSApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSApproverMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type MEQSApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type POApproverListRelationFilter = {
    every?: POApproverWhereInput
    some?: POApproverWhereInput
    none?: POApproverWhereInput
  }

  export type RRNullableRelationFilter = {
    is?: RRWhereInput | null
    isNot?: RRWhereInput | null
  }

  export type POApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POCountOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    po_number?: SortOrder
    po_date?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    is_referenced?: SortOrder
  }

  export type POAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type POMaxOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    po_number?: SortOrder
    po_date?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    is_referenced?: SortOrder
  }

  export type POMinOrderByAggregateInput = {
    id?: SortOrder
    meqs_supplier_id?: SortOrder
    po_number?: SortOrder
    po_date?: SortOrder
    status?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    is_referenced?: SortOrder
  }

  export type POSumOrderByAggregateInput = {
    status?: SortOrder
  }

  export type PORelationFilter = {
    is?: POWhereInput
    isNot?: POWhereInput
  }

  export type POApproverCountOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type POApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type POApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type POApproverMinOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type POApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type RRApproverListRelationFilter = {
    every?: RRApproverWhereInput
    some?: RRApproverWhereInput
    none?: RRApproverWhereInput
  }

  export type RRApproverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RRCountOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRAvgOrderByAggregateInput = {
    delivery_charge?: SortOrder
    status?: SortOrder
  }

  export type RRMaxOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRMinOrderByAggregateInput = {
    id?: SortOrder
    po_id?: SortOrder
    rr_number?: SortOrder
    rr_date?: SortOrder
    received_by_id?: SortOrder
    canceller_id?: SortOrder
    date_cancelled?: SortOrder
    invoice_number?: SortOrder
    delivery_number?: SortOrder
    notes?: SortOrder
    delivery_charge?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRSumOrderByAggregateInput = {
    delivery_charge?: SortOrder
    status?: SortOrder
  }

  export type RRRelationFilter = {
    is?: RRWhereInput
    isNot?: RRWhereInput
  }

  export type RRApproverCountOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRApproverAvgOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type RRApproverMaxOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRApproverMinOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    approver_id?: SortOrder
    approver_proxy_id?: SortOrder
    date_approval?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    label?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRApproverSumOrderByAggregateInput = {
    status?: SortOrder
    order?: SortOrder
  }

  export type ItemNullableRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type UnitNullableRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type ItemTransactionNullableRelationFilter = {
    is?: ItemTransactionWhereInput | null
    isNot?: ItemTransactionWhereInput | null
  }

  export type RRItemCountOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    item_id?: SortOrder
    item_brand_id?: SortOrder
    unit_id?: SortOrder
    item_class?: SortOrder
    quantity_delivered?: SortOrder
    quantity_accepted?: SortOrder
    description?: SortOrder
    vat_type?: SortOrder
    gross_price?: SortOrder
    net_price?: SortOrder
    vat_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRItemAvgOrderByAggregateInput = {
    item_class?: SortOrder
    quantity_delivered?: SortOrder
    quantity_accepted?: SortOrder
    vat_type?: SortOrder
    gross_price?: SortOrder
    net_price?: SortOrder
    vat_amount?: SortOrder
  }

  export type RRItemMaxOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    item_id?: SortOrder
    item_brand_id?: SortOrder
    unit_id?: SortOrder
    item_class?: SortOrder
    quantity_delivered?: SortOrder
    quantity_accepted?: SortOrder
    description?: SortOrder
    vat_type?: SortOrder
    gross_price?: SortOrder
    net_price?: SortOrder
    vat_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRItemMinOrderByAggregateInput = {
    id?: SortOrder
    rr_id?: SortOrder
    item_id?: SortOrder
    item_brand_id?: SortOrder
    unit_id?: SortOrder
    item_class?: SortOrder
    quantity_delivered?: SortOrder
    quantity_accepted?: SortOrder
    description?: SortOrder
    vat_type?: SortOrder
    gross_price?: SortOrder
    net_price?: SortOrder
    vat_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type RRItemSumOrderByAggregateInput = {
    item_class?: SortOrder
    quantity_delivered?: SortOrder
    quantity_accepted?: SortOrder
    vat_type?: SortOrder
    gross_price?: SortOrder
    net_price?: SortOrder
    vat_amount?: SortOrder
  }

  export type ItemTypeRelationFilter = {
    is?: ItemTypeWhereInput
    isNot?: ItemTypeWhereInput
  }

  export type ItemTransactionListRelationFilter = {
    every?: ItemTransactionWhereInput
    some?: ItemTransactionWhereInput
    none?: ItemTransactionWhereInput
  }

  export type ItemTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    initial_quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    initial_quantity?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    initial_quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    item_type_id?: SortOrder
    unit_id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    initial_quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    initial_quantity?: SortOrder
  }

  export type ItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type RRItemNullableRelationFilter = {
    is?: RRItemWhereInput | null
    isNot?: RRItemWhereInput | null
  }

  export type ItemTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemTransactionAvgOrderByAggregateInput = {
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ItemTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    rr_item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    remarks?: SortOrder
    is_initial?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type ItemTransactionSumOrderByAggregateInput = {
    type?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MEQSSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type MEQSSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MEQSSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutSupplierInput | MEQSSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput> | MEQSSupplierCreateWithoutSupplierInput[] | MEQSSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutSupplierInput | MEQSSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: MEQSSupplierCreateManySupplierInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput | MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutSupplierInput | MEQSSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type CanvassItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type RRItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<RRItemCreateWithoutUnitInput, RRItemUncheckedCreateWithoutUnitInput> | RRItemCreateWithoutUnitInput[] | RRItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutUnitInput | RRItemCreateOrConnectWithoutUnitInput[]
    createMany?: RRItemCreateManyUnitInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type CanvassItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type RRItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<RRItemCreateWithoutUnitInput, RRItemUncheckedCreateWithoutUnitInput> | RRItemCreateWithoutUnitInput[] | RRItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutUnitInput | RRItemCreateOrConnectWithoutUnitInput[]
    createMany?: RRItemCreateManyUnitInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type CanvassItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutUnitInput | CanvassItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutUnitInput | CanvassItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutUnitInput | CanvassItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type RRItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<RRItemCreateWithoutUnitInput, RRItemUncheckedCreateWithoutUnitInput> | RRItemCreateWithoutUnitInput[] | RRItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutUnitInput | RRItemCreateOrConnectWithoutUnitInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutUnitInput | RRItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: RRItemCreateManyUnitInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutUnitInput | RRItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutUnitInput | RRItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutUnitInput | ItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutUnitInput | ItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutUnitInput | ItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type CanvassItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput> | CanvassItemCreateWithoutUnitInput[] | CanvassItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutUnitInput | CanvassItemCreateOrConnectWithoutUnitInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutUnitInput | CanvassItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: CanvassItemCreateManyUnitInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutUnitInput | CanvassItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutUnitInput | CanvassItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type RRItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<RRItemCreateWithoutUnitInput, RRItemUncheckedCreateWithoutUnitInput> | RRItemCreateWithoutUnitInput[] | RRItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutUnitInput | RRItemCreateOrConnectWithoutUnitInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutUnitInput | RRItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: RRItemCreateManyUnitInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutUnitInput | RRItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutUnitInput | RRItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutUnitInput | ItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutUnitInput | ItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutUnitInput | ItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type CanvassItemCreateNestedManyWithoutBrandInput = {
    create?: XOR<CanvassItemCreateWithoutBrandInput, CanvassItemUncheckedCreateWithoutBrandInput> | CanvassItemCreateWithoutBrandInput[] | CanvassItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutBrandInput | CanvassItemCreateOrConnectWithoutBrandInput[]
    createMany?: CanvassItemCreateManyBrandInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type RRItemCreateNestedManyWithoutItem_brandInput = {
    create?: XOR<RRItemCreateWithoutItem_brandInput, RRItemUncheckedCreateWithoutItem_brandInput> | RRItemCreateWithoutItem_brandInput[] | RRItemUncheckedCreateWithoutItem_brandInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_brandInput | RRItemCreateOrConnectWithoutItem_brandInput[]
    createMany?: RRItemCreateManyItem_brandInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type CanvassItemUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<CanvassItemCreateWithoutBrandInput, CanvassItemUncheckedCreateWithoutBrandInput> | CanvassItemCreateWithoutBrandInput[] | CanvassItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutBrandInput | CanvassItemCreateOrConnectWithoutBrandInput[]
    createMany?: CanvassItemCreateManyBrandInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type RRItemUncheckedCreateNestedManyWithoutItem_brandInput = {
    create?: XOR<RRItemCreateWithoutItem_brandInput, RRItemUncheckedCreateWithoutItem_brandInput> | RRItemCreateWithoutItem_brandInput[] | RRItemUncheckedCreateWithoutItem_brandInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_brandInput | RRItemCreateOrConnectWithoutItem_brandInput[]
    createMany?: RRItemCreateManyItem_brandInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type CanvassItemUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CanvassItemCreateWithoutBrandInput, CanvassItemUncheckedCreateWithoutBrandInput> | CanvassItemCreateWithoutBrandInput[] | CanvassItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutBrandInput | CanvassItemCreateOrConnectWithoutBrandInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutBrandInput | CanvassItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CanvassItemCreateManyBrandInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutBrandInput | CanvassItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutBrandInput | CanvassItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type RRItemUpdateManyWithoutItem_brandNestedInput = {
    create?: XOR<RRItemCreateWithoutItem_brandInput, RRItemUncheckedCreateWithoutItem_brandInput> | RRItemCreateWithoutItem_brandInput[] | RRItemUncheckedCreateWithoutItem_brandInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_brandInput | RRItemCreateOrConnectWithoutItem_brandInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutItem_brandInput | RRItemUpsertWithWhereUniqueWithoutItem_brandInput[]
    createMany?: RRItemCreateManyItem_brandInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutItem_brandInput | RRItemUpdateWithWhereUniqueWithoutItem_brandInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutItem_brandInput | RRItemUpdateManyWithWhereWithoutItem_brandInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type CanvassItemUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CanvassItemCreateWithoutBrandInput, CanvassItemUncheckedCreateWithoutBrandInput> | CanvassItemCreateWithoutBrandInput[] | CanvassItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutBrandInput | CanvassItemCreateOrConnectWithoutBrandInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutBrandInput | CanvassItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CanvassItemCreateManyBrandInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutBrandInput | CanvassItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutBrandInput | CanvassItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type RRItemUncheckedUpdateManyWithoutItem_brandNestedInput = {
    create?: XOR<RRItemCreateWithoutItem_brandInput, RRItemUncheckedCreateWithoutItem_brandInput> | RRItemCreateWithoutItem_brandInput[] | RRItemUncheckedCreateWithoutItem_brandInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_brandInput | RRItemCreateOrConnectWithoutItem_brandInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutItem_brandInput | RRItemUpsertWithWhereUniqueWithoutItem_brandInput[]
    createMany?: RRItemCreateManyItem_brandInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutItem_brandInput | RRItemUpdateWithWhereUniqueWithoutItem_brandInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutItem_brandInput | RRItemUpdateManyWithWhereWithoutItem_brandInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type SPRCreateNestedManyWithoutVehicleInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
  }

  export type SPRUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
  }

  export type SPRUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    upsert?: SPRUpsertWithWhereUniqueWithoutVehicleInput | SPRUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    set?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    disconnect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    delete?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    update?: SPRUpdateWithWhereUniqueWithoutVehicleInput | SPRUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: SPRUpdateManyWithWhereWithoutVehicleInput | SPRUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: SPRScalarWhereInput | SPRScalarWhereInput[]
  }

  export type SPRUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput> | SPRCreateWithoutVehicleInput[] | SPRUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SPRCreateOrConnectWithoutVehicleInput | SPRCreateOrConnectWithoutVehicleInput[]
    upsert?: SPRUpsertWithWhereUniqueWithoutVehicleInput | SPRUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: SPRCreateManyVehicleInputEnvelope
    set?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    disconnect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    delete?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    connect?: SPRWhereUniqueInput | SPRWhereUniqueInput[]
    update?: SPRUpdateWithWhereUniqueWithoutVehicleInput | SPRUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: SPRUpdateManyWithWhereWithoutVehicleInput | SPRUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: SPRScalarWhereInput | SPRScalarWhereInput[]
  }

  export type CanvassCreateNestedOneWithoutCanvass_itemsInput = {
    create?: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutCanvass_itemsInput
    connect?: CanvassWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutCanvass_itemsInput = {
    create?: XOR<BrandCreateWithoutCanvass_itemsInput, BrandUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCanvass_itemsInput
    connect?: BrandWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutCanvass_itemsInput = {
    create?: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCanvass_itemsInput
    connect?: UnitWhereUniqueInput
  }

  export type MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput = {
    create?: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutCanvass_itemsInput
    upsert?: CanvassUpsertWithoutCanvass_itemsInput
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutCanvass_itemsInput, CanvassUpdateWithoutCanvass_itemsInput>, CanvassUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type BrandUpdateOneWithoutCanvass_itemsNestedInput = {
    create?: XOR<BrandCreateWithoutCanvass_itemsInput, BrandUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCanvass_itemsInput
    upsert?: BrandUpsertWithoutCanvass_itemsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutCanvass_itemsInput, BrandUpdateWithoutCanvass_itemsInput>, BrandUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type UnitUpdateOneRequiredWithoutCanvass_itemsNestedInput = {
    create?: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCanvass_itemsInput
    upsert?: UnitUpsertWithoutCanvass_itemsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutCanvass_itemsInput, UnitUpdateWithoutCanvass_itemsInput>, UnitUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput | MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput> | MEQSSupplierItemCreateWithoutCanvass_itemInput[] | MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput | MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput[]
    createMany?: MEQSSupplierItemCreateManyCanvass_itemInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput | MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type CanvassItemCreateNestedManyWithoutCanvassInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type JOCreateNestedOneWithoutCanvassInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    connect?: JOWhereUniqueInput
  }

  export type RVCreateNestedOneWithoutCanvassInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    connect?: RVWhereUniqueInput
  }

  export type SPRCreateNestedOneWithoutCanvassInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    connect?: SPRWhereUniqueInput
  }

  export type CanvassItemUncheckedCreateNestedManyWithoutCanvassInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
  }

  export type JOUncheckedCreateNestedOneWithoutCanvassInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    connect?: JOWhereUniqueInput
  }

  export type RVUncheckedCreateNestedOneWithoutCanvassInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    connect?: RVWhereUniqueInput
  }

  export type SPRUncheckedCreateNestedOneWithoutCanvassInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    connect?: SPRWhereUniqueInput
  }

  export type CanvassItemUpdateManyWithoutCanvassNestedInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutCanvassInput | CanvassItemUpsertWithWhereUniqueWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutCanvassInput | CanvassItemUpdateWithWhereUniqueWithoutCanvassInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutCanvassInput | CanvassItemUpdateManyWithWhereWithoutCanvassInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type JOUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    upsert?: JOUpsertWithoutCanvassInput
    disconnect?: JOWhereInput | boolean
    delete?: JOWhereInput | boolean
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutCanvassInput, JOUpdateWithoutCanvassInput>, JOUncheckedUpdateWithoutCanvassInput>
  }

  export type RVUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    upsert?: RVUpsertWithoutCanvassInput
    disconnect?: RVWhereInput | boolean
    delete?: RVWhereInput | boolean
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutCanvassInput, RVUpdateWithoutCanvassInput>, RVUncheckedUpdateWithoutCanvassInput>
  }

  export type SPRUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    upsert?: SPRUpsertWithoutCanvassInput
    disconnect?: SPRWhereInput | boolean
    delete?: SPRWhereInput | boolean
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutCanvassInput, SPRUpdateWithoutCanvassInput>, SPRUncheckedUpdateWithoutCanvassInput>
  }

  export type CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput = {
    create?: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput> | CanvassItemCreateWithoutCanvassInput[] | CanvassItemUncheckedCreateWithoutCanvassInput[]
    connectOrCreate?: CanvassItemCreateOrConnectWithoutCanvassInput | CanvassItemCreateOrConnectWithoutCanvassInput[]
    upsert?: CanvassItemUpsertWithWhereUniqueWithoutCanvassInput | CanvassItemUpsertWithWhereUniqueWithoutCanvassInput[]
    createMany?: CanvassItemCreateManyCanvassInputEnvelope
    set?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    disconnect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    delete?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    connect?: CanvassItemWhereUniqueInput | CanvassItemWhereUniqueInput[]
    update?: CanvassItemUpdateWithWhereUniqueWithoutCanvassInput | CanvassItemUpdateWithWhereUniqueWithoutCanvassInput[]
    updateMany?: CanvassItemUpdateManyWithWhereWithoutCanvassInput | CanvassItemUpdateManyWithWhereWithoutCanvassInput[]
    deleteMany?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
  }

  export type JOUncheckedUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: JOCreateOrConnectWithoutCanvassInput
    upsert?: JOUpsertWithoutCanvassInput
    disconnect?: JOWhereInput | boolean
    delete?: JOWhereInput | boolean
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutCanvassInput, JOUpdateWithoutCanvassInput>, JOUncheckedUpdateWithoutCanvassInput>
  }

  export type RVUncheckedUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: RVCreateOrConnectWithoutCanvassInput
    upsert?: RVUpsertWithoutCanvassInput
    disconnect?: RVWhereInput | boolean
    delete?: RVWhereInput | boolean
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutCanvassInput, RVUpdateWithoutCanvassInput>, RVUncheckedUpdateWithoutCanvassInput>
  }

  export type SPRUncheckedUpdateOneWithoutCanvassNestedInput = {
    create?: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    connectOrCreate?: SPRCreateOrConnectWithoutCanvassInput
    upsert?: SPRUpsertWithoutCanvassInput
    disconnect?: SPRWhereInput | boolean
    delete?: SPRWhereInput | boolean
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutCanvassInput, SPRUpdateWithoutCanvassInput>, SPRUncheckedUpdateWithoutCanvassInput>
  }

  export type JOApproverCreateNestedManyWithoutJoInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
  }

  export type CanvassCreateNestedOneWithoutJoInput = {
    create?: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutJoInput
    connect?: CanvassWhereUniqueInput
  }

  export type MEQSCreateNestedOneWithoutJoInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    connect?: MEQSWhereUniqueInput
  }

  export type JOApproverUncheckedCreateNestedManyWithoutJoInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
  }

  export type MEQSUncheckedCreateNestedOneWithoutJoInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    connect?: MEQSWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type JOApproverUpdateManyWithoutJoNestedInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    upsert?: JOApproverUpsertWithWhereUniqueWithoutJoInput | JOApproverUpsertWithWhereUniqueWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    set?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    disconnect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    delete?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    update?: JOApproverUpdateWithWhereUniqueWithoutJoInput | JOApproverUpdateWithWhereUniqueWithoutJoInput[]
    updateMany?: JOApproverUpdateManyWithWhereWithoutJoInput | JOApproverUpdateManyWithWhereWithoutJoInput[]
    deleteMany?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
  }

  export type CanvassUpdateOneRequiredWithoutJoNestedInput = {
    create?: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutJoInput
    upsert?: CanvassUpsertWithoutJoInput
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutJoInput, CanvassUpdateWithoutJoInput>, CanvassUncheckedUpdateWithoutJoInput>
  }

  export type MEQSUpdateOneWithoutJoNestedInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    upsert?: MEQSUpsertWithoutJoInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutJoInput, MEQSUpdateWithoutJoInput>, MEQSUncheckedUpdateWithoutJoInput>
  }

  export type JOApproverUncheckedUpdateManyWithoutJoNestedInput = {
    create?: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput> | JOApproverCreateWithoutJoInput[] | JOApproverUncheckedCreateWithoutJoInput[]
    connectOrCreate?: JOApproverCreateOrConnectWithoutJoInput | JOApproverCreateOrConnectWithoutJoInput[]
    upsert?: JOApproverUpsertWithWhereUniqueWithoutJoInput | JOApproverUpsertWithWhereUniqueWithoutJoInput[]
    createMany?: JOApproverCreateManyJoInputEnvelope
    set?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    disconnect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    delete?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    connect?: JOApproverWhereUniqueInput | JOApproverWhereUniqueInput[]
    update?: JOApproverUpdateWithWhereUniqueWithoutJoInput | JOApproverUpdateWithWhereUniqueWithoutJoInput[]
    updateMany?: JOApproverUpdateManyWithWhereWithoutJoInput | JOApproverUpdateManyWithWhereWithoutJoInput[]
    deleteMany?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
  }

  export type MEQSUncheckedUpdateOneWithoutJoNestedInput = {
    create?: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutJoInput
    upsert?: MEQSUpsertWithoutJoInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutJoInput, MEQSUpdateWithoutJoInput>, MEQSUncheckedUpdateWithoutJoInput>
  }

  export type JOCreateNestedOneWithoutJo_approversInput = {
    create?: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
    connectOrCreate?: JOCreateOrConnectWithoutJo_approversInput
    connect?: JOWhereUniqueInput
  }

  export type JOUpdateOneRequiredWithoutJo_approversNestedInput = {
    create?: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
    connectOrCreate?: JOCreateOrConnectWithoutJo_approversInput
    upsert?: JOUpsertWithoutJo_approversInput
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutJo_approversInput, JOUpdateWithoutJo_approversInput>, JOUncheckedUpdateWithoutJo_approversInput>
  }

  export type CanvassCreateNestedOneWithoutRvInput = {
    create?: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutRvInput
    connect?: CanvassWhereUniqueInput
  }

  export type MEQSCreateNestedOneWithoutRvInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    connect?: MEQSWhereUniqueInput
  }

  export type RVApproverCreateNestedManyWithoutRvInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
  }

  export type MEQSUncheckedCreateNestedOneWithoutRvInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    connect?: MEQSWhereUniqueInput
  }

  export type RVApproverUncheckedCreateNestedManyWithoutRvInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
  }

  export type CanvassUpdateOneRequiredWithoutRvNestedInput = {
    create?: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutRvInput
    upsert?: CanvassUpsertWithoutRvInput
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutRvInput, CanvassUpdateWithoutRvInput>, CanvassUncheckedUpdateWithoutRvInput>
  }

  export type MEQSUpdateOneWithoutRvNestedInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    upsert?: MEQSUpsertWithoutRvInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutRvInput, MEQSUpdateWithoutRvInput>, MEQSUncheckedUpdateWithoutRvInput>
  }

  export type RVApproverUpdateManyWithoutRvNestedInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    upsert?: RVApproverUpsertWithWhereUniqueWithoutRvInput | RVApproverUpsertWithWhereUniqueWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    set?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    disconnect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    delete?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    update?: RVApproverUpdateWithWhereUniqueWithoutRvInput | RVApproverUpdateWithWhereUniqueWithoutRvInput[]
    updateMany?: RVApproverUpdateManyWithWhereWithoutRvInput | RVApproverUpdateManyWithWhereWithoutRvInput[]
    deleteMany?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
  }

  export type MEQSUncheckedUpdateOneWithoutRvNestedInput = {
    create?: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutRvInput
    upsert?: MEQSUpsertWithoutRvInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutRvInput, MEQSUpdateWithoutRvInput>, MEQSUncheckedUpdateWithoutRvInput>
  }

  export type RVApproverUncheckedUpdateManyWithoutRvNestedInput = {
    create?: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput> | RVApproverCreateWithoutRvInput[] | RVApproverUncheckedCreateWithoutRvInput[]
    connectOrCreate?: RVApproverCreateOrConnectWithoutRvInput | RVApproverCreateOrConnectWithoutRvInput[]
    upsert?: RVApproverUpsertWithWhereUniqueWithoutRvInput | RVApproverUpsertWithWhereUniqueWithoutRvInput[]
    createMany?: RVApproverCreateManyRvInputEnvelope
    set?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    disconnect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    delete?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    connect?: RVApproverWhereUniqueInput | RVApproverWhereUniqueInput[]
    update?: RVApproverUpdateWithWhereUniqueWithoutRvInput | RVApproverUpdateWithWhereUniqueWithoutRvInput[]
    updateMany?: RVApproverUpdateManyWithWhereWithoutRvInput | RVApproverUpdateManyWithWhereWithoutRvInput[]
    deleteMany?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
  }

  export type RVCreateNestedOneWithoutRv_approversInput = {
    create?: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
    connectOrCreate?: RVCreateOrConnectWithoutRv_approversInput
    connect?: RVWhereUniqueInput
  }

  export type RVUpdateOneRequiredWithoutRv_approversNestedInput = {
    create?: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
    connectOrCreate?: RVCreateOrConnectWithoutRv_approversInput
    upsert?: RVUpsertWithoutRv_approversInput
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutRv_approversInput, RVUpdateWithoutRv_approversInput>, RVUncheckedUpdateWithoutRv_approversInput>
  }

  export type MEQSCreateNestedOneWithoutSprInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    connect?: MEQSWhereUniqueInput
  }

  export type CanvassCreateNestedOneWithoutSprInput = {
    create?: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutSprInput
    connect?: CanvassWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutSprsInput = {
    create?: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSprsInput
    connect?: VehicleWhereUniqueInput
  }

  export type SPRApproverCreateNestedManyWithoutSprInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
  }

  export type MEQSUncheckedCreateNestedOneWithoutSprInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    connect?: MEQSWhereUniqueInput
  }

  export type SPRApproverUncheckedCreateNestedManyWithoutSprInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
  }

  export type MEQSUpdateOneWithoutSprNestedInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    upsert?: MEQSUpsertWithoutSprInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutSprInput, MEQSUpdateWithoutSprInput>, MEQSUncheckedUpdateWithoutSprInput>
  }

  export type CanvassUpdateOneRequiredWithoutSprNestedInput = {
    create?: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
    connectOrCreate?: CanvassCreateOrConnectWithoutSprInput
    upsert?: CanvassUpsertWithoutSprInput
    connect?: CanvassWhereUniqueInput
    update?: XOR<XOR<CanvassUpdateToOneWithWhereWithoutSprInput, CanvassUpdateWithoutSprInput>, CanvassUncheckedUpdateWithoutSprInput>
  }

  export type VehicleUpdateOneRequiredWithoutSprsNestedInput = {
    create?: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSprsInput
    upsert?: VehicleUpsertWithoutSprsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutSprsInput, VehicleUpdateWithoutSprsInput>, VehicleUncheckedUpdateWithoutSprsInput>
  }

  export type SPRApproverUpdateManyWithoutSprNestedInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    upsert?: SPRApproverUpsertWithWhereUniqueWithoutSprInput | SPRApproverUpsertWithWhereUniqueWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    set?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    disconnect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    delete?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    update?: SPRApproverUpdateWithWhereUniqueWithoutSprInput | SPRApproverUpdateWithWhereUniqueWithoutSprInput[]
    updateMany?: SPRApproverUpdateManyWithWhereWithoutSprInput | SPRApproverUpdateManyWithWhereWithoutSprInput[]
    deleteMany?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
  }

  export type MEQSUncheckedUpdateOneWithoutSprNestedInput = {
    create?: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutSprInput
    upsert?: MEQSUpsertWithoutSprInput
    disconnect?: MEQSWhereInput | boolean
    delete?: MEQSWhereInput | boolean
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutSprInput, MEQSUpdateWithoutSprInput>, MEQSUncheckedUpdateWithoutSprInput>
  }

  export type SPRApproverUncheckedUpdateManyWithoutSprNestedInput = {
    create?: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput> | SPRApproverCreateWithoutSprInput[] | SPRApproverUncheckedCreateWithoutSprInput[]
    connectOrCreate?: SPRApproverCreateOrConnectWithoutSprInput | SPRApproverCreateOrConnectWithoutSprInput[]
    upsert?: SPRApproverUpsertWithWhereUniqueWithoutSprInput | SPRApproverUpsertWithWhereUniqueWithoutSprInput[]
    createMany?: SPRApproverCreateManySprInputEnvelope
    set?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    disconnect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    delete?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    connect?: SPRApproverWhereUniqueInput | SPRApproverWhereUniqueInput[]
    update?: SPRApproverUpdateWithWhereUniqueWithoutSprInput | SPRApproverUpdateWithWhereUniqueWithoutSprInput[]
    updateMany?: SPRApproverUpdateManyWithWhereWithoutSprInput | SPRApproverUpdateManyWithWhereWithoutSprInput[]
    deleteMany?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
  }

  export type SPRCreateNestedOneWithoutSpr_approversInput = {
    create?: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
    connectOrCreate?: SPRCreateOrConnectWithoutSpr_approversInput
    connect?: SPRWhereUniqueInput
  }

  export type SPRUpdateOneRequiredWithoutSpr_approversNestedInput = {
    create?: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
    connectOrCreate?: SPRCreateOrConnectWithoutSpr_approversInput
    upsert?: SPRUpsertWithoutSpr_approversInput
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutSpr_approversInput, SPRUpdateWithoutSpr_approversInput>, SPRUncheckedUpdateWithoutSpr_approversInput>
  }

  export type JOCreateNestedOneWithoutMeqsInput = {
    create?: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: JOCreateOrConnectWithoutMeqsInput
    connect?: JOWhereUniqueInput
  }

  export type RVCreateNestedOneWithoutMeqsInput = {
    create?: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: RVCreateOrConnectWithoutMeqsInput
    connect?: RVWhereUniqueInput
  }

  export type SPRCreateNestedOneWithoutMeqsInput = {
    create?: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: SPRCreateOrConnectWithoutMeqsInput
    connect?: SPRWhereUniqueInput
  }

  export type MEQSApproverCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
  }

  export type MEQSSupplierCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
  }

  export type MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
  }

  export type JOUpdateOneWithoutMeqsNestedInput = {
    create?: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: JOCreateOrConnectWithoutMeqsInput
    upsert?: JOUpsertWithoutMeqsInput
    disconnect?: JOWhereInput | boolean
    delete?: JOWhereInput | boolean
    connect?: JOWhereUniqueInput
    update?: XOR<XOR<JOUpdateToOneWithWhereWithoutMeqsInput, JOUpdateWithoutMeqsInput>, JOUncheckedUpdateWithoutMeqsInput>
  }

  export type RVUpdateOneWithoutMeqsNestedInput = {
    create?: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: RVCreateOrConnectWithoutMeqsInput
    upsert?: RVUpsertWithoutMeqsInput
    disconnect?: RVWhereInput | boolean
    delete?: RVWhereInput | boolean
    connect?: RVWhereUniqueInput
    update?: XOR<XOR<RVUpdateToOneWithWhereWithoutMeqsInput, RVUpdateWithoutMeqsInput>, RVUncheckedUpdateWithoutMeqsInput>
  }

  export type SPRUpdateOneWithoutMeqsNestedInput = {
    create?: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
    connectOrCreate?: SPRCreateOrConnectWithoutMeqsInput
    upsert?: SPRUpsertWithoutMeqsInput
    disconnect?: SPRWhereInput | boolean
    delete?: SPRWhereInput | boolean
    connect?: SPRWhereUniqueInput
    update?: XOR<XOR<SPRUpdateToOneWithWhereWithoutMeqsInput, SPRUpdateWithoutMeqsInput>, SPRUncheckedUpdateWithoutMeqsInput>
  }

  export type MEQSApproverUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput | MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    set?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    disconnect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    delete?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    update?: MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput | MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSApproverUpdateManyWithWhereWithoutMeqsInput | MEQSApproverUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
  }

  export type MEQSSupplierUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutMeqsInput | MEQSSupplierUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput> | MEQSApproverCreateWithoutMeqsInput[] | MEQSApproverUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSApproverCreateOrConnectWithoutMeqsInput | MEQSApproverCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput | MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSApproverCreateManyMeqsInputEnvelope
    set?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    disconnect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    delete?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    connect?: MEQSApproverWhereUniqueInput | MEQSApproverWhereUniqueInput[]
    update?: MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput | MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSApproverUpdateManyWithWhereWithoutMeqsInput | MEQSApproverUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput> | MEQSSupplierCreateWithoutMeqsInput[] | MEQSSupplierUncheckedCreateWithoutMeqsInput[]
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqsInput | MEQSSupplierCreateOrConnectWithoutMeqsInput[]
    upsert?: MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput[]
    createMany?: MEQSSupplierCreateManyMeqsInputEnvelope
    set?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    disconnect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    delete?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    connect?: MEQSSupplierWhereUniqueInput | MEQSSupplierWhereUniqueInput[]
    update?: MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput | MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput[]
    updateMany?: MEQSSupplierUpdateManyWithWhereWithoutMeqsInput | MEQSSupplierUpdateManyWithWhereWithoutMeqsInput[]
    deleteMany?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
  }

  export type MEQSCreateNestedOneWithoutMeqs_suppliersInput = {
    create?: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_suppliersInput
    connect?: MEQSWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutMEQSSupplierInput = {
    create?: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutMEQSSupplierInput
    connect?: SupplierWhereUniqueInput
  }

  export type MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
  }

  export type MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type POCreateNestedOneWithoutMeqs_supplierInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    connect?: POWhereUniqueInput
  }

  export type MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
  }

  export type MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
  }

  export type POUncheckedCreateNestedOneWithoutMeqs_supplierInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    connect?: POWhereUniqueInput
  }

  export type MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput = {
    create?: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_suppliersInput
    upsert?: MEQSUpsertWithoutMeqs_suppliersInput
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutMeqs_suppliersInput, MEQSUpdateWithoutMeqs_suppliersInput>, MEQSUncheckedUpdateWithoutMeqs_suppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput = {
    create?: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutMEQSSupplierInput
    upsert?: SupplierUpsertWithoutMEQSSupplierInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutMEQSSupplierInput, SupplierUpdateWithoutMEQSSupplierInput>, SupplierUncheckedUpdateWithoutMEQSSupplierInput>
  }

  export type MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    disconnect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    delete?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    update?: MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
  }

  export type MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type POUpdateOneWithoutMeqs_supplierNestedInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    upsert?: POUpsertWithoutMeqs_supplierInput
    disconnect?: POWhereInput | boolean
    delete?: POWhereInput | boolean
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutMeqs_supplierInput, POUpdateWithoutMeqs_supplierInput>, POUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput[] | MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    disconnect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    delete?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    connect?: MEQSSupplierAttachmentWhereUniqueInput | MEQSSupplierAttachmentWhereUniqueInput[]
    update?: MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput = {
    create?: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput> | MEQSSupplierItemCreateWithoutMeqs_supplierInput[] | MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput[]
    connectOrCreate?: MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput | MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput[]
    upsert?: MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput[]
    createMany?: MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope
    set?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    disconnect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    delete?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    connect?: MEQSSupplierItemWhereUniqueInput | MEQSSupplierItemWhereUniqueInput[]
    update?: MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput | MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput[]
    updateMany?: MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput | MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput[]
    deleteMany?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
  }

  export type POUncheckedUpdateOneWithoutMeqs_supplierNestedInput = {
    create?: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    connectOrCreate?: POCreateOrConnectWithoutMeqs_supplierInput
    upsert?: POUpsertWithoutMeqs_supplierInput
    disconnect?: POWhereInput | boolean
    delete?: POWhereInput | boolean
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutMeqs_supplierInput, POUpdateWithoutMeqs_supplierInput>, POUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type CanvassItemCreateNestedOneWithoutMeqs_supplier_itemsInput = {
    create?: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: CanvassItemCreateOrConnectWithoutMeqs_supplier_itemsInput
    connect?: CanvassItemWhereUniqueInput
  }

  export type MEQSSupplierCreateNestedOneWithoutMeqs_supplier_itemsInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqs_supplier_itemsInput
    connect?: MEQSSupplierWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CanvassItemUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput = {
    create?: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: CanvassItemCreateOrConnectWithoutMeqs_supplier_itemsInput
    upsert?: CanvassItemUpsertWithoutMeqs_supplier_itemsInput
    connect?: CanvassItemWhereUniqueInput
    update?: XOR<XOR<CanvassItemUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput, CanvassItemUpdateWithoutMeqs_supplier_itemsInput>, CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type MEQSSupplierUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutMeqs_supplier_itemsInput
    upsert?: MEQSSupplierUpsertWithoutMeqs_supplier_itemsInput
    connect?: MEQSSupplierWhereUniqueInput
    update?: XOR<XOR<MEQSSupplierUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput, MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput>, MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type MEQSSupplierCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutAttachmentsInput
    connect?: MEQSSupplierWhereUniqueInput
  }

  export type MEQSSupplierUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutAttachmentsInput
    upsert?: MEQSSupplierUpsertWithoutAttachmentsInput
    connect?: MEQSSupplierWhereUniqueInput
    update?: XOR<XOR<MEQSSupplierUpdateToOneWithWhereWithoutAttachmentsInput, MEQSSupplierUpdateWithoutAttachmentsInput>, MEQSSupplierUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MEQSCreateNestedOneWithoutMeqs_approversInput = {
    create?: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_approversInput
    connect?: MEQSWhereUniqueInput
  }

  export type MEQSUpdateOneRequiredWithoutMeqs_approversNestedInput = {
    create?: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
    connectOrCreate?: MEQSCreateOrConnectWithoutMeqs_approversInput
    upsert?: MEQSUpsertWithoutMeqs_approversInput
    connect?: MEQSWhereUniqueInput
    update?: XOR<XOR<MEQSUpdateToOneWithWhereWithoutMeqs_approversInput, MEQSUpdateWithoutMeqs_approversInput>, MEQSUncheckedUpdateWithoutMeqs_approversInput>
  }

  export type POApproverCreateNestedManyWithoutPoInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
  }

  export type MEQSSupplierCreateNestedOneWithoutPoInput = {
    create?: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutPoInput
    connect?: MEQSSupplierWhereUniqueInput
  }

  export type RRCreateNestedOneWithoutPoInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
    connectOrCreate?: RRCreateOrConnectWithoutPoInput
    connect?: RRWhereUniqueInput
  }

  export type POApproverUncheckedCreateNestedManyWithoutPoInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
  }

  export type RRUncheckedCreateNestedOneWithoutPoInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
    connectOrCreate?: RRCreateOrConnectWithoutPoInput
    connect?: RRWhereUniqueInput
  }

  export type POApproverUpdateManyWithoutPoNestedInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    upsert?: POApproverUpsertWithWhereUniqueWithoutPoInput | POApproverUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    set?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    disconnect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    delete?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    update?: POApproverUpdateWithWhereUniqueWithoutPoInput | POApproverUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: POApproverUpdateManyWithWhereWithoutPoInput | POApproverUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
  }

  export type MEQSSupplierUpdateOneRequiredWithoutPoNestedInput = {
    create?: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
    connectOrCreate?: MEQSSupplierCreateOrConnectWithoutPoInput
    upsert?: MEQSSupplierUpsertWithoutPoInput
    connect?: MEQSSupplierWhereUniqueInput
    update?: XOR<XOR<MEQSSupplierUpdateToOneWithWhereWithoutPoInput, MEQSSupplierUpdateWithoutPoInput>, MEQSSupplierUncheckedUpdateWithoutPoInput>
  }

  export type RRUpdateOneWithoutPoNestedInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
    connectOrCreate?: RRCreateOrConnectWithoutPoInput
    upsert?: RRUpsertWithoutPoInput
    disconnect?: RRWhereInput | boolean
    delete?: RRWhereInput | boolean
    connect?: RRWhereUniqueInput
    update?: XOR<XOR<RRUpdateToOneWithWhereWithoutPoInput, RRUpdateWithoutPoInput>, RRUncheckedUpdateWithoutPoInput>
  }

  export type POApproverUncheckedUpdateManyWithoutPoNestedInput = {
    create?: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput> | POApproverCreateWithoutPoInput[] | POApproverUncheckedCreateWithoutPoInput[]
    connectOrCreate?: POApproverCreateOrConnectWithoutPoInput | POApproverCreateOrConnectWithoutPoInput[]
    upsert?: POApproverUpsertWithWhereUniqueWithoutPoInput | POApproverUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: POApproverCreateManyPoInputEnvelope
    set?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    disconnect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    delete?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    connect?: POApproverWhereUniqueInput | POApproverWhereUniqueInput[]
    update?: POApproverUpdateWithWhereUniqueWithoutPoInput | POApproverUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: POApproverUpdateManyWithWhereWithoutPoInput | POApproverUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
  }

  export type RRUncheckedUpdateOneWithoutPoNestedInput = {
    create?: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
    connectOrCreate?: RRCreateOrConnectWithoutPoInput
    upsert?: RRUpsertWithoutPoInput
    disconnect?: RRWhereInput | boolean
    delete?: RRWhereInput | boolean
    connect?: RRWhereUniqueInput
    update?: XOR<XOR<RRUpdateToOneWithWhereWithoutPoInput, RRUpdateWithoutPoInput>, RRUncheckedUpdateWithoutPoInput>
  }

  export type POCreateNestedOneWithoutPo_approversInput = {
    create?: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
    connectOrCreate?: POCreateOrConnectWithoutPo_approversInput
    connect?: POWhereUniqueInput
  }

  export type POUpdateOneRequiredWithoutPo_approversNestedInput = {
    create?: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
    connectOrCreate?: POCreateOrConnectWithoutPo_approversInput
    upsert?: POUpsertWithoutPo_approversInput
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutPo_approversInput, POUpdateWithoutPo_approversInput>, POUncheckedUpdateWithoutPo_approversInput>
  }

  export type POCreateNestedOneWithoutRrInput = {
    create?: XOR<POCreateWithoutRrInput, POUncheckedCreateWithoutRrInput>
    connectOrCreate?: POCreateOrConnectWithoutRrInput
    connect?: POWhereUniqueInput
  }

  export type RRApproverCreateNestedManyWithoutRrInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
  }

  export type RRItemCreateNestedManyWithoutRrInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type RRApproverUncheckedCreateNestedManyWithoutRrInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
  }

  export type RRItemUncheckedCreateNestedManyWithoutRrInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type POUpdateOneRequiredWithoutRrNestedInput = {
    create?: XOR<POCreateWithoutRrInput, POUncheckedCreateWithoutRrInput>
    connectOrCreate?: POCreateOrConnectWithoutRrInput
    upsert?: POUpsertWithoutRrInput
    connect?: POWhereUniqueInput
    update?: XOR<XOR<POUpdateToOneWithWhereWithoutRrInput, POUpdateWithoutRrInput>, POUncheckedUpdateWithoutRrInput>
  }

  export type RRApproverUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    upsert?: RRApproverUpsertWithWhereUniqueWithoutRrInput | RRApproverUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    set?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    disconnect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    delete?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    update?: RRApproverUpdateWithWhereUniqueWithoutRrInput | RRApproverUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRApproverUpdateManyWithWhereWithoutRrInput | RRApproverUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
  }

  export type RRItemUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutRrInput | RRItemUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutRrInput | RRItemUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutRrInput | RRItemUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type RRApproverUncheckedUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput> | RRApproverCreateWithoutRrInput[] | RRApproverUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRApproverCreateOrConnectWithoutRrInput | RRApproverCreateOrConnectWithoutRrInput[]
    upsert?: RRApproverUpsertWithWhereUniqueWithoutRrInput | RRApproverUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRApproverCreateManyRrInputEnvelope
    set?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    disconnect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    delete?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    connect?: RRApproverWhereUniqueInput | RRApproverWhereUniqueInput[]
    update?: RRApproverUpdateWithWhereUniqueWithoutRrInput | RRApproverUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRApproverUpdateManyWithWhereWithoutRrInput | RRApproverUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
  }

  export type RRItemUncheckedUpdateManyWithoutRrNestedInput = {
    create?: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput> | RRItemCreateWithoutRrInput[] | RRItemUncheckedCreateWithoutRrInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutRrInput | RRItemCreateOrConnectWithoutRrInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutRrInput | RRItemUpsertWithWhereUniqueWithoutRrInput[]
    createMany?: RRItemCreateManyRrInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutRrInput | RRItemUpdateWithWhereUniqueWithoutRrInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutRrInput | RRItemUpdateManyWithWhereWithoutRrInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type RRCreateNestedOneWithoutRr_approversInput = {
    create?: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_approversInput
    connect?: RRWhereUniqueInput
  }

  export type RRUpdateOneRequiredWithoutRr_approversNestedInput = {
    create?: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_approversInput
    upsert?: RRUpsertWithoutRr_approversInput
    connect?: RRWhereUniqueInput
    update?: XOR<XOR<RRUpdateToOneWithWhereWithoutRr_approversInput, RRUpdateWithoutRr_approversInput>, RRUncheckedUpdateWithoutRr_approversInput>
  }

  export type RRCreateNestedOneWithoutRr_itemsInput = {
    create?: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_itemsInput
    connect?: RRWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutRr_itemsInput = {
    create?: XOR<ItemCreateWithoutRr_itemsInput, ItemUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutRr_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutRr_itemsInput = {
    create?: XOR<BrandCreateWithoutRr_itemsInput, BrandUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutRr_itemsInput
    connect?: BrandWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutRr_itemsInput = {
    create?: XOR<UnitCreateWithoutRr_itemsInput, UnitUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRr_itemsInput
    connect?: UnitWhereUniqueInput
  }

  export type ItemTransactionCreateNestedOneWithoutRr_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    connect?: ItemTransactionWhereUniqueInput
  }

  export type RRUpdateOneRequiredWithoutRr_itemsNestedInput = {
    create?: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: RRCreateOrConnectWithoutRr_itemsInput
    upsert?: RRUpsertWithoutRr_itemsInput
    connect?: RRWhereUniqueInput
    update?: XOR<XOR<RRUpdateToOneWithWhereWithoutRr_itemsInput, RRUpdateWithoutRr_itemsInput>, RRUncheckedUpdateWithoutRr_itemsInput>
  }

  export type ItemUpdateOneWithoutRr_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutRr_itemsInput, ItemUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutRr_itemsInput
    upsert?: ItemUpsertWithoutRr_itemsInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutRr_itemsInput, ItemUpdateWithoutRr_itemsInput>, ItemUncheckedUpdateWithoutRr_itemsInput>
  }

  export type BrandUpdateOneWithoutRr_itemsNestedInput = {
    create?: XOR<BrandCreateWithoutRr_itemsInput, BrandUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutRr_itemsInput
    upsert?: BrandUpsertWithoutRr_itemsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutRr_itemsInput, BrandUpdateWithoutRr_itemsInput>, BrandUncheckedUpdateWithoutRr_itemsInput>
  }

  export type UnitUpdateOneWithoutRr_itemsNestedInput = {
    create?: XOR<UnitCreateWithoutRr_itemsInput, UnitUncheckedCreateWithoutRr_itemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRr_itemsInput
    upsert?: UnitUpsertWithoutRr_itemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutRr_itemsInput, UnitUpdateWithoutRr_itemsInput>, UnitUncheckedUpdateWithoutRr_itemsInput>
  }

  export type ItemTransactionUpdateOneWithoutRr_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    upsert?: ItemTransactionUpsertWithoutRr_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutRr_itemInput, ItemTransactionUpdateWithoutRr_itemInput>, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
  }

  export type ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutRr_itemInput
    upsert?: ItemTransactionUpsertWithoutRr_itemInput
    disconnect?: ItemTransactionWhereInput | boolean
    delete?: ItemTransactionWhereInput | boolean
    connect?: ItemTransactionWhereUniqueInput
    update?: XOR<XOR<ItemTransactionUpdateToOneWithWhereWithoutRr_itemInput, ItemTransactionUpdateWithoutRr_itemInput>, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
  }

  export type ItemTypeCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type ItemTransactionCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
  }

  export type RRItemCreateNestedManyWithoutItemInput = {
    create?: XOR<RRItemCreateWithoutItemInput, RRItemUncheckedCreateWithoutItemInput> | RRItemCreateWithoutItemInput[] | RRItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItemInput | RRItemCreateOrConnectWithoutItemInput[]
    createMany?: RRItemCreateManyItemInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type UnitCreateNestedOneWithoutItemsInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type ItemTransactionUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
  }

  export type RRItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<RRItemCreateWithoutItemInput, RRItemUncheckedCreateWithoutItemInput> | RRItemCreateWithoutItemInput[] | RRItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItemInput | RRItemCreateOrConnectWithoutItemInput[]
    createMany?: RRItemCreateManyItemInputEnvelope
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
  }

  export type ItemTypeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    upsert?: ItemTypeUpsertWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutItemsInput, ItemTypeUpdateWithoutItemsInput>, ItemTypeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemTransactionUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    upsert?: ItemTransactionUpsertWithWhereUniqueWithoutItemInput | ItemTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    set?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    disconnect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    delete?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    update?: ItemTransactionUpdateWithWhereUniqueWithoutItemInput | ItemTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemTransactionUpdateManyWithWhereWithoutItemInput | ItemTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
  }

  export type RRItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<RRItemCreateWithoutItemInput, RRItemUncheckedCreateWithoutItemInput> | RRItemCreateWithoutItemInput[] | RRItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItemInput | RRItemCreateOrConnectWithoutItemInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutItemInput | RRItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: RRItemCreateManyItemInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutItemInput | RRItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutItemInput | RRItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type UnitUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    upsert?: UnitUpsertWithoutItemsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutItemsInput, UnitUpdateWithoutItemsInput>, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type ItemTransactionUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput> | ItemTransactionCreateWithoutItemInput[] | ItemTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemTransactionCreateOrConnectWithoutItemInput | ItemTransactionCreateOrConnectWithoutItemInput[]
    upsert?: ItemTransactionUpsertWithWhereUniqueWithoutItemInput | ItemTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemTransactionCreateManyItemInputEnvelope
    set?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    disconnect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    delete?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    connect?: ItemTransactionWhereUniqueInput | ItemTransactionWhereUniqueInput[]
    update?: ItemTransactionUpdateWithWhereUniqueWithoutItemInput | ItemTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemTransactionUpdateManyWithWhereWithoutItemInput | ItemTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
  }

  export type RRItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<RRItemCreateWithoutItemInput, RRItemUncheckedCreateWithoutItemInput> | RRItemCreateWithoutItemInput[] | RRItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: RRItemCreateOrConnectWithoutItemInput | RRItemCreateOrConnectWithoutItemInput[]
    upsert?: RRItemUpsertWithWhereUniqueWithoutItemInput | RRItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: RRItemCreateManyItemInputEnvelope
    set?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    disconnect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    delete?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    connect?: RRItemWhereUniqueInput | RRItemWhereUniqueInput[]
    update?: RRItemUpdateWithWhereUniqueWithoutItemInput | RRItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: RRItemUpdateManyWithWhereWithoutItemInput | RRItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
  }

  export type ItemCreateNestedManyWithoutItem_typeInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutItem_typeInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutItem_typeNestedInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItem_typeInput | ItemUpsertWithWhereUniqueWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItem_typeInput | ItemUpdateWithWhereUniqueWithoutItem_typeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItem_typeInput | ItemUpdateManyWithWhereWithoutItem_typeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutItem_typeNestedInput = {
    create?: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput> | ItemCreateWithoutItem_typeInput[] | ItemUncheckedCreateWithoutItem_typeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItem_typeInput | ItemCreateOrConnectWithoutItem_typeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItem_typeInput | ItemUpsertWithWhereUniqueWithoutItem_typeInput[]
    createMany?: ItemCreateManyItem_typeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItem_typeInput | ItemUpdateWithWhereUniqueWithoutItem_typeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItem_typeInput | ItemUpdateManyWithWhereWithoutItem_typeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutItem_transactionsInput = {
    create?: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_transactionsInput
    connect?: ItemWhereUniqueInput
  }

  export type RRItemCreateNestedOneWithoutItem_transactionInput = {
    create?: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_transactionInput
    connect?: RRItemWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutItem_transactionsNestedInput = {
    create?: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_transactionsInput
    upsert?: ItemUpsertWithoutItem_transactionsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutItem_transactionsInput, ItemUpdateWithoutItem_transactionsInput>, ItemUncheckedUpdateWithoutItem_transactionsInput>
  }

  export type RRItemUpdateOneWithoutItem_transactionNestedInput = {
    create?: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
    connectOrCreate?: RRItemCreateOrConnectWithoutItem_transactionInput
    upsert?: RRItemUpsertWithoutItem_transactionInput
    disconnect?: RRItemWhereInput | boolean
    delete?: RRItemWhereInput | boolean
    connect?: RRItemWhereUniqueInput
    update?: XOR<XOR<RRItemUpdateToOneWithWhereWithoutItem_transactionInput, RRItemUpdateWithoutItem_transactionInput>, RRItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type MEQSSupplierCreateWithoutSupplierInput = {
    id?: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutSupplierInput = {
    id?: string
    meqs_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutSupplierInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type MEQSSupplierCreateManySupplierInputEnvelope = {
    data: MEQSSupplierCreateManySupplierInput | MEQSSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: MEQSSupplierWhereUniqueInput
    update: XOR<MEQSSupplierUpdateWithoutSupplierInput, MEQSSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<MEQSSupplierCreateWithoutSupplierInput, MEQSSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type MEQSSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: MEQSSupplierWhereUniqueInput
    data: XOR<MEQSSupplierUpdateWithoutSupplierInput, MEQSSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type MEQSSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: MEQSSupplierScalarWhereInput
    data: XOR<MEQSSupplierUpdateManyMutationInput, MEQSSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type MEQSSupplierScalarWhereInput = {
    AND?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
    OR?: MEQSSupplierScalarWhereInput[]
    NOT?: MEQSSupplierScalarWhereInput | MEQSSupplierScalarWhereInput[]
    id?: StringFilter<"MEQSSupplier"> | string
    meqs_id?: StringFilter<"MEQSSupplier"> | string
    supplier_id?: StringFilter<"MEQSSupplier"> | string
    payment_terms?: StringFilter<"MEQSSupplier"> | string
    is_referenced?: BoolFilter<"MEQSSupplier"> | boolean
    created_at?: DateTimeFilter<"MEQSSupplier"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplier"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplier"> | boolean
  }

  export type CanvassItemCreateWithoutUnitInput = {
    id?: string
    description: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    brand?: BrandCreateNestedOneWithoutCanvass_itemsInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemUncheckedCreateWithoutUnitInput = {
    id?: string
    canvass_id: string
    description: string
    brand_id?: string | null
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemCreateOrConnectWithoutUnitInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput>
  }

  export type CanvassItemCreateManyUnitInputEnvelope = {
    data: CanvassItemCreateManyUnitInput | CanvassItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type RRItemCreateWithoutUnitInput = {
    id?: string
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr: RRCreateNestedOneWithoutRr_itemsInput
    item?: ItemCreateNestedOneWithoutRr_itemsInput
    item_brand?: BrandCreateNestedOneWithoutRr_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUncheckedCreateWithoutUnitInput = {
    id?: string
    rr_id: string
    item_id?: string | null
    item_brand_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemCreateOrConnectWithoutUnitInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutUnitInput, RRItemUncheckedCreateWithoutUnitInput>
  }

  export type RRItemCreateManyUnitInputEnvelope = {
    data: RRItemCreateManyUnitInput | RRItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutUnitInput = {
    id?: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    rr_items?: RRItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutUnitInput = {
    id?: string
    item_type_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutUnitInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemCreateManyUnitInputEnvelope = {
    data: ItemCreateManyUnitInput | ItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type CanvassItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: CanvassItemWhereUniqueInput
    update: XOR<CanvassItemUpdateWithoutUnitInput, CanvassItemUncheckedUpdateWithoutUnitInput>
    create: XOR<CanvassItemCreateWithoutUnitInput, CanvassItemUncheckedCreateWithoutUnitInput>
  }

  export type CanvassItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: CanvassItemWhereUniqueInput
    data: XOR<CanvassItemUpdateWithoutUnitInput, CanvassItemUncheckedUpdateWithoutUnitInput>
  }

  export type CanvassItemUpdateManyWithWhereWithoutUnitInput = {
    where: CanvassItemScalarWhereInput
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type CanvassItemScalarWhereInput = {
    AND?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
    OR?: CanvassItemScalarWhereInput[]
    NOT?: CanvassItemScalarWhereInput | CanvassItemScalarWhereInput[]
    id?: StringFilter<"CanvassItem"> | string
    canvass_id?: StringFilter<"CanvassItem"> | string
    description?: StringFilter<"CanvassItem"> | string
    brand_id?: StringNullableFilter<"CanvassItem"> | string | null
    unit_id?: StringFilter<"CanvassItem"> | string
    quantity?: IntFilter<"CanvassItem"> | number
    created_at?: DateTimeFilter<"CanvassItem"> | Date | string
    updated_at?: DateTimeFilter<"CanvassItem"> | Date | string
    is_deleted?: BoolFilter<"CanvassItem"> | boolean
  }

  export type RRItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: RRItemWhereUniqueInput
    update: XOR<RRItemUpdateWithoutUnitInput, RRItemUncheckedUpdateWithoutUnitInput>
    create: XOR<RRItemCreateWithoutUnitInput, RRItemUncheckedCreateWithoutUnitInput>
  }

  export type RRItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: RRItemWhereUniqueInput
    data: XOR<RRItemUpdateWithoutUnitInput, RRItemUncheckedUpdateWithoutUnitInput>
  }

  export type RRItemUpdateManyWithWhereWithoutUnitInput = {
    where: RRItemScalarWhereInput
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type RRItemScalarWhereInput = {
    AND?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
    OR?: RRItemScalarWhereInput[]
    NOT?: RRItemScalarWhereInput | RRItemScalarWhereInput[]
    id?: StringFilter<"RRItem"> | string
    rr_id?: StringFilter<"RRItem"> | string
    item_id?: StringNullableFilter<"RRItem"> | string | null
    item_brand_id?: StringNullableFilter<"RRItem"> | string | null
    unit_id?: StringNullableFilter<"RRItem"> | string | null
    item_class?: IntFilter<"RRItem"> | number
    quantity_delivered?: IntFilter<"RRItem"> | number
    quantity_accepted?: IntFilter<"RRItem"> | number
    description?: StringFilter<"RRItem"> | string
    vat_type?: IntFilter<"RRItem"> | number
    gross_price?: FloatFilter<"RRItem"> | number
    net_price?: FloatFilter<"RRItem"> | number
    vat_amount?: FloatFilter<"RRItem"> | number
    created_at?: DateTimeFilter<"RRItem"> | Date | string
    updated_at?: DateTimeFilter<"RRItem"> | Date | string
    is_deleted?: BoolFilter<"RRItem"> | boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
  }

  export type ItemUpdateManyWithWhereWithoutUnitInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    item_type_id?: StringFilter<"Item"> | string
    unit_id?: StringFilter<"Item"> | string
    code?: StringFilter<"Item"> | string
    description?: StringFilter<"Item"> | string
    quantity?: IntFilter<"Item"> | number
    initial_quantity?: IntFilter<"Item"> | number
    created_at?: DateTimeFilter<"Item"> | Date | string
    updated_at?: DateTimeFilter<"Item"> | Date | string
    is_deleted?: BoolFilter<"Item"> | boolean
  }

  export type CanvassItemCreateWithoutBrandInput = {
    id?: string
    description: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    unit: UnitCreateNestedOneWithoutCanvass_itemsInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemUncheckedCreateWithoutBrandInput = {
    id?: string
    canvass_id: string
    description: string
    unit_id: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemCreateOrConnectWithoutBrandInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutBrandInput, CanvassItemUncheckedCreateWithoutBrandInput>
  }

  export type CanvassItemCreateManyBrandInputEnvelope = {
    data: CanvassItemCreateManyBrandInput | CanvassItemCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type RRItemCreateWithoutItem_brandInput = {
    id?: string
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr: RRCreateNestedOneWithoutRr_itemsInput
    item?: ItemCreateNestedOneWithoutRr_itemsInput
    unit?: UnitCreateNestedOneWithoutRr_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUncheckedCreateWithoutItem_brandInput = {
    id?: string
    rr_id: string
    item_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemCreateOrConnectWithoutItem_brandInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutItem_brandInput, RRItemUncheckedCreateWithoutItem_brandInput>
  }

  export type RRItemCreateManyItem_brandInputEnvelope = {
    data: RRItemCreateManyItem_brandInput | RRItemCreateManyItem_brandInput[]
    skipDuplicates?: boolean
  }

  export type CanvassItemUpsertWithWhereUniqueWithoutBrandInput = {
    where: CanvassItemWhereUniqueInput
    update: XOR<CanvassItemUpdateWithoutBrandInput, CanvassItemUncheckedUpdateWithoutBrandInput>
    create: XOR<CanvassItemCreateWithoutBrandInput, CanvassItemUncheckedCreateWithoutBrandInput>
  }

  export type CanvassItemUpdateWithWhereUniqueWithoutBrandInput = {
    where: CanvassItemWhereUniqueInput
    data: XOR<CanvassItemUpdateWithoutBrandInput, CanvassItemUncheckedUpdateWithoutBrandInput>
  }

  export type CanvassItemUpdateManyWithWhereWithoutBrandInput = {
    where: CanvassItemScalarWhereInput
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyWithoutBrandInput>
  }

  export type RRItemUpsertWithWhereUniqueWithoutItem_brandInput = {
    where: RRItemWhereUniqueInput
    update: XOR<RRItemUpdateWithoutItem_brandInput, RRItemUncheckedUpdateWithoutItem_brandInput>
    create: XOR<RRItemCreateWithoutItem_brandInput, RRItemUncheckedCreateWithoutItem_brandInput>
  }

  export type RRItemUpdateWithWhereUniqueWithoutItem_brandInput = {
    where: RRItemWhereUniqueInput
    data: XOR<RRItemUpdateWithoutItem_brandInput, RRItemUncheckedUpdateWithoutItem_brandInput>
  }

  export type RRItemUpdateManyWithWhereWithoutItem_brandInput = {
    where: RRItemScalarWhereInput
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyWithoutItem_brandInput>
  }

  export type SPRCreateWithoutVehicleInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSCreateNestedOneWithoutSprInput
    canvass: CanvassCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateWithoutVehicleInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id: string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutVehicleInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput>
  }

  export type SPRCreateManyVehicleInputEnvelope = {
    data: SPRCreateManyVehicleInput | SPRCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type SPRUpsertWithWhereUniqueWithoutVehicleInput = {
    where: SPRWhereUniqueInput
    update: XOR<SPRUpdateWithoutVehicleInput, SPRUncheckedUpdateWithoutVehicleInput>
    create: XOR<SPRCreateWithoutVehicleInput, SPRUncheckedCreateWithoutVehicleInput>
  }

  export type SPRUpdateWithWhereUniqueWithoutVehicleInput = {
    where: SPRWhereUniqueInput
    data: XOR<SPRUpdateWithoutVehicleInput, SPRUncheckedUpdateWithoutVehicleInput>
  }

  export type SPRUpdateManyWithWhereWithoutVehicleInput = {
    where: SPRScalarWhereInput
    data: XOR<SPRUpdateManyMutationInput, SPRUncheckedUpdateManyWithoutVehicleInput>
  }

  export type SPRScalarWhereInput = {
    AND?: SPRScalarWhereInput | SPRScalarWhereInput[]
    OR?: SPRScalarWhereInput[]
    NOT?: SPRScalarWhereInput | SPRScalarWhereInput[]
    id?: StringFilter<"SPR"> | string
    spr_number?: StringFilter<"SPR"> | string
    date_requested?: DateTimeFilter<"SPR"> | Date | string
    canvass_id?: StringFilter<"SPR"> | string
    vehicle_id?: StringFilter<"SPR"> | string
    classification_id?: StringNullableFilter<"SPR"> | string | null
    supervisor_id?: StringFilter<"SPR"> | string
    status?: IntFilter<"SPR"> | number
    canceller_id?: StringNullableFilter<"SPR"> | string | null
    date_cancelled?: DateTimeNullableFilter<"SPR"> | Date | string | null
    is_referenced?: BoolFilter<"SPR"> | boolean
    created_at?: DateTimeFilter<"SPR"> | Date | string
    updated_at?: DateTimeFilter<"SPR"> | Date | string
    is_deleted?: BoolFilter<"SPR"> | boolean
  }

  export type CanvassCreateWithoutCanvass_itemsInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo?: JOCreateNestedOneWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutCanvass_itemsInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutCanvass_itemsInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
  }

  export type BrandCreateWithoutCanvass_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_items?: RRItemCreateNestedManyWithoutItem_brandInput
  }

  export type BrandUncheckedCreateWithoutCanvass_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_items?: RRItemUncheckedCreateNestedManyWithoutItem_brandInput
  }

  export type BrandCreateOrConnectWithoutCanvass_itemsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutCanvass_itemsInput, BrandUncheckedCreateWithoutCanvass_itemsInput>
  }

  export type UnitCreateWithoutCanvass_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_items?: RRItemCreateNestedManyWithoutUnitInput
    items?: ItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutCanvass_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_items?: RRItemUncheckedCreateNestedManyWithoutUnitInput
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutCanvass_itemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
  }

  export type MEQSSupplierItemCreateWithoutCanvass_itemInput = {
    id?: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutMeqs_supplier_itemsInput
  }

  export type MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput = {
    id?: string
    meqs_supplier_id: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierItemCreateOrConnectWithoutCanvass_itemInput = {
    where: MEQSSupplierItemWhereUniqueInput
    create: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemCreateManyCanvass_itemInputEnvelope = {
    data: MEQSSupplierItemCreateManyCanvass_itemInput | MEQSSupplierItemCreateManyCanvass_itemInput[]
    skipDuplicates?: boolean
  }

  export type CanvassUpsertWithoutCanvass_itemsInput = {
    update: XOR<CanvassUpdateWithoutCanvass_itemsInput, CanvassUncheckedUpdateWithoutCanvass_itemsInput>
    create: XOR<CanvassCreateWithoutCanvass_itemsInput, CanvassUncheckedCreateWithoutCanvass_itemsInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutCanvass_itemsInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutCanvass_itemsInput, CanvassUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type CanvassUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUpdateOneWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type BrandUpsertWithoutCanvass_itemsInput = {
    update: XOR<BrandUpdateWithoutCanvass_itemsInput, BrandUncheckedUpdateWithoutCanvass_itemsInput>
    create: XOR<BrandCreateWithoutCanvass_itemsInput, BrandUncheckedCreateWithoutCanvass_itemsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutCanvass_itemsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutCanvass_itemsInput, BrandUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type BrandUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_items?: RRItemUpdateManyWithoutItem_brandNestedInput
  }

  export type BrandUncheckedUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_items?: RRItemUncheckedUpdateManyWithoutItem_brandNestedInput
  }

  export type UnitUpsertWithoutCanvass_itemsInput = {
    update: XOR<UnitUpdateWithoutCanvass_itemsInput, UnitUncheckedUpdateWithoutCanvass_itemsInput>
    create: XOR<UnitCreateWithoutCanvass_itemsInput, UnitUncheckedCreateWithoutCanvass_itemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutCanvass_itemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutCanvass_itemsInput, UnitUncheckedUpdateWithoutCanvass_itemsInput>
  }

  export type UnitUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_items?: RRItemUpdateManyWithoutUnitNestedInput
    items?: ItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutCanvass_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_items?: RRItemUncheckedUpdateManyWithoutUnitNestedInput
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type MEQSSupplierItemUpsertWithWhereUniqueWithoutCanvass_itemInput = {
    where: MEQSSupplierItemWhereUniqueInput
    update: XOR<MEQSSupplierItemUpdateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedUpdateWithoutCanvass_itemInput>
    create: XOR<MEQSSupplierItemCreateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedCreateWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemUpdateWithWhereUniqueWithoutCanvass_itemInput = {
    where: MEQSSupplierItemWhereUniqueInput
    data: XOR<MEQSSupplierItemUpdateWithoutCanvass_itemInput, MEQSSupplierItemUncheckedUpdateWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemUpdateManyWithWhereWithoutCanvass_itemInput = {
    where: MEQSSupplierItemScalarWhereInput
    data: XOR<MEQSSupplierItemUpdateManyMutationInput, MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemInput>
  }

  export type MEQSSupplierItemScalarWhereInput = {
    AND?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
    OR?: MEQSSupplierItemScalarWhereInput[]
    NOT?: MEQSSupplierItemScalarWhereInput | MEQSSupplierItemScalarWhereInput[]
    id?: StringFilter<"MEQSSupplierItem"> | string
    canvass_item_id?: StringFilter<"MEQSSupplierItem"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierItem"> | string
    price?: FloatFilter<"MEQSSupplierItem"> | number
    is_awarded?: BoolFilter<"MEQSSupplierItem"> | boolean
    notes?: StringNullableFilter<"MEQSSupplierItem"> | string | null
    vat_type?: IntFilter<"MEQSSupplierItem"> | number
    created_at?: DateTimeFilter<"MEQSSupplierItem"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplierItem"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplierItem"> | boolean
  }

  export type CanvassItemCreateWithoutCanvassInput = {
    id?: string
    description: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    brand?: BrandCreateNestedOneWithoutCanvass_itemsInput
    unit: UnitCreateNestedOneWithoutCanvass_itemsInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemUncheckedCreateWithoutCanvassInput = {
    id?: string
    description: string
    brand_id?: string | null
    unit_id: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutCanvass_itemInput
  }

  export type CanvassItemCreateOrConnectWithoutCanvassInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput>
  }

  export type CanvassItemCreateManyCanvassInputEnvelope = {
    data: CanvassItemCreateManyCanvassInput | CanvassItemCreateManyCanvassInput[]
    skipDuplicates?: boolean
  }

  export type JOCreateWithoutCanvassInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo_approvers?: JOApproverCreateNestedManyWithoutJoInput
    meqs?: MEQSCreateNestedOneWithoutJoInput
  }

  export type JOUncheckedCreateWithoutCanvassInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo_approvers?: JOApproverUncheckedCreateNestedManyWithoutJoInput
    meqs?: MEQSUncheckedCreateNestedOneWithoutJoInput
  }

  export type JOCreateOrConnectWithoutCanvassInput = {
    where: JOWhereUniqueInput
    create: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
  }

  export type RVCreateWithoutCanvassInput = {
    id?: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverCreateNestedManyWithoutRvInput
  }

  export type RVUncheckedCreateWithoutCanvassInput = {
    id?: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverUncheckedCreateNestedManyWithoutRvInput
  }

  export type RVCreateOrConnectWithoutCanvassInput = {
    where: RVWhereUniqueInput
    create: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
  }

  export type SPRCreateWithoutCanvassInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateWithoutCanvassInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutCanvassInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
  }

  export type CanvassItemUpsertWithWhereUniqueWithoutCanvassInput = {
    where: CanvassItemWhereUniqueInput
    update: XOR<CanvassItemUpdateWithoutCanvassInput, CanvassItemUncheckedUpdateWithoutCanvassInput>
    create: XOR<CanvassItemCreateWithoutCanvassInput, CanvassItemUncheckedCreateWithoutCanvassInput>
  }

  export type CanvassItemUpdateWithWhereUniqueWithoutCanvassInput = {
    where: CanvassItemWhereUniqueInput
    data: XOR<CanvassItemUpdateWithoutCanvassInput, CanvassItemUncheckedUpdateWithoutCanvassInput>
  }

  export type CanvassItemUpdateManyWithWhereWithoutCanvassInput = {
    where: CanvassItemScalarWhereInput
    data: XOR<CanvassItemUpdateManyMutationInput, CanvassItemUncheckedUpdateManyWithoutCanvassInput>
  }

  export type JOUpsertWithoutCanvassInput = {
    update: XOR<JOUpdateWithoutCanvassInput, JOUncheckedUpdateWithoutCanvassInput>
    create: XOR<JOCreateWithoutCanvassInput, JOUncheckedCreateWithoutCanvassInput>
    where?: JOWhereInput
  }

  export type JOUpdateToOneWithWhereWithoutCanvassInput = {
    where?: JOWhereInput
    data: XOR<JOUpdateWithoutCanvassInput, JOUncheckedUpdateWithoutCanvassInput>
  }

  export type JOUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo_approvers?: JOApproverUpdateManyWithoutJoNestedInput
    meqs?: MEQSUpdateOneWithoutJoNestedInput
  }

  export type JOUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo_approvers?: JOApproverUncheckedUpdateManyWithoutJoNestedInput
    meqs?: MEQSUncheckedUpdateOneWithoutJoNestedInput
  }

  export type RVUpsertWithoutCanvassInput = {
    update: XOR<RVUpdateWithoutCanvassInput, RVUncheckedUpdateWithoutCanvassInput>
    create: XOR<RVCreateWithoutCanvassInput, RVUncheckedCreateWithoutCanvassInput>
    where?: RVWhereInput
  }

  export type RVUpdateToOneWithWhereWithoutCanvassInput = {
    where?: RVWhereInput
    data: XOR<RVUpdateWithoutCanvassInput, RVUncheckedUpdateWithoutCanvassInput>
  }

  export type RVUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUpdateManyWithoutRvNestedInput
  }

  export type RVUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutRvNestedInput
    rv_approvers?: RVApproverUncheckedUpdateManyWithoutRvNestedInput
  }

  export type SPRUpsertWithoutCanvassInput = {
    update: XOR<SPRUpdateWithoutCanvassInput, SPRUncheckedUpdateWithoutCanvassInput>
    create: XOR<SPRCreateWithoutCanvassInput, SPRUncheckedCreateWithoutCanvassInput>
    where?: SPRWhereInput
  }

  export type SPRUpdateToOneWithWhereWithoutCanvassInput = {
    where?: SPRWhereInput
    data: XOR<SPRUpdateWithoutCanvassInput, SPRUncheckedUpdateWithoutCanvassInput>
  }

  export type SPRUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type JOApproverCreateWithoutJoInput = {
    id?: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type JOApproverUncheckedCreateWithoutJoInput = {
    id?: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type JOApproverCreateOrConnectWithoutJoInput = {
    where: JOApproverWhereUniqueInput
    create: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput>
  }

  export type JOApproverCreateManyJoInputEnvelope = {
    data: JOApproverCreateManyJoInput | JOApproverCreateManyJoInput[]
    skipDuplicates?: boolean
  }

  export type CanvassCreateWithoutJoInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutJoInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutJoInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
  }

  export type MEQSCreateWithoutJoInput = {
    id?: string
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutJoInput = {
    id?: string
    rv_id?: string | null
    spr_id?: string | null
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutJoInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
  }

  export type JOApproverUpsertWithWhereUniqueWithoutJoInput = {
    where: JOApproverWhereUniqueInput
    update: XOR<JOApproverUpdateWithoutJoInput, JOApproverUncheckedUpdateWithoutJoInput>
    create: XOR<JOApproverCreateWithoutJoInput, JOApproverUncheckedCreateWithoutJoInput>
  }

  export type JOApproverUpdateWithWhereUniqueWithoutJoInput = {
    where: JOApproverWhereUniqueInput
    data: XOR<JOApproverUpdateWithoutJoInput, JOApproverUncheckedUpdateWithoutJoInput>
  }

  export type JOApproverUpdateManyWithWhereWithoutJoInput = {
    where: JOApproverScalarWhereInput
    data: XOR<JOApproverUpdateManyMutationInput, JOApproverUncheckedUpdateManyWithoutJoInput>
  }

  export type JOApproverScalarWhereInput = {
    AND?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
    OR?: JOApproverScalarWhereInput[]
    NOT?: JOApproverScalarWhereInput | JOApproverScalarWhereInput[]
    id?: StringFilter<"JOApprover"> | string
    jo_id?: StringFilter<"JOApprover"> | string
    approver_proxy_id?: StringNullableFilter<"JOApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"JOApprover"> | Date | string | null
    notes?: StringNullableFilter<"JOApprover"> | string | null
    status?: IntFilter<"JOApprover"> | number
    label?: StringFilter<"JOApprover"> | string
    order?: IntFilter<"JOApprover"> | number
    created_at?: DateTimeFilter<"JOApprover"> | Date | string
    updated_at?: DateTimeFilter<"JOApprover"> | Date | string
    is_deleted?: BoolFilter<"JOApprover"> | boolean
  }

  export type CanvassUpsertWithoutJoInput = {
    update: XOR<CanvassUpdateWithoutJoInput, CanvassUncheckedUpdateWithoutJoInput>
    create: XOR<CanvassCreateWithoutJoInput, CanvassUncheckedCreateWithoutJoInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutJoInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutJoInput, CanvassUncheckedUpdateWithoutJoInput>
  }

  export type CanvassUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type MEQSUpsertWithoutJoInput = {
    update: XOR<MEQSUpdateWithoutJoInput, MEQSUncheckedUpdateWithoutJoInput>
    create: XOR<MEQSCreateWithoutJoInput, MEQSUncheckedCreateWithoutJoInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutJoInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutJoInput, MEQSUncheckedUpdateWithoutJoInput>
  }

  export type MEQSUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type JOCreateWithoutJo_approversInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutJoInput
    meqs?: MEQSCreateNestedOneWithoutJoInput
  }

  export type JOUncheckedCreateWithoutJo_approversInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id: string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutJoInput
  }

  export type JOCreateOrConnectWithoutJo_approversInput = {
    where: JOWhereUniqueInput
    create: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
  }

  export type JOUpsertWithoutJo_approversInput = {
    update: XOR<JOUpdateWithoutJo_approversInput, JOUncheckedUpdateWithoutJo_approversInput>
    create: XOR<JOCreateWithoutJo_approversInput, JOUncheckedCreateWithoutJo_approversInput>
    where?: JOWhereInput
  }

  export type JOUpdateToOneWithWhereWithoutJo_approversInput = {
    where?: JOWhereInput
    data: XOR<JOUpdateWithoutJo_approversInput, JOUncheckedUpdateWithoutJo_approversInput>
  }

  export type JOUpdateWithoutJo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutJoNestedInput
    meqs?: MEQSUpdateOneWithoutJoNestedInput
  }

  export type JOUncheckedUpdateWithoutJo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutJoNestedInput
  }

  export type CanvassCreateWithoutRvInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    jo?: JOCreateNestedOneWithoutCanvassInput
    spr?: SPRCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutRvInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    spr?: SPRUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutRvInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
  }

  export type MEQSCreateWithoutRvInput = {
    id?: string
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo?: JOCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutRvInput = {
    id?: string
    jo_id?: string | null
    spr_id?: string | null
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutRvInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
  }

  export type RVApproverCreateWithoutRvInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RVApproverUncheckedCreateWithoutRvInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RVApproverCreateOrConnectWithoutRvInput = {
    where: RVApproverWhereUniqueInput
    create: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput>
  }

  export type RVApproverCreateManyRvInputEnvelope = {
    data: RVApproverCreateManyRvInput | RVApproverCreateManyRvInput[]
    skipDuplicates?: boolean
  }

  export type CanvassUpsertWithoutRvInput = {
    update: XOR<CanvassUpdateWithoutRvInput, CanvassUncheckedUpdateWithoutRvInput>
    create: XOR<CanvassCreateWithoutRvInput, CanvassUncheckedCreateWithoutRvInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutRvInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutRvInput, CanvassUncheckedUpdateWithoutRvInput>
  }

  export type CanvassUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    jo?: JOUpdateOneWithoutCanvassNestedInput
    spr?: SPRUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    spr?: SPRUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type MEQSUpsertWithoutRvInput = {
    update: XOR<MEQSUpdateWithoutRvInput, MEQSUncheckedUpdateWithoutRvInput>
    create: XOR<MEQSCreateWithoutRvInput, MEQSUncheckedCreateWithoutRvInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutRvInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutRvInput, MEQSUncheckedUpdateWithoutRvInput>
  }

  export type MEQSUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type RVApproverUpsertWithWhereUniqueWithoutRvInput = {
    where: RVApproverWhereUniqueInput
    update: XOR<RVApproverUpdateWithoutRvInput, RVApproverUncheckedUpdateWithoutRvInput>
    create: XOR<RVApproverCreateWithoutRvInput, RVApproverUncheckedCreateWithoutRvInput>
  }

  export type RVApproverUpdateWithWhereUniqueWithoutRvInput = {
    where: RVApproverWhereUniqueInput
    data: XOR<RVApproverUpdateWithoutRvInput, RVApproverUncheckedUpdateWithoutRvInput>
  }

  export type RVApproverUpdateManyWithWhereWithoutRvInput = {
    where: RVApproverScalarWhereInput
    data: XOR<RVApproverUpdateManyMutationInput, RVApproverUncheckedUpdateManyWithoutRvInput>
  }

  export type RVApproverScalarWhereInput = {
    AND?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
    OR?: RVApproverScalarWhereInput[]
    NOT?: RVApproverScalarWhereInput | RVApproverScalarWhereInput[]
    id?: StringFilter<"RVApprover"> | string
    rv_id?: StringFilter<"RVApprover"> | string
    approver_id?: StringFilter<"RVApprover"> | string
    approver_proxy_id?: StringNullableFilter<"RVApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"RVApprover"> | Date | string | null
    notes?: StringNullableFilter<"RVApprover"> | string | null
    status?: IntFilter<"RVApprover"> | number
    label?: StringFilter<"RVApprover"> | string
    order?: IntFilter<"RVApprover"> | number
    created_at?: DateTimeFilter<"RVApprover"> | Date | string
    updated_at?: DateTimeFilter<"RVApprover"> | Date | string
    is_deleted?: BoolFilter<"RVApprover"> | boolean
  }

  export type RVCreateWithoutRv_approversInput = {
    id?: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutRvInput
    meqs?: MEQSCreateNestedOneWithoutRvInput
  }

  export type RVUncheckedCreateWithoutRv_approversInput = {
    id?: string
    canvass_id: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutRvInput
  }

  export type RVCreateOrConnectWithoutRv_approversInput = {
    where: RVWhereUniqueInput
    create: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
  }

  export type RVUpsertWithoutRv_approversInput = {
    update: XOR<RVUpdateWithoutRv_approversInput, RVUncheckedUpdateWithoutRv_approversInput>
    create: XOR<RVCreateWithoutRv_approversInput, RVUncheckedCreateWithoutRv_approversInput>
    where?: RVWhereInput
  }

  export type RVUpdateToOneWithWhereWithoutRv_approversInput = {
    where?: RVWhereInput
    data: XOR<RVUpdateWithoutRv_approversInput, RVUncheckedUpdateWithoutRv_approversInput>
  }

  export type RVUpdateWithoutRv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutRvNestedInput
    meqs?: MEQSUpdateOneWithoutRvNestedInput
  }

  export type RVUncheckedUpdateWithoutRv_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutRvNestedInput
  }

  export type MEQSCreateWithoutSprInput = {
    id?: string
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutSprInput = {
    id?: string
    jo_id?: string | null
    rv_id?: string | null
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutSprInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
  }

  export type CanvassCreateWithoutSprInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutCanvassInput
    jo?: JOCreateNestedOneWithoutCanvassInput
    rv?: RVCreateNestedOneWithoutCanvassInput
  }

  export type CanvassUncheckedCreateWithoutSprInput = {
    id?: string
    rc_number: string
    date_requested: Date | string
    purpose: string
    notes?: string | null
    requested_by_id: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutCanvassInput
    jo?: JOUncheckedCreateNestedOneWithoutCanvassInput
    rv?: RVUncheckedCreateNestedOneWithoutCanvassInput
  }

  export type CanvassCreateOrConnectWithoutSprInput = {
    where: CanvassWhereUniqueInput
    create: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
  }

  export type VehicleCreateWithoutSprsInput = {
    id?: string
    name: string
    plate_number: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type VehicleUncheckedCreateWithoutSprsInput = {
    id?: string
    name: string
    plate_number: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type VehicleCreateOrConnectWithoutSprsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
  }

  export type SPRApproverCreateWithoutSprInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SPRApproverUncheckedCreateWithoutSprInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SPRApproverCreateOrConnectWithoutSprInput = {
    where: SPRApproverWhereUniqueInput
    create: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput>
  }

  export type SPRApproverCreateManySprInputEnvelope = {
    data: SPRApproverCreateManySprInput | SPRApproverCreateManySprInput[]
    skipDuplicates?: boolean
  }

  export type MEQSUpsertWithoutSprInput = {
    update: XOR<MEQSUpdateWithoutSprInput, MEQSUncheckedUpdateWithoutSprInput>
    create: XOR<MEQSCreateWithoutSprInput, MEQSUncheckedCreateWithoutSprInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutSprInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutSprInput, MEQSUncheckedUpdateWithoutSprInput>
  }

  export type MEQSUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type CanvassUpsertWithoutSprInput = {
    update: XOR<CanvassUpdateWithoutSprInput, CanvassUncheckedUpdateWithoutSprInput>
    create: XOR<CanvassCreateWithoutSprInput, CanvassUncheckedCreateWithoutSprInput>
    where?: CanvassWhereInput
  }

  export type CanvassUpdateToOneWithWhereWithoutSprInput = {
    where?: CanvassWhereInput
    data: XOR<CanvassUpdateWithoutSprInput, CanvassUncheckedUpdateWithoutSprInput>
  }

  export type CanvassUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutCanvassNestedInput
    jo?: JOUpdateOneWithoutCanvassNestedInput
    rv?: RVUpdateOneWithoutCanvassNestedInput
  }

  export type CanvassUncheckedUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requested_by_id?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutCanvassNestedInput
    jo?: JOUncheckedUpdateOneWithoutCanvassNestedInput
    rv?: RVUncheckedUpdateOneWithoutCanvassNestedInput
  }

  export type VehicleUpsertWithoutSprsInput = {
    update: XOR<VehicleUpdateWithoutSprsInput, VehicleUncheckedUpdateWithoutSprsInput>
    create: XOR<VehicleCreateWithoutSprsInput, VehicleUncheckedCreateWithoutSprsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutSprsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutSprsInput, VehicleUncheckedUpdateWithoutSprsInput>
  }

  export type VehicleUpdateWithoutSprsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleUncheckedUpdateWithoutSprsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    plate_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRApproverUpsertWithWhereUniqueWithoutSprInput = {
    where: SPRApproverWhereUniqueInput
    update: XOR<SPRApproverUpdateWithoutSprInput, SPRApproverUncheckedUpdateWithoutSprInput>
    create: XOR<SPRApproverCreateWithoutSprInput, SPRApproverUncheckedCreateWithoutSprInput>
  }

  export type SPRApproverUpdateWithWhereUniqueWithoutSprInput = {
    where: SPRApproverWhereUniqueInput
    data: XOR<SPRApproverUpdateWithoutSprInput, SPRApproverUncheckedUpdateWithoutSprInput>
  }

  export type SPRApproverUpdateManyWithWhereWithoutSprInput = {
    where: SPRApproverScalarWhereInput
    data: XOR<SPRApproverUpdateManyMutationInput, SPRApproverUncheckedUpdateManyWithoutSprInput>
  }

  export type SPRApproverScalarWhereInput = {
    AND?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
    OR?: SPRApproverScalarWhereInput[]
    NOT?: SPRApproverScalarWhereInput | SPRApproverScalarWhereInput[]
    id?: StringFilter<"SPRApprover"> | string
    spr_id?: StringFilter<"SPRApprover"> | string
    approver_id?: StringFilter<"SPRApprover"> | string
    approver_proxy_id?: StringNullableFilter<"SPRApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"SPRApprover"> | Date | string | null
    notes?: StringNullableFilter<"SPRApprover"> | string | null
    status?: IntFilter<"SPRApprover"> | number
    label?: StringFilter<"SPRApprover"> | string
    order?: IntFilter<"SPRApprover"> | number
    created_at?: DateTimeFilter<"SPRApprover"> | Date | string
    updated_at?: DateTimeFilter<"SPRApprover"> | Date | string
    is_deleted?: BoolFilter<"SPRApprover"> | boolean
  }

  export type SPRCreateWithoutSpr_approversInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSCreateNestedOneWithoutSprInput
    canvass: CanvassCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
  }

  export type SPRUncheckedCreateWithoutSpr_approversInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id: string
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs?: MEQSUncheckedCreateNestedOneWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutSpr_approversInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
  }

  export type SPRUpsertWithoutSpr_approversInput = {
    update: XOR<SPRUpdateWithoutSpr_approversInput, SPRUncheckedUpdateWithoutSpr_approversInput>
    create: XOR<SPRCreateWithoutSpr_approversInput, SPRUncheckedCreateWithoutSpr_approversInput>
    where?: SPRWhereInput
  }

  export type SPRUpdateToOneWithWhereWithoutSpr_approversInput = {
    where?: SPRWhereInput
    data: XOR<SPRUpdateWithoutSpr_approversInput, SPRUncheckedUpdateWithoutSpr_approversInput>
  }

  export type SPRUpdateWithoutSpr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
  }

  export type SPRUncheckedUpdateWithoutSpr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
  }

  export type JOCreateWithoutMeqsInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo_approvers?: JOApproverCreateNestedManyWithoutJoInput
    canvass: CanvassCreateNestedOneWithoutJoInput
  }

  export type JOUncheckedCreateWithoutMeqsInput = {
    id?: string
    jo_number: string
    date_requested: Date | string
    canvass_id: string
    equipment: string
    classification_id?: string | null
    department_id: string
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo_approvers?: JOApproverUncheckedCreateNestedManyWithoutJoInput
  }

  export type JOCreateOrConnectWithoutMeqsInput = {
    where: JOWhereUniqueInput
    create: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
  }

  export type RVCreateWithoutMeqsInput = {
    id?: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutRvInput
    rv_approvers?: RVApproverCreateNestedManyWithoutRvInput
  }

  export type RVUncheckedCreateWithoutMeqsInput = {
    id?: string
    canvass_id: string
    classification_id?: string | null
    supervisor_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    rv_number: string
    date_requested: Date | string
    work_order_no?: string | null
    work_order_date?: Date | string | null
    status?: number
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rv_approvers?: RVApproverUncheckedCreateNestedManyWithoutRvInput
  }

  export type RVCreateOrConnectWithoutMeqsInput = {
    where: RVWhereUniqueInput
    create: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
  }

  export type SPRCreateWithoutMeqsInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutSprInput
    vehicle: VehicleCreateNestedOneWithoutSprsInput
    spr_approvers?: SPRApproverCreateNestedManyWithoutSprInput
  }

  export type SPRUncheckedCreateWithoutMeqsInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id: string
    vehicle_id: string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    spr_approvers?: SPRApproverUncheckedCreateNestedManyWithoutSprInput
  }

  export type SPRCreateOrConnectWithoutMeqsInput = {
    where: SPRWhereUniqueInput
    create: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSApproverCreateWithoutMeqsInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSApproverUncheckedCreateWithoutMeqsInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSApproverCreateOrConnectWithoutMeqsInput = {
    where: MEQSApproverWhereUniqueInput
    create: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSApproverCreateManyMeqsInputEnvelope = {
    data: MEQSApproverCreateManyMeqsInput | MEQSApproverCreateManyMeqsInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierCreateWithoutMeqsInput = {
    id?: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutMeqsInput = {
    id?: string
    supplier_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutMeqsInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSSupplierCreateManyMeqsInputEnvelope = {
    data: MEQSSupplierCreateManyMeqsInput | MEQSSupplierCreateManyMeqsInput[]
    skipDuplicates?: boolean
  }

  export type JOUpsertWithoutMeqsInput = {
    update: XOR<JOUpdateWithoutMeqsInput, JOUncheckedUpdateWithoutMeqsInput>
    create: XOR<JOCreateWithoutMeqsInput, JOUncheckedCreateWithoutMeqsInput>
    where?: JOWhereInput
  }

  export type JOUpdateToOneWithWhereWithoutMeqsInput = {
    where?: JOWhereInput
    data: XOR<JOUpdateWithoutMeqsInput, JOUncheckedUpdateWithoutMeqsInput>
  }

  export type JOUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo_approvers?: JOApproverUpdateManyWithoutJoNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutJoNestedInput
  }

  export type JOUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    equipment?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo_approvers?: JOApproverUncheckedUpdateManyWithoutJoNestedInput
  }

  export type RVUpsertWithoutMeqsInput = {
    update: XOR<RVUpdateWithoutMeqsInput, RVUncheckedUpdateWithoutMeqsInput>
    create: XOR<RVCreateWithoutMeqsInput, RVUncheckedCreateWithoutMeqsInput>
    where?: RVWhereInput
  }

  export type RVUpdateToOneWithWhereWithoutMeqsInput = {
    where?: RVWhereInput
    data: XOR<RVUpdateWithoutMeqsInput, RVUncheckedUpdateWithoutMeqsInput>
  }

  export type RVUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutRvNestedInput
    rv_approvers?: RVApproverUpdateManyWithoutRvNestedInput
  }

  export type RVUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rv_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    work_order_no?: NullableStringFieldUpdateOperationsInput | string | null
    work_order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rv_approvers?: RVApproverUncheckedUpdateManyWithoutRvNestedInput
  }

  export type SPRUpsertWithoutMeqsInput = {
    update: XOR<SPRUpdateWithoutMeqsInput, SPRUncheckedUpdateWithoutMeqsInput>
    create: XOR<SPRCreateWithoutMeqsInput, SPRUncheckedCreateWithoutMeqsInput>
    where?: SPRWhereInput
  }

  export type SPRUpdateToOneWithWhereWithoutMeqsInput = {
    where?: SPRWhereInput
    data: XOR<SPRUpdateWithoutMeqsInput, SPRUncheckedUpdateWithoutMeqsInput>
  }

  export type SPRUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutSprNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSprsNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type MEQSApproverUpsertWithWhereUniqueWithoutMeqsInput = {
    where: MEQSApproverWhereUniqueInput
    update: XOR<MEQSApproverUpdateWithoutMeqsInput, MEQSApproverUncheckedUpdateWithoutMeqsInput>
    create: XOR<MEQSApproverCreateWithoutMeqsInput, MEQSApproverUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSApproverUpdateWithWhereUniqueWithoutMeqsInput = {
    where: MEQSApproverWhereUniqueInput
    data: XOR<MEQSApproverUpdateWithoutMeqsInput, MEQSApproverUncheckedUpdateWithoutMeqsInput>
  }

  export type MEQSApproverUpdateManyWithWhereWithoutMeqsInput = {
    where: MEQSApproverScalarWhereInput
    data: XOR<MEQSApproverUpdateManyMutationInput, MEQSApproverUncheckedUpdateManyWithoutMeqsInput>
  }

  export type MEQSApproverScalarWhereInput = {
    AND?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
    OR?: MEQSApproverScalarWhereInput[]
    NOT?: MEQSApproverScalarWhereInput | MEQSApproverScalarWhereInput[]
    id?: StringFilter<"MEQSApprover"> | string
    meqs_id?: StringFilter<"MEQSApprover"> | string
    approver_id?: StringFilter<"MEQSApprover"> | string
    approver_proxy_id?: StringNullableFilter<"MEQSApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"MEQSApprover"> | Date | string | null
    notes?: StringNullableFilter<"MEQSApprover"> | string | null
    status?: IntFilter<"MEQSApprover"> | number
    label?: StringFilter<"MEQSApprover"> | string
    order?: IntFilter<"MEQSApprover"> | number
    created_at?: DateTimeFilter<"MEQSApprover"> | Date | string
    updated_at?: DateTimeFilter<"MEQSApprover"> | Date | string
    is_deleted?: BoolFilter<"MEQSApprover"> | boolean
  }

  export type MEQSSupplierUpsertWithWhereUniqueWithoutMeqsInput = {
    where: MEQSSupplierWhereUniqueInput
    update: XOR<MEQSSupplierUpdateWithoutMeqsInput, MEQSSupplierUncheckedUpdateWithoutMeqsInput>
    create: XOR<MEQSSupplierCreateWithoutMeqsInput, MEQSSupplierUncheckedCreateWithoutMeqsInput>
  }

  export type MEQSSupplierUpdateWithWhereUniqueWithoutMeqsInput = {
    where: MEQSSupplierWhereUniqueInput
    data: XOR<MEQSSupplierUpdateWithoutMeqsInput, MEQSSupplierUncheckedUpdateWithoutMeqsInput>
  }

  export type MEQSSupplierUpdateManyWithWhereWithoutMeqsInput = {
    where: MEQSSupplierScalarWhereInput
    data: XOR<MEQSSupplierUpdateManyMutationInput, MEQSSupplierUncheckedUpdateManyWithoutMeqsInput>
  }

  export type MEQSCreateWithoutMeqs_suppliersInput = {
    id?: string
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_approvers?: MEQSApproverCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutMeqs_suppliersInput = {
    id?: string
    jo_id?: string | null
    rv_id?: string | null
    spr_id?: string | null
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_approvers?: MEQSApproverUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutMeqs_suppliersInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
  }

  export type SupplierCreateWithoutMEQSSupplierInput = {
    id?: string
    name: string
    contact: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SupplierUncheckedCreateWithoutMEQSSupplierInput = {
    id?: string
    name: string
    contact: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SupplierCreateOrConnectWithoutMEQSSupplierInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
  }

  export type MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput = {
    id?: string
    src: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput = {
    id?: string
    src: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierAttachmentCreateOrConnectWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentWhereUniqueInput
    create: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentCreateManyMeqs_supplierInputEnvelope = {
    data: MEQSSupplierAttachmentCreateManyMeqs_supplierInput | MEQSSupplierAttachmentCreateManyMeqs_supplierInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierItemCreateWithoutMeqs_supplierInput = {
    id?: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_item: CanvassItemCreateNestedOneWithoutMeqs_supplier_itemsInput
  }

  export type MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput = {
    id?: string
    canvass_item_id: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierItemCreateOrConnectWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemWhereUniqueInput
    create: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierItemCreateManyMeqs_supplierInputEnvelope = {
    data: MEQSSupplierItemCreateManyMeqs_supplierInput | MEQSSupplierItemCreateManyMeqs_supplierInput[]
    skipDuplicates?: boolean
  }

  export type POCreateWithoutMeqs_supplierInput = {
    id?: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    po_approvers?: POApproverCreateNestedManyWithoutPoInput
    rr?: RRCreateNestedOneWithoutPoInput
  }

  export type POUncheckedCreateWithoutMeqs_supplierInput = {
    id?: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    po_approvers?: POApproverUncheckedCreateNestedManyWithoutPoInput
    rr?: RRUncheckedCreateNestedOneWithoutPoInput
  }

  export type POCreateOrConnectWithoutMeqs_supplierInput = {
    where: POWhereUniqueInput
    create: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSUpsertWithoutMeqs_suppliersInput = {
    update: XOR<MEQSUpdateWithoutMeqs_suppliersInput, MEQSUncheckedUpdateWithoutMeqs_suppliersInput>
    create: XOR<MEQSCreateWithoutMeqs_suppliersInput, MEQSUncheckedCreateWithoutMeqs_suppliersInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutMeqs_suppliersInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutMeqs_suppliersInput, MEQSUncheckedUpdateWithoutMeqs_suppliersInput>
  }

  export type MEQSUpdateWithoutMeqs_suppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_approvers?: MEQSApproverUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutMeqs_suppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_approvers?: MEQSApproverUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type SupplierUpsertWithoutMEQSSupplierInput = {
    update: XOR<SupplierUpdateWithoutMEQSSupplierInput, SupplierUncheckedUpdateWithoutMEQSSupplierInput>
    create: XOR<SupplierCreateWithoutMEQSSupplierInput, SupplierUncheckedCreateWithoutMEQSSupplierInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutMEQSSupplierInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutMEQSSupplierInput, SupplierUncheckedUpdateWithoutMEQSSupplierInput>
  }

  export type SupplierUpdateWithoutMEQSSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupplierUncheckedUpdateWithoutMEQSSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierAttachmentUpsertWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentWhereUniqueInput
    update: XOR<MEQSSupplierAttachmentUpdateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedUpdateWithoutMeqs_supplierInput>
    create: XOR<MEQSSupplierAttachmentCreateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentUpdateWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentWhereUniqueInput
    data: XOR<MEQSSupplierAttachmentUpdateWithoutMeqs_supplierInput, MEQSSupplierAttachmentUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentUpdateManyWithWhereWithoutMeqs_supplierInput = {
    where: MEQSSupplierAttachmentScalarWhereInput
    data: XOR<MEQSSupplierAttachmentUpdateManyMutationInput, MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierAttachmentScalarWhereInput = {
    AND?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
    OR?: MEQSSupplierAttachmentScalarWhereInput[]
    NOT?: MEQSSupplierAttachmentScalarWhereInput | MEQSSupplierAttachmentScalarWhereInput[]
    id?: StringFilter<"MEQSSupplierAttachment"> | string
    meqs_supplier_id?: StringFilter<"MEQSSupplierAttachment"> | string
    src?: StringFilter<"MEQSSupplierAttachment"> | string
    created_at?: DateTimeFilter<"MEQSSupplierAttachment"> | Date | string
    updated_at?: DateTimeFilter<"MEQSSupplierAttachment"> | Date | string
    is_deleted?: BoolFilter<"MEQSSupplierAttachment"> | boolean
  }

  export type MEQSSupplierItemUpsertWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemWhereUniqueInput
    update: XOR<MEQSSupplierItemUpdateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedUpdateWithoutMeqs_supplierInput>
    create: XOR<MEQSSupplierItemCreateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedCreateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierItemUpdateWithWhereUniqueWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemWhereUniqueInput
    data: XOR<MEQSSupplierItemUpdateWithoutMeqs_supplierInput, MEQSSupplierItemUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type MEQSSupplierItemUpdateManyWithWhereWithoutMeqs_supplierInput = {
    where: MEQSSupplierItemScalarWhereInput
    data: XOR<MEQSSupplierItemUpdateManyMutationInput, MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierInput>
  }

  export type POUpsertWithoutMeqs_supplierInput = {
    update: XOR<POUpdateWithoutMeqs_supplierInput, POUncheckedUpdateWithoutMeqs_supplierInput>
    create: XOR<POCreateWithoutMeqs_supplierInput, POUncheckedCreateWithoutMeqs_supplierInput>
    where?: POWhereInput
  }

  export type POUpdateToOneWithWhereWithoutMeqs_supplierInput = {
    where?: POWhereInput
    data: XOR<POUpdateWithoutMeqs_supplierInput, POUncheckedUpdateWithoutMeqs_supplierInput>
  }

  export type POUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    po_approvers?: POApproverUpdateManyWithoutPoNestedInput
    rr?: RRUpdateOneWithoutPoNestedInput
  }

  export type POUncheckedUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    po_approvers?: POApproverUncheckedUpdateManyWithoutPoNestedInput
    rr?: RRUncheckedUpdateOneWithoutPoNestedInput
  }

  export type CanvassItemCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    description: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass: CanvassCreateNestedOneWithoutCanvass_itemsInput
    brand?: BrandCreateNestedOneWithoutCanvass_itemsInput
    unit: UnitCreateNestedOneWithoutCanvass_itemsInput
  }

  export type CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    canvass_id: string
    description: string
    brand_id?: string | null
    unit_id: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type CanvassItemCreateOrConnectWithoutMeqs_supplier_itemsInput = {
    where: CanvassItemWhereUniqueInput
    create: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
  }

  export type MEQSSupplierCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutMeqs_supplier_itemsInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
  }

  export type CanvassItemUpsertWithoutMeqs_supplier_itemsInput = {
    update: XOR<CanvassItemUpdateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput>
    create: XOR<CanvassItemCreateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedCreateWithoutMeqs_supplier_itemsInput>
    where?: CanvassItemWhereInput
  }

  export type CanvassItemUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput = {
    where?: CanvassItemWhereInput
    data: XOR<CanvassItemUpdateWithoutMeqs_supplier_itemsInput, CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type CanvassItemUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    brand?: BrandUpdateOneWithoutCanvass_itemsNestedInput
    unit?: UnitUpdateOneRequiredWithoutCanvass_itemsNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierUpsertWithoutMeqs_supplier_itemsInput = {
    update: XOR<MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput>
    create: XOR<MEQSSupplierCreateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedCreateWithoutMeqs_supplier_itemsInput>
    where?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierUpdateToOneWithWhereWithoutMeqs_supplier_itemsInput = {
    where?: MEQSSupplierWhereInput
    data: XOR<MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput, MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput>
  }

  export type MEQSSupplierUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutMeqs_supplier_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierCreateWithoutAttachmentsInput = {
    id?: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
    po?: POCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
    po?: POUncheckedCreateNestedOneWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutAttachmentsInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
  }

  export type MEQSSupplierUpsertWithoutAttachmentsInput = {
    update: XOR<MEQSSupplierUpdateWithoutAttachmentsInput, MEQSSupplierUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MEQSSupplierCreateWithoutAttachmentsInput, MEQSSupplierUncheckedCreateWithoutAttachmentsInput>
    where?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MEQSSupplierWhereInput
    data: XOR<MEQSSupplierUpdateWithoutAttachmentsInput, MEQSSupplierUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MEQSSupplierUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSCreateWithoutMeqs_approversInput = {
    id?: string
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    jo?: JOCreateNestedOneWithoutMeqsInput
    rv?: RVCreateNestedOneWithoutMeqsInput
    spr?: SPRCreateNestedOneWithoutMeqsInput
    meqs_suppliers?: MEQSSupplierCreateNestedManyWithoutMeqsInput
  }

  export type MEQSUncheckedCreateWithoutMeqs_approversInput = {
    id?: string
    jo_id?: string | null
    rv_id?: string | null
    spr_id?: string | null
    meqs_number: string
    request_type?: number
    meqs_date: Date | string
    status?: number
    notes?: string | null
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs_suppliers?: MEQSSupplierUncheckedCreateNestedManyWithoutMeqsInput
  }

  export type MEQSCreateOrConnectWithoutMeqs_approversInput = {
    where: MEQSWhereUniqueInput
    create: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
  }

  export type MEQSUpsertWithoutMeqs_approversInput = {
    update: XOR<MEQSUpdateWithoutMeqs_approversInput, MEQSUncheckedUpdateWithoutMeqs_approversInput>
    create: XOR<MEQSCreateWithoutMeqs_approversInput, MEQSUncheckedCreateWithoutMeqs_approversInput>
    where?: MEQSWhereInput
  }

  export type MEQSUpdateToOneWithWhereWithoutMeqs_approversInput = {
    where?: MEQSWhereInput
    data: XOR<MEQSUpdateWithoutMeqs_approversInput, MEQSUncheckedUpdateWithoutMeqs_approversInput>
  }

  export type MEQSUpdateWithoutMeqs_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    jo?: JOUpdateOneWithoutMeqsNestedInput
    rv?: RVUpdateOneWithoutMeqsNestedInput
    spr?: SPRUpdateOneWithoutMeqsNestedInput
    meqs_suppliers?: MEQSSupplierUpdateManyWithoutMeqsNestedInput
  }

  export type MEQSUncheckedUpdateWithoutMeqs_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    jo_id?: NullableStringFieldUpdateOperationsInput | string | null
    rv_id?: NullableStringFieldUpdateOperationsInput | string | null
    spr_id?: NullableStringFieldUpdateOperationsInput | string | null
    meqs_number?: StringFieldUpdateOperationsInput | string
    request_type?: IntFieldUpdateOperationsInput | number
    meqs_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_suppliers?: MEQSSupplierUncheckedUpdateManyWithoutMeqsNestedInput
  }

  export type POApproverCreateWithoutPoInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type POApproverUncheckedCreateWithoutPoInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type POApproverCreateOrConnectWithoutPoInput = {
    where: POApproverWhereUniqueInput
    create: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput>
  }

  export type POApproverCreateManyPoInputEnvelope = {
    data: POApproverCreateManyPoInput | POApproverCreateManyPoInput[]
    skipDuplicates?: boolean
  }

  export type MEQSSupplierCreateWithoutPoInput = {
    id?: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    meqs: MEQSCreateNestedOneWithoutMeqs_suppliersInput
    supplier: SupplierCreateNestedOneWithoutMEQSSupplierInput
    attachments?: MEQSSupplierAttachmentCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemCreateNestedManyWithoutMeqs_supplierInput
  }

  export type MEQSSupplierUncheckedCreateWithoutPoInput = {
    id?: string
    meqs_id: string
    supplier_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    attachments?: MEQSSupplierAttachmentUncheckedCreateNestedManyWithoutMeqs_supplierInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedCreateNestedManyWithoutMeqs_supplierInput
  }

  export type MEQSSupplierCreateOrConnectWithoutPoInput = {
    where: MEQSSupplierWhereUniqueInput
    create: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
  }

  export type RRCreateWithoutPoInput = {
    id?: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_approvers?: RRApproverCreateNestedManyWithoutRrInput
    rr_items?: RRItemCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateWithoutPoInput = {
    id?: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_approvers?: RRApproverUncheckedCreateNestedManyWithoutRrInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRCreateOrConnectWithoutPoInput = {
    where: RRWhereUniqueInput
    create: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
  }

  export type POApproverUpsertWithWhereUniqueWithoutPoInput = {
    where: POApproverWhereUniqueInput
    update: XOR<POApproverUpdateWithoutPoInput, POApproverUncheckedUpdateWithoutPoInput>
    create: XOR<POApproverCreateWithoutPoInput, POApproverUncheckedCreateWithoutPoInput>
  }

  export type POApproverUpdateWithWhereUniqueWithoutPoInput = {
    where: POApproverWhereUniqueInput
    data: XOR<POApproverUpdateWithoutPoInput, POApproverUncheckedUpdateWithoutPoInput>
  }

  export type POApproverUpdateManyWithWhereWithoutPoInput = {
    where: POApproverScalarWhereInput
    data: XOR<POApproverUpdateManyMutationInput, POApproverUncheckedUpdateManyWithoutPoInput>
  }

  export type POApproverScalarWhereInput = {
    AND?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
    OR?: POApproverScalarWhereInput[]
    NOT?: POApproverScalarWhereInput | POApproverScalarWhereInput[]
    id?: StringFilter<"POApprover"> | string
    po_id?: StringFilter<"POApprover"> | string
    approver_id?: StringFilter<"POApprover"> | string
    approver_proxy_id?: StringNullableFilter<"POApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"POApprover"> | Date | string | null
    notes?: StringNullableFilter<"POApprover"> | string | null
    status?: IntFilter<"POApprover"> | number
    label?: StringFilter<"POApprover"> | string
    order?: IntFilter<"POApprover"> | number
    created_at?: DateTimeFilter<"POApprover"> | Date | string
    updated_at?: DateTimeFilter<"POApprover"> | Date | string
    is_deleted?: BoolFilter<"POApprover"> | boolean
  }

  export type MEQSSupplierUpsertWithoutPoInput = {
    update: XOR<MEQSSupplierUpdateWithoutPoInput, MEQSSupplierUncheckedUpdateWithoutPoInput>
    create: XOR<MEQSSupplierCreateWithoutPoInput, MEQSSupplierUncheckedCreateWithoutPoInput>
    where?: MEQSSupplierWhereInput
  }

  export type MEQSSupplierUpdateToOneWithWhereWithoutPoInput = {
    where?: MEQSSupplierWhereInput
    data: XOR<MEQSSupplierUpdateWithoutPoInput, MEQSSupplierUncheckedUpdateWithoutPoInput>
  }

  export type MEQSSupplierUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
  }

  export type RRUpsertWithoutPoInput = {
    update: XOR<RRUpdateWithoutPoInput, RRUncheckedUpdateWithoutPoInput>
    create: XOR<RRCreateWithoutPoInput, RRUncheckedCreateWithoutPoInput>
    where?: RRWhereInput
  }

  export type RRUpdateToOneWithWhereWithoutPoInput = {
    where?: RRWhereInput
    data: XOR<RRUpdateWithoutPoInput, RRUncheckedUpdateWithoutPoInput>
  }

  export type RRUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_approvers?: RRApproverUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_approvers?: RRApproverUncheckedUpdateManyWithoutRrNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutRrNestedInput
  }

  export type POCreateWithoutPo_approversInput = {
    id?: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutPoInput
    rr?: RRCreateNestedOneWithoutPoInput
  }

  export type POUncheckedCreateWithoutPo_approversInput = {
    id?: string
    meqs_supplier_id: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    rr?: RRUncheckedCreateNestedOneWithoutPoInput
  }

  export type POCreateOrConnectWithoutPo_approversInput = {
    where: POWhereUniqueInput
    create: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
  }

  export type POUpsertWithoutPo_approversInput = {
    update: XOR<POUpdateWithoutPo_approversInput, POUncheckedUpdateWithoutPo_approversInput>
    create: XOR<POCreateWithoutPo_approversInput, POUncheckedCreateWithoutPo_approversInput>
    where?: POWhereInput
  }

  export type POUpdateToOneWithWhereWithoutPo_approversInput = {
    where?: POWhereInput
    data: XOR<POUpdateWithoutPo_approversInput, POUncheckedUpdateWithoutPo_approversInput>
  }

  export type POUpdateWithoutPo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutPoNestedInput
    rr?: RRUpdateOneWithoutPoNestedInput
  }

  export type POUncheckedUpdateWithoutPo_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    rr?: RRUncheckedUpdateOneWithoutPoNestedInput
  }

  export type POCreateWithoutRrInput = {
    id?: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    po_approvers?: POApproverCreateNestedManyWithoutPoInput
    meqs_supplier: MEQSSupplierCreateNestedOneWithoutPoInput
  }

  export type POUncheckedCreateWithoutRrInput = {
    id?: string
    meqs_supplier_id: string
    po_number: string
    po_date: Date | string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    is_referenced?: boolean
    po_approvers?: POApproverUncheckedCreateNestedManyWithoutPoInput
  }

  export type POCreateOrConnectWithoutRrInput = {
    where: POWhereUniqueInput
    create: XOR<POCreateWithoutRrInput, POUncheckedCreateWithoutRrInput>
  }

  export type RRApproverCreateWithoutRrInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRApproverUncheckedCreateWithoutRrInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRApproverCreateOrConnectWithoutRrInput = {
    where: RRApproverWhereUniqueInput
    create: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput>
  }

  export type RRApproverCreateManyRrInputEnvelope = {
    data: RRApproverCreateManyRrInput | RRApproverCreateManyRrInput[]
    skipDuplicates?: boolean
  }

  export type RRItemCreateWithoutRrInput = {
    id?: string
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item?: ItemCreateNestedOneWithoutRr_itemsInput
    item_brand?: BrandCreateNestedOneWithoutRr_itemsInput
    unit?: UnitCreateNestedOneWithoutRr_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUncheckedCreateWithoutRrInput = {
    id?: string
    item_id?: string | null
    item_brand_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemCreateOrConnectWithoutRrInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput>
  }

  export type RRItemCreateManyRrInputEnvelope = {
    data: RRItemCreateManyRrInput | RRItemCreateManyRrInput[]
    skipDuplicates?: boolean
  }

  export type POUpsertWithoutRrInput = {
    update: XOR<POUpdateWithoutRrInput, POUncheckedUpdateWithoutRrInput>
    create: XOR<POCreateWithoutRrInput, POUncheckedCreateWithoutRrInput>
    where?: POWhereInput
  }

  export type POUpdateToOneWithWhereWithoutRrInput = {
    where?: POWhereInput
    data: XOR<POUpdateWithoutRrInput, POUncheckedUpdateWithoutRrInput>
  }

  export type POUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    po_approvers?: POApproverUpdateManyWithoutPoNestedInput
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutPoNestedInput
  }

  export type POUncheckedUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    po_approvers?: POApproverUncheckedUpdateManyWithoutPoNestedInput
  }

  export type RRApproverUpsertWithWhereUniqueWithoutRrInput = {
    where: RRApproverWhereUniqueInput
    update: XOR<RRApproverUpdateWithoutRrInput, RRApproverUncheckedUpdateWithoutRrInput>
    create: XOR<RRApproverCreateWithoutRrInput, RRApproverUncheckedCreateWithoutRrInput>
  }

  export type RRApproverUpdateWithWhereUniqueWithoutRrInput = {
    where: RRApproverWhereUniqueInput
    data: XOR<RRApproverUpdateWithoutRrInput, RRApproverUncheckedUpdateWithoutRrInput>
  }

  export type RRApproverUpdateManyWithWhereWithoutRrInput = {
    where: RRApproverScalarWhereInput
    data: XOR<RRApproverUpdateManyMutationInput, RRApproverUncheckedUpdateManyWithoutRrInput>
  }

  export type RRApproverScalarWhereInput = {
    AND?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
    OR?: RRApproverScalarWhereInput[]
    NOT?: RRApproverScalarWhereInput | RRApproverScalarWhereInput[]
    id?: StringFilter<"RRApprover"> | string
    rr_id?: StringFilter<"RRApprover"> | string
    approver_id?: StringFilter<"RRApprover"> | string
    approver_proxy_id?: StringNullableFilter<"RRApprover"> | string | null
    date_approval?: DateTimeNullableFilter<"RRApprover"> | Date | string | null
    notes?: StringNullableFilter<"RRApprover"> | string | null
    status?: IntFilter<"RRApprover"> | number
    label?: StringFilter<"RRApprover"> | string
    order?: IntFilter<"RRApprover"> | number
    created_at?: DateTimeFilter<"RRApprover"> | Date | string
    updated_at?: DateTimeFilter<"RRApprover"> | Date | string
    is_deleted?: BoolFilter<"RRApprover"> | boolean
  }

  export type RRItemUpsertWithWhereUniqueWithoutRrInput = {
    where: RRItemWhereUniqueInput
    update: XOR<RRItemUpdateWithoutRrInput, RRItemUncheckedUpdateWithoutRrInput>
    create: XOR<RRItemCreateWithoutRrInput, RRItemUncheckedCreateWithoutRrInput>
  }

  export type RRItemUpdateWithWhereUniqueWithoutRrInput = {
    where: RRItemWhereUniqueInput
    data: XOR<RRItemUpdateWithoutRrInput, RRItemUncheckedUpdateWithoutRrInput>
  }

  export type RRItemUpdateManyWithWhereWithoutRrInput = {
    where: RRItemScalarWhereInput
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyWithoutRrInput>
  }

  export type RRCreateWithoutRr_approversInput = {
    id?: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    po: POCreateNestedOneWithoutRrInput
    rr_items?: RRItemCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateWithoutRr_approversInput = {
    id?: string
    po_id: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_items?: RRItemUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRCreateOrConnectWithoutRr_approversInput = {
    where: RRWhereUniqueInput
    create: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
  }

  export type RRUpsertWithoutRr_approversInput = {
    update: XOR<RRUpdateWithoutRr_approversInput, RRUncheckedUpdateWithoutRr_approversInput>
    create: XOR<RRCreateWithoutRr_approversInput, RRUncheckedCreateWithoutRr_approversInput>
    where?: RRWhereInput
  }

  export type RRUpdateToOneWithWhereWithoutRr_approversInput = {
    where?: RRWhereInput
    data: XOR<RRUpdateWithoutRr_approversInput, RRUncheckedUpdateWithoutRr_approversInput>
  }

  export type RRUpdateWithoutRr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    po?: POUpdateOneRequiredWithoutRrNestedInput
    rr_items?: RRItemUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateWithoutRr_approversInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_items?: RRItemUncheckedUpdateManyWithoutRrNestedInput
  }

  export type RRCreateWithoutRr_itemsInput = {
    id?: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    po: POCreateNestedOneWithoutRrInput
    rr_approvers?: RRApproverCreateNestedManyWithoutRrInput
  }

  export type RRUncheckedCreateWithoutRr_itemsInput = {
    id?: string
    po_id: string
    rr_number: string
    rr_date: Date | string
    received_by_id: string
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    invoice_number: string
    delivery_number?: string | null
    notes?: string | null
    delivery_charge: number
    status?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_approvers?: RRApproverUncheckedCreateNestedManyWithoutRrInput
  }

  export type RRCreateOrConnectWithoutRr_itemsInput = {
    where: RRWhereUniqueInput
    create: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
  }

  export type ItemCreateWithoutRr_itemsInput = {
    id?: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutRr_itemsInput = {
    id?: string
    item_type_id: string
    unit_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutRr_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutRr_itemsInput, ItemUncheckedCreateWithoutRr_itemsInput>
  }

  export type BrandCreateWithoutRr_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutRr_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutRr_itemsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutRr_itemsInput, BrandUncheckedCreateWithoutRr_itemsInput>
  }

  export type UnitCreateWithoutRr_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutUnitInput
    items?: ItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutRr_itemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutUnitInput
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutRr_itemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutRr_itemsInput, UnitUncheckedCreateWithoutRr_itemsInput>
  }

  export type ItemTransactionCreateWithoutRr_itemInput = {
    id?: string
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item: ItemCreateNestedOneWithoutItem_transactionsInput
  }

  export type ItemTransactionUncheckedCreateWithoutRr_itemInput = {
    id?: string
    item_id: string
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTransactionCreateOrConnectWithoutRr_itemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
  }

  export type RRUpsertWithoutRr_itemsInput = {
    update: XOR<RRUpdateWithoutRr_itemsInput, RRUncheckedUpdateWithoutRr_itemsInput>
    create: XOR<RRCreateWithoutRr_itemsInput, RRUncheckedCreateWithoutRr_itemsInput>
    where?: RRWhereInput
  }

  export type RRUpdateToOneWithWhereWithoutRr_itemsInput = {
    where?: RRWhereInput
    data: XOR<RRUpdateWithoutRr_itemsInput, RRUncheckedUpdateWithoutRr_itemsInput>
  }

  export type RRUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    po?: POUpdateOneRequiredWithoutRrNestedInput
    rr_approvers?: RRApproverUpdateManyWithoutRrNestedInput
  }

  export type RRUncheckedUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_id?: StringFieldUpdateOperationsInput | string
    rr_number?: StringFieldUpdateOperationsInput | string
    rr_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by_id?: StringFieldUpdateOperationsInput | string
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    delivery_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_charge?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_approvers?: RRApproverUncheckedUpdateManyWithoutRrNestedInput
  }

  export type ItemUpsertWithoutRr_itemsInput = {
    update: XOR<ItemUpdateWithoutRr_itemsInput, ItemUncheckedUpdateWithoutRr_itemsInput>
    create: XOR<ItemCreateWithoutRr_itemsInput, ItemUncheckedCreateWithoutRr_itemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutRr_itemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutRr_itemsInput, ItemUncheckedUpdateWithoutRr_itemsInput>
  }

  export type ItemUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
  }

  export type BrandUpsertWithoutRr_itemsInput = {
    update: XOR<BrandUpdateWithoutRr_itemsInput, BrandUncheckedUpdateWithoutRr_itemsInput>
    create: XOR<BrandCreateWithoutRr_itemsInput, BrandUncheckedCreateWithoutRr_itemsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutRr_itemsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutRr_itemsInput, BrandUncheckedUpdateWithoutRr_itemsInput>
  }

  export type BrandUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type UnitUpsertWithoutRr_itemsInput = {
    update: XOR<UnitUpdateWithoutRr_itemsInput, UnitUncheckedUpdateWithoutRr_itemsInput>
    create: XOR<UnitCreateWithoutRr_itemsInput, UnitUncheckedCreateWithoutRr_itemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutRr_itemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutRr_itemsInput, UnitUncheckedUpdateWithoutRr_itemsInput>
  }

  export type UnitUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutUnitNestedInput
    items?: ItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutRr_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutUnitNestedInput
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ItemTransactionUpsertWithoutRr_itemInput = {
    update: XOR<ItemTransactionUpdateWithoutRr_itemInput, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
    create: XOR<ItemTransactionCreateWithoutRr_itemInput, ItemTransactionUncheckedCreateWithoutRr_itemInput>
    where?: ItemTransactionWhereInput
  }

  export type ItemTransactionUpdateToOneWithWhereWithoutRr_itemInput = {
    where?: ItemTransactionWhereInput
    data: XOR<ItemTransactionUpdateWithoutRr_itemInput, ItemTransactionUncheckedUpdateWithoutRr_itemInput>
  }

  export type ItemTransactionUpdateWithoutRr_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item?: ItemUpdateOneRequiredWithoutItem_transactionsNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutRr_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTypeCreateWithoutItemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTypeUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTypeCreateOrConnectWithoutItemsInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
  }

  export type ItemTransactionCreateWithoutItemInput = {
    id?: string
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_item?: RRItemCreateNestedOneWithoutItem_transactionInput
  }

  export type ItemTransactionUncheckedCreateWithoutItemInput = {
    id?: string
    rr_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTransactionCreateOrConnectWithoutItemInput = {
    where: ItemTransactionWhereUniqueInput
    create: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput>
  }

  export type ItemTransactionCreateManyItemInputEnvelope = {
    data: ItemTransactionCreateManyItemInput | ItemTransactionCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type RRItemCreateWithoutItemInput = {
    id?: string
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr: RRCreateNestedOneWithoutRr_itemsInput
    item_brand?: BrandCreateNestedOneWithoutRr_itemsInput
    unit?: UnitCreateNestedOneWithoutRr_itemsInput
    item_transaction?: ItemTransactionCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemUncheckedCreateWithoutItemInput = {
    id?: string
    rr_id: string
    item_brand_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transaction?: ItemTransactionUncheckedCreateNestedOneWithoutRr_itemInput
  }

  export type RRItemCreateOrConnectWithoutItemInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutItemInput, RRItemUncheckedCreateWithoutItemInput>
  }

  export type RRItemCreateManyItemInputEnvelope = {
    data: RRItemCreateManyItemInput | RRItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutItemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemCreateNestedManyWithoutUnitInput
    rr_items?: RRItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    canvass_items?: CanvassItemUncheckedCreateNestedManyWithoutUnitInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
  }

  export type ItemTypeUpsertWithoutItemsInput = {
    update: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemTypeUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTypeUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTransactionUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemTransactionWhereUniqueInput
    update: XOR<ItemTransactionUpdateWithoutItemInput, ItemTransactionUncheckedUpdateWithoutItemInput>
    create: XOR<ItemTransactionCreateWithoutItemInput, ItemTransactionUncheckedCreateWithoutItemInput>
  }

  export type ItemTransactionUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemTransactionWhereUniqueInput
    data: XOR<ItemTransactionUpdateWithoutItemInput, ItemTransactionUncheckedUpdateWithoutItemInput>
  }

  export type ItemTransactionUpdateManyWithWhereWithoutItemInput = {
    where: ItemTransactionScalarWhereInput
    data: XOR<ItemTransactionUpdateManyMutationInput, ItemTransactionUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemTransactionScalarWhereInput = {
    AND?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
    OR?: ItemTransactionScalarWhereInput[]
    NOT?: ItemTransactionScalarWhereInput | ItemTransactionScalarWhereInput[]
    id?: StringFilter<"ItemTransaction"> | string
    item_id?: StringFilter<"ItemTransaction"> | string
    rr_item_id?: StringNullableFilter<"ItemTransaction"> | string | null
    type?: IntFilter<"ItemTransaction"> | number
    quantity?: FloatFilter<"ItemTransaction"> | number
    price?: FloatFilter<"ItemTransaction"> | number
    remarks?: StringNullableFilter<"ItemTransaction"> | string | null
    is_initial?: BoolFilter<"ItemTransaction"> | boolean
    created_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    updated_at?: DateTimeFilter<"ItemTransaction"> | Date | string
    is_deleted?: BoolFilter<"ItemTransaction"> | boolean
  }

  export type RRItemUpsertWithWhereUniqueWithoutItemInput = {
    where: RRItemWhereUniqueInput
    update: XOR<RRItemUpdateWithoutItemInput, RRItemUncheckedUpdateWithoutItemInput>
    create: XOR<RRItemCreateWithoutItemInput, RRItemUncheckedCreateWithoutItemInput>
  }

  export type RRItemUpdateWithWhereUniqueWithoutItemInput = {
    where: RRItemWhereUniqueInput
    data: XOR<RRItemUpdateWithoutItemInput, RRItemUncheckedUpdateWithoutItemInput>
  }

  export type RRItemUpdateManyWithWhereWithoutItemInput = {
    where: RRItemScalarWhereInput
    data: XOR<RRItemUpdateManyMutationInput, RRItemUncheckedUpdateManyWithoutItemInput>
  }

  export type UnitUpsertWithoutItemsInput = {
    update: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type UnitUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUpdateManyWithoutUnitNestedInput
    rr_items?: RRItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_items?: CanvassItemUncheckedUpdateManyWithoutUnitNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ItemCreateWithoutItem_typeInput = {
    id?: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transactions?: ItemTransactionCreateNestedManyWithoutItemInput
    rr_items?: RRItemCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutItem_typeInput = {
    id?: string
    unit_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_transactions?: ItemTransactionUncheckedCreateNestedManyWithoutItemInput
    rr_items?: RRItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput>
  }

  export type ItemCreateManyItem_typeInputEnvelope = {
    data: ItemCreateManyItem_typeInput | ItemCreateManyItem_typeInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutItem_typeInput, ItemUncheckedUpdateWithoutItem_typeInput>
    create: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutItem_typeInput, ItemUncheckedUpdateWithoutItem_typeInput>
  }

  export type ItemUpdateManyWithWhereWithoutItem_typeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItem_typeInput>
  }

  export type ItemCreateWithoutItem_transactionsInput = {
    id?: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    rr_items?: RRItemCreateNestedManyWithoutItemInput
    unit: UnitCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutItem_transactionsInput = {
    id?: string
    item_type_id: string
    unit_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr_items?: RRItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItem_transactionsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
  }

  export type RRItemCreateWithoutItem_transactionInput = {
    id?: string
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
    rr: RRCreateNestedOneWithoutRr_itemsInput
    item?: ItemCreateNestedOneWithoutRr_itemsInput
    item_brand?: BrandCreateNestedOneWithoutRr_itemsInput
    unit?: UnitCreateNestedOneWithoutRr_itemsInput
  }

  export type RRItemUncheckedCreateWithoutItem_transactionInput = {
    id?: string
    rr_id: string
    item_id?: string | null
    item_brand_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRItemCreateOrConnectWithoutItem_transactionInput = {
    where: RRItemWhereUniqueInput
    create: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
  }

  export type ItemUpsertWithoutItem_transactionsInput = {
    update: XOR<ItemUpdateWithoutItem_transactionsInput, ItemUncheckedUpdateWithoutItem_transactionsInput>
    create: XOR<ItemCreateWithoutItem_transactionsInput, ItemUncheckedCreateWithoutItem_transactionsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutItem_transactionsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutItem_transactionsInput, ItemUncheckedUpdateWithoutItem_transactionsInput>
  }

  export type ItemUpdateWithoutItem_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    rr_items?: RRItemUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutItem_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_items?: RRItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type RRItemUpsertWithoutItem_transactionInput = {
    update: XOR<RRItemUpdateWithoutItem_transactionInput, RRItemUncheckedUpdateWithoutItem_transactionInput>
    create: XOR<RRItemCreateWithoutItem_transactionInput, RRItemUncheckedCreateWithoutItem_transactionInput>
    where?: RRItemWhereInput
  }

  export type RRItemUpdateToOneWithWhereWithoutItem_transactionInput = {
    where?: RRItemWhereInput
    data: XOR<RRItemUpdateWithoutItem_transactionInput, RRItemUncheckedUpdateWithoutItem_transactionInput>
  }

  export type RRItemUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    item?: ItemUpdateOneWithoutRr_itemsNestedInput
    item_brand?: BrandUpdateOneWithoutRr_itemsNestedInput
    unit?: UnitUpdateOneWithoutRr_itemsNestedInput
  }

  export type RRItemUncheckedUpdateWithoutItem_transactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierCreateManySupplierInput = {
    id?: string
    meqs_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneRequiredWithoutMeqs_suppliersNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CanvassItemCreateManyUnitInput = {
    id?: string
    canvass_id: string
    description: string
    brand_id?: string | null
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRItemCreateManyUnitInput = {
    id?: string
    rr_id: string
    item_id?: string | null
    item_brand_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemCreateManyUnitInput = {
    id?: string
    item_type_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type CanvassItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    brand?: BrandUpdateOneWithoutCanvass_itemsNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    item?: ItemUpdateOneWithoutRr_itemsNestedInput
    item_brand?: BrandUpdateOneWithoutRr_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    rr_items?: RRItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_type_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CanvassItemCreateManyBrandInput = {
    id?: string
    canvass_id: string
    description: string
    unit_id: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRItemCreateManyItem_brandInput = {
    id?: string
    rr_id: string
    item_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type CanvassItemUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass?: CanvassUpdateOneRequiredWithoutCanvass_itemsNestedInput
    unit?: UnitUpdateOneRequiredWithoutCanvass_itemsNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRItemUpdateWithoutItem_brandInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    item?: ItemUpdateOneWithoutRr_itemsNestedInput
    unit?: UnitUpdateOneWithoutRr_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateWithoutItem_brandInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateManyWithoutItem_brandInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRCreateManyVehicleInput = {
    id?: string
    spr_number: string
    date_requested: Date | string
    canvass_id: string
    classification_id?: string | null
    supervisor_id: string
    status?: number
    canceller_id?: string | null
    date_cancelled?: Date | string | null
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SPRUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUpdateOneWithoutSprNestedInput
    canvass?: CanvassUpdateOneRequiredWithoutSprNestedInput
    spr_approvers?: SPRApproverUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs?: MEQSUncheckedUpdateOneWithoutSprNestedInput
    spr_approvers?: SPRApproverUncheckedUpdateManyWithoutSprNestedInput
  }

  export type SPRUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    spr_number?: StringFieldUpdateOperationsInput | string
    date_requested?: DateTimeFieldUpdateOperationsInput | Date | string
    canvass_id?: StringFieldUpdateOperationsInput | string
    classification_id?: NullableStringFieldUpdateOperationsInput | string | null
    supervisor_id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    canceller_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancelled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierItemCreateManyCanvass_itemInput = {
    id?: string
    meqs_supplier_id: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierItemUpdateWithoutCanvass_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier?: MEQSSupplierUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateWithoutCanvass_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemInput = {
    id?: StringFieldUpdateOperationsInput | string
    meqs_supplier_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CanvassItemCreateManyCanvassInput = {
    id?: string
    description: string
    brand_id?: string | null
    unit_id: string
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type CanvassItemUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    brand?: BrandUpdateOneWithoutCanvass_itemsNestedInput
    unit?: UnitUpdateOneRequiredWithoutCanvass_itemsNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutCanvass_itemNestedInput
  }

  export type CanvassItemUncheckedUpdateManyWithoutCanvassInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOApproverCreateManyJoInput = {
    id?: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type JOApproverUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOApproverUncheckedUpdateWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JOApproverUncheckedUpdateManyWithoutJoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVApproverCreateManyRvInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RVApproverUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVApproverUncheckedUpdateWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RVApproverUncheckedUpdateManyWithoutRvInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRApproverCreateManySprInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type SPRApproverUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRApproverUncheckedUpdateWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SPRApproverUncheckedUpdateManyWithoutSprInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSApproverCreateManyMeqsInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierCreateManyMeqsInput = {
    id?: string
    supplier_id: string
    payment_terms: string
    is_referenced?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSApproverUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSApproverUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSApproverUncheckedUpdateManyWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    supplier?: SupplierUpdateOneRequiredWithoutMEQSSupplierNestedInput
    attachments?: MEQSSupplierAttachmentUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    attachments?: MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    meqs_supplier_items?: MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierNestedInput
    po?: POUncheckedUpdateOneWithoutMeqs_supplierNestedInput
  }

  export type MEQSSupplierUncheckedUpdateManyWithoutMeqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    is_referenced?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierAttachmentCreateManyMeqs_supplierInput = {
    id?: string
    src: string
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierItemCreateManyMeqs_supplierInput = {
    id?: string
    canvass_item_id: string
    price: number
    is_awarded?: boolean
    notes?: string | null
    vat_type?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type MEQSSupplierAttachmentUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierAttachmentUncheckedUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierAttachmentUncheckedUpdateManyWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    src?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierItemUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    canvass_item?: CanvassItemUpdateOneRequiredWithoutMeqs_supplier_itemsNestedInput
  }

  export type MEQSSupplierItemUncheckedUpdateWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MEQSSupplierItemUncheckedUpdateManyWithoutMeqs_supplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    canvass_item_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    is_awarded?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vat_type?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POApproverCreateManyPoInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type POApproverUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POApproverUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type POApproverUncheckedUpdateManyWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRApproverCreateManyRrInput = {
    id?: string
    approver_id: string
    approver_proxy_id?: string | null
    date_approval?: Date | string | null
    notes?: string | null
    status: number
    label: string
    order: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRItemCreateManyRrInput = {
    id?: string
    item_id?: string | null
    item_brand_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRApproverUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRApproverUncheckedUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRApproverUncheckedUpdateManyWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    approver_id?: StringFieldUpdateOperationsInput | string
    approver_proxy_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_approval?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRItemUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item?: ItemUpdateOneWithoutRr_itemsNestedInput
    item_brand?: BrandUpdateOneWithoutRr_itemsNestedInput
    unit?: UnitUpdateOneWithoutRr_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateManyWithoutRrInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTransactionCreateManyItemInput = {
    id?: string
    rr_item_id?: string | null
    type: number
    quantity: number
    price: number
    remarks?: string | null
    is_initial?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type RRItemCreateManyItemInput = {
    id?: string
    rr_id: string
    item_brand_id?: string | null
    unit_id?: string | null
    item_class: number
    quantity_delivered: number
    quantity_accepted: number
    description: string
    vat_type: number
    gross_price: number
    net_price: number
    vat_amount?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemTransactionUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr_item?: RRItemUpdateOneWithoutItem_transactionNestedInput
  }

  export type ItemTransactionUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemTransactionUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    is_initial?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RRItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    rr?: RRUpdateOneRequiredWithoutRr_itemsNestedInput
    item_brand?: BrandUpdateOneWithoutRr_itemsNestedInput
    unit?: UnitUpdateOneWithoutRr_itemsNestedInput
    item_transaction?: ItemTransactionUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transaction?: ItemTransactionUncheckedUpdateOneWithoutRr_itemNestedInput
  }

  export type RRItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rr_id?: StringFieldUpdateOperationsInput | string
    item_brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    unit_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_class?: IntFieldUpdateOperationsInput | number
    quantity_delivered?: IntFieldUpdateOperationsInput | number
    quantity_accepted?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vat_type?: IntFieldUpdateOperationsInput | number
    gross_price?: FloatFieldUpdateOperationsInput | number
    net_price?: FloatFieldUpdateOperationsInput | number
    vat_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCreateManyItem_typeInput = {
    id?: string
    unit_id: string
    code: string
    description: string
    quantity: number
    initial_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted?: boolean
  }

  export type ItemUpdateWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transactions?: ItemTransactionUpdateManyWithoutItemNestedInput
    rr_items?: RRItemUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    item_transactions?: ItemTransactionUncheckedUpdateManyWithoutItemNestedInput
    rr_items?: RRItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    initial_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitCountOutputTypeDefaultArgs instead
     */
    export type UnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandCountOutputTypeDefaultArgs instead
     */
    export type BrandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleCountOutputTypeDefaultArgs instead
     */
    export type VehicleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassItemCountOutputTypeDefaultArgs instead
     */
    export type CanvassItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassCountOutputTypeDefaultArgs instead
     */
    export type CanvassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JOCountOutputTypeDefaultArgs instead
     */
    export type JOCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JOCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RVCountOutputTypeDefaultArgs instead
     */
    export type RVCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RVCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SPRCountOutputTypeDefaultArgs instead
     */
    export type SPRCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SPRCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSCountOutputTypeDefaultArgs instead
     */
    export type MEQSCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierCountOutputTypeDefaultArgs instead
     */
    export type MEQSSupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use POCountOutputTypeDefaultArgs instead
     */
    export type POCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = POCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRCountOutputTypeDefaultArgs instead
     */
    export type RRCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCountOutputTypeDefaultArgs instead
     */
    export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTypeCountOutputTypeDefaultArgs instead
     */
    export type ItemTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandDefaultArgs instead
     */
    export type BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDefaultArgs instead
     */
    export type VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassItemDefaultArgs instead
     */
    export type CanvassItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CanvassDefaultArgs instead
     */
    export type CanvassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CanvassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JODefaultArgs instead
     */
    export type JOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JODefaultArgs<ExtArgs>
    /**
     * @deprecated Use JOApproverDefaultArgs instead
     */
    export type JOApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JOApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RVDefaultArgs instead
     */
    export type RVArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RVDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RVApproverDefaultArgs instead
     */
    export type RVApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RVApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SPRDefaultArgs instead
     */
    export type SPRArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SPRDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SPRApproverDefaultArgs instead
     */
    export type SPRApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SPRApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSDefaultArgs instead
     */
    export type MEQSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierDefaultArgs instead
     */
    export type MEQSSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierItemDefaultArgs instead
     */
    export type MEQSSupplierItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSSupplierAttachmentDefaultArgs instead
     */
    export type MEQSSupplierAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSSupplierAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEQSApproverDefaultArgs instead
     */
    export type MEQSApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEQSApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PODefaultArgs instead
     */
    export type POArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PODefaultArgs<ExtArgs>
    /**
     * @deprecated Use POApproverDefaultArgs instead
     */
    export type POApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = POApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRDefaultArgs instead
     */
    export type RRArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRApproverDefaultArgs instead
     */
    export type RRApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRApproverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RRItemDefaultArgs instead
     */
    export type RRItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RRItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTypeDefaultArgs instead
     */
    export type ItemTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTransactionDefaultArgs instead
     */
    export type ItemTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTransactionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}